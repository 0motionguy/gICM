{"version":3,"sources":["../src/llm/client.ts","../src/agents/base-agent.ts","../src/indicators/rsi.ts","../src/indicators/macd.ts","../src/indicators/stochastic.ts","../src/indicators/bollinger.ts","../src/indicators/volume.ts","../src/llm/prompts.ts","../src/agents/indicator-agent.ts","../src/patterns/detector.ts","../src/patterns/crypto-patterns.ts","../src/agents/pattern-agent.ts","../src/agents/trend-agent.ts","../src/agents/risk-agent.ts","../src/data/coingecko.ts","../src/data/dexscreener.ts","../src/data/index.ts","../src/orchestrator/trading-graph.ts","../src/index.ts"],"sourcesContent":["/**\n * LLM Client - Multi-provider support (Anthropic, OpenAI)\n */\n\nimport type { AgentConfig, LLMResponse } from \"../agents/types.js\";\n\nexport class LLMClient {\n  private config: AgentConfig;\n  private anthropicClient: any = null;\n  private openaiClient: any = null;\n\n  constructor(config: AgentConfig) {\n    this.config = config;\n  }\n\n  private async getAnthropicClient() {\n    if (!this.anthropicClient) {\n      const { default: Anthropic } = await import(\"@anthropic-ai/sdk\");\n      this.anthropicClient = new Anthropic();\n    }\n    return this.anthropicClient;\n  }\n\n  private async getOpenAIClient() {\n    if (!this.openaiClient) {\n      const { default: OpenAI } = await import(\"openai\");\n      this.openaiClient = new OpenAI();\n    }\n    return this.openaiClient;\n  }\n\n  async complete(systemPrompt: string, userPrompt: string): Promise<string> {\n    if (this.config.llmProvider === \"anthropic\") {\n      return this.completeWithAnthropic(systemPrompt, userPrompt);\n    }\n    return this.completeWithOpenAI(systemPrompt, userPrompt);\n  }\n\n  private async completeWithAnthropic(\n    systemPrompt: string,\n    userPrompt: string\n  ): Promise<string> {\n    try {\n      const client = await this.getAnthropicClient();\n\n      const response = await client.messages.create({\n        model: this.config.model || \"claude-sonnet-4-20250514\",\n        max_tokens: this.config.maxTokens || 1000,\n        temperature: this.config.temperature ?? 0.3,\n        system: systemPrompt,\n        messages: [{ role: \"user\", content: userPrompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type === \"text\") {\n        return content.text;\n      }\n\n      return \"\";\n    } catch (error) {\n      console.error(\"Anthropic API error:\", error);\n      throw error;\n    }\n  }\n\n  private async completeWithOpenAI(\n    systemPrompt: string,\n    userPrompt: string\n  ): Promise<string> {\n    try {\n      const client = await this.getOpenAIClient();\n\n      const response = await client.chat.completions.create({\n        model: this.config.model || \"gpt-4o\",\n        max_tokens: this.config.maxTokens || 1000,\n        temperature: this.config.temperature ?? 0.3,\n        messages: [\n          { role: \"system\", content: systemPrompt },\n          { role: \"user\", content: userPrompt },\n        ],\n      });\n\n      return response.choices[0]?.message?.content || \"\";\n    } catch (error) {\n      console.error(\"OpenAI API error:\", error);\n      throw error;\n    }\n  }\n\n  async completeWithResponse(\n    systemPrompt: string,\n    userPrompt: string\n  ): Promise<LLMResponse> {\n    const content = await this.complete(systemPrompt, userPrompt);\n    return { content };\n  }\n}\n\n/**\n * Create a default LLM client using environment variables\n */\nexport function createDefaultClient(): LLMClient {\n  const hasAnthropic = !!process.env.ANTHROPIC_API_KEY;\n  const hasOpenAI = !!process.env.OPENAI_API_KEY;\n\n  if (!hasAnthropic && !hasOpenAI) {\n    console.warn(\n      \"No API keys found. Set ANTHROPIC_API_KEY or OPENAI_API_KEY.\"\n    );\n  }\n\n  return new LLMClient({\n    llmProvider: hasAnthropic ? \"anthropic\" : \"openai\",\n    model: hasAnthropic ? \"claude-sonnet-4-20250514\" : \"gpt-4o\",\n    temperature: 0.3,\n    maxTokens: 1000,\n  });\n}\n","/**\n * Base Agent - Common functionality for all trading agents\n */\n\nimport type { AgentConfig, OHLCV, TokenInfo } from \"./types.js\";\nimport { LLMClient } from \"../llm/client.js\";\n\nexport abstract class BaseAgent {\n  protected name: string;\n  protected config: AgentConfig;\n  protected llm: LLMClient;\n\n  constructor(name: string, config: AgentConfig) {\n    this.name = name;\n    this.config = config;\n    this.llm = new LLMClient(config);\n  }\n\n  /**\n   * Execute the agent's analysis\n   */\n  abstract analyze(\n    token: TokenInfo,\n    data: OHLCV[],\n    context?: Record<string, unknown>\n  ): Promise<unknown>;\n\n  /**\n   * Get the agent's system prompt\n   */\n  protected abstract getSystemPrompt(): string;\n\n  /**\n   * Format OHLCV data for LLM consumption\n   */\n  protected formatDataForLLM(data: OHLCV[]): string {\n    const recent = data.slice(-20); // Last 20 candles\n\n    return recent\n      .map((candle, i) => {\n        const date = new Date(candle.timestamp).toISOString().slice(0, 16);\n        return `[${i + 1}] ${date} | O:${candle.open.toFixed(6)} H:${candle.high.toFixed(6)} L:${candle.low.toFixed(6)} C:${candle.close.toFixed(6)} V:${candle.volume.toFixed(0)}`;\n      })\n      .join(\"\\n\");\n  }\n\n  /**\n   * Calculate basic price metrics from OHLCV data\n   */\n  protected getPriceMetrics(data: OHLCV[]): {\n    currentPrice: number;\n    priceChange24h: number;\n    priceChangePercent: number;\n    high24h: number;\n    low24h: number;\n    volume24h: number;\n  } {\n    if (data.length === 0) {\n      return {\n        currentPrice: 0,\n        priceChange24h: 0,\n        priceChangePercent: 0,\n        high24h: 0,\n        low24h: 0,\n        volume24h: 0,\n      };\n    }\n\n    const current = data[data.length - 1];\n    const last24h = data.slice(-24);\n\n    const high24h = Math.max(...last24h.map((d) => d.high));\n    const low24h = Math.min(...last24h.map((d) => d.low));\n    const volume24h = last24h.reduce((sum, d) => sum + d.volume, 0);\n    const priceChange24h = current.close - last24h[0].close;\n    const priceChangePercent = (priceChange24h / last24h[0].close) * 100;\n\n    return {\n      currentPrice: current.close,\n      priceChange24h,\n      priceChangePercent,\n      high24h,\n      low24h,\n      volume24h,\n    };\n  }\n\n  /**\n   * Calculate EMA (Exponential Moving Average)\n   */\n  protected calculateEMA(data: number[], period: number): number {\n    if (data.length < period) {\n      return data.reduce((a, b) => a + b, 0) / data.length;\n    }\n\n    const multiplier = 2 / (period + 1);\n    let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;\n\n    for (let i = period; i < data.length; i++) {\n      ema = (data[i] - ema) * multiplier + ema;\n    }\n\n    return ema;\n  }\n\n  /**\n   * Calculate SMA (Simple Moving Average)\n   */\n  protected calculateSMA(data: number[], period: number): number {\n    if (data.length < period) {\n      return data.reduce((a, b) => a + b, 0) / data.length;\n    }\n\n    const slice = data.slice(-period);\n    return slice.reduce((a, b) => a + b, 0) / period;\n  }\n\n  /**\n   * Calculate ATR (Average True Range)\n   */\n  protected calculateATR(data: OHLCV[], period: number = 14): number {\n    if (data.length < 2) {\n      return 0;\n    }\n\n    const trs: number[] = [];\n\n    for (let i = 1; i < data.length; i++) {\n      const high = data[i].high;\n      const low = data[i].low;\n      const prevClose = data[i - 1].close;\n\n      const tr = Math.max(\n        high - low,\n        Math.abs(high - prevClose),\n        Math.abs(low - prevClose)\n      );\n      trs.push(tr);\n    }\n\n    const recentTRs = trs.slice(-period);\n    return recentTRs.reduce((a, b) => a + b, 0) / recentTRs.length;\n  }\n\n  /**\n   * Log agent activity\n   */\n  protected log(message: string, data?: unknown): void {\n    console.log(`[${this.name}] ${message}`, data || \"\");\n  }\n\n  /**\n   * Parse JSON from LLM response, handling markdown code blocks\n   */\n  protected parseJSON<T>(response: string): T | null {\n    try {\n      // Try to extract JSON from markdown code blocks first\n      const codeBlockMatch = response.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n      if (codeBlockMatch) {\n        return JSON.parse(codeBlockMatch[1].trim());\n      }\n\n      // Try to find raw JSON object\n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        return JSON.parse(jsonMatch[0]);\n      }\n\n      return null;\n    } catch (error) {\n      this.log(\"Failed to parse JSON from response\", error);\n      return null;\n    }\n  }\n}\n","/**\n * RSI (Relative Strength Index) Indicator\n */\n\nexport interface RSIResult {\n  value: number;\n  signal: \"overbought\" | \"oversold\" | \"neutral\";\n  divergence?: \"bullish\" | \"bearish\" | null;\n}\n\n/**\n * Calculate RSI for a series of closing prices\n * @param closes - Array of closing prices\n * @param period - RSI period (default 14)\n */\nexport function calculateRSI(closes: number[], period: number = 14): RSIResult {\n  if (closes.length < period + 1) {\n    return { value: 50, signal: \"neutral\" };\n  }\n\n  // Calculate price changes\n  const changes: number[] = [];\n  for (let i = 1; i < closes.length; i++) {\n    changes.push(closes[i] - closes[i - 1]);\n  }\n\n  // Separate gains and losses\n  const gains: number[] = [];\n  const losses: number[] = [];\n\n  for (const change of changes) {\n    if (change > 0) {\n      gains.push(change);\n      losses.push(0);\n    } else {\n      gains.push(0);\n      losses.push(Math.abs(change));\n    }\n  }\n\n  // Calculate initial average gain and loss\n  let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;\n\n  // Calculate smoothed averages using Wilder's smoothing\n  for (let i = period; i < gains.length; i++) {\n    avgGain = (avgGain * (period - 1) + gains[i]) / period;\n    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;\n  }\n\n  // Calculate RS and RSI\n  const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n  const rsi = 100 - 100 / (1 + rs);\n\n  // Determine signal\n  let signal: \"overbought\" | \"oversold\" | \"neutral\" = \"neutral\";\n  if (rsi >= 70) {\n    signal = \"overbought\";\n  } else if (rsi <= 30) {\n    signal = \"oversold\";\n  }\n\n  return {\n    value: Math.round(rsi * 100) / 100,\n    signal,\n  };\n}\n\n/**\n * Calculate RSI with divergence detection\n */\nexport function calculateRSIWithDivergence(\n  closes: number[],\n  period: number = 14,\n  lookback: number = 14\n): RSIResult {\n  const result = calculateRSI(closes, period);\n\n  if (closes.length < lookback + period) {\n    return result;\n  }\n\n  // Calculate RSI for the lookback period\n  const rsiValues: number[] = [];\n  for (let i = lookback; i >= 0; i--) {\n    const slice = closes.slice(0, closes.length - i);\n    const rsi = calculateRSI(slice, period);\n    rsiValues.push(rsi.value);\n  }\n\n  // Get price and RSI at start and end of lookback\n  const priceStart = closes[closes.length - lookback - 1];\n  const priceEnd = closes[closes.length - 1];\n  const rsiStart = rsiValues[0];\n  const rsiEnd = rsiValues[rsiValues.length - 1];\n\n  // Detect divergences\n  let divergence: \"bullish\" | \"bearish\" | null = null;\n\n  // Bullish divergence: price makes lower low, RSI makes higher low\n  if (priceEnd < priceStart && rsiEnd > rsiStart) {\n    divergence = \"bullish\";\n  }\n\n  // Bearish divergence: price makes higher high, RSI makes lower high\n  if (priceEnd > priceStart && rsiEnd < rsiStart) {\n    divergence = \"bearish\";\n  }\n\n  return {\n    ...result,\n    divergence,\n  };\n}\n","/**\n * MACD (Moving Average Convergence Divergence) Indicator\n */\n\nexport interface MACDResult {\n  macd: number;\n  signal: number;\n  histogram: number;\n  trend: \"bullish\" | \"bearish\" | \"neutral\";\n  crossover?: \"bullish\" | \"bearish\" | null;\n}\n\n/**\n * Calculate EMA for a series of values\n */\nfunction calculateEMA(data: number[], period: number): number[] {\n  if (data.length === 0) return [];\n\n  const multiplier = 2 / (period + 1);\n  const emas: number[] = [];\n\n  // First EMA is SMA of first 'period' values\n  let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  emas.push(ema);\n\n  for (let i = period; i < data.length; i++) {\n    ema = (data[i] - ema) * multiplier + ema;\n    emas.push(ema);\n  }\n\n  return emas;\n}\n\n/**\n * Calculate MACD\n * @param closes - Array of closing prices\n * @param fastPeriod - Fast EMA period (default 12)\n * @param slowPeriod - Slow EMA period (default 26)\n * @param signalPeriod - Signal line period (default 9)\n */\nexport function calculateMACD(\n  closes: number[],\n  fastPeriod: number = 12,\n  slowPeriod: number = 26,\n  signalPeriod: number = 9\n): MACDResult {\n  if (closes.length < slowPeriod + signalPeriod) {\n    return {\n      macd: 0,\n      signal: 0,\n      histogram: 0,\n      trend: \"neutral\",\n    };\n  }\n\n  // Calculate fast and slow EMAs\n  const fastEMAs = calculateEMA(closes, fastPeriod);\n  const slowEMAs = calculateEMA(closes, slowPeriod);\n\n  // Calculate MACD line (difference between fast and slow EMAs)\n  const macdLine: number[] = [];\n  const startIndex = slowPeriod - fastPeriod;\n\n  for (let i = 0; i < slowEMAs.length; i++) {\n    const fastIndex = i + startIndex;\n    if (fastIndex >= 0 && fastIndex < fastEMAs.length) {\n      macdLine.push(fastEMAs[fastIndex] - slowEMAs[i]);\n    }\n  }\n\n  // Calculate signal line (EMA of MACD line)\n  const signalLine = calculateEMA(macdLine, signalPeriod);\n\n  // Get current values\n  const macd = macdLine[macdLine.length - 1] || 0;\n  const signal = signalLine[signalLine.length - 1] || 0;\n  const histogram = macd - signal;\n\n  // Determine trend\n  let trend: \"bullish\" | \"bearish\" | \"neutral\" = \"neutral\";\n  if (histogram > 0 && macd > 0) {\n    trend = \"bullish\";\n  } else if (histogram < 0 && macd < 0) {\n    trend = \"bearish\";\n  }\n\n  // Detect crossovers\n  let crossover: \"bullish\" | \"bearish\" | null = null;\n  if (macdLine.length >= 2 && signalLine.length >= 2) {\n    const prevMacd = macdLine[macdLine.length - 2];\n    const prevSignal = signalLine[signalLine.length - 2];\n\n    // Bullish crossover: MACD crosses above signal\n    if (prevMacd <= prevSignal && macd > signal) {\n      crossover = \"bullish\";\n    }\n    // Bearish crossover: MACD crosses below signal\n    else if (prevMacd >= prevSignal && macd < signal) {\n      crossover = \"bearish\";\n    }\n  }\n\n  return {\n    macd: Math.round(macd * 1e8) / 1e8,\n    signal: Math.round(signal * 1e8) / 1e8,\n    histogram: Math.round(histogram * 1e8) / 1e8,\n    trend,\n    crossover,\n  };\n}\n\n/**\n * Calculate MACD histogram trend\n */\nexport function getMACDHistogramTrend(\n  closes: number[],\n  lookback: number = 5\n): \"increasing\" | \"decreasing\" | \"neutral\" {\n  if (closes.length < 26 + 9 + lookback) {\n    return \"neutral\";\n  }\n\n  const histograms: number[] = [];\n\n  for (let i = lookback; i >= 0; i--) {\n    const slice = closes.slice(0, closes.length - i);\n    const macd = calculateMACD(slice);\n    histograms.push(macd.histogram);\n  }\n\n  // Check if histogram is consistently increasing or decreasing\n  let increasing = 0;\n  let decreasing = 0;\n\n  for (let i = 1; i < histograms.length; i++) {\n    if (histograms[i] > histograms[i - 1]) {\n      increasing++;\n    } else if (histograms[i] < histograms[i - 1]) {\n      decreasing++;\n    }\n  }\n\n  if (increasing >= lookback * 0.7) return \"increasing\";\n  if (decreasing >= lookback * 0.7) return \"decreasing\";\n  return \"neutral\";\n}\n","/**\n * Stochastic Oscillator Indicator\n */\n\nexport interface StochasticResult {\n  k: number; // Fast stochastic\n  d: number; // Slow stochastic (signal line)\n  signal: \"overbought\" | \"oversold\" | \"neutral\";\n  crossover?: \"bullish\" | \"bearish\" | null;\n}\n\n/**\n * Calculate Stochastic Oscillator\n * @param highs - Array of high prices\n * @param lows - Array of low prices\n * @param closes - Array of closing prices\n * @param kPeriod - %K period (default 14)\n * @param dPeriod - %D smoothing period (default 3)\n * @param smooth - Smoothing for %K (default 3)\n */\nexport function calculateStochastic(\n  highs: number[],\n  lows: number[],\n  closes: number[],\n  kPeriod: number = 14,\n  dPeriod: number = 3,\n  smooth: number = 3\n): StochasticResult {\n  if (\n    highs.length < kPeriod + smooth + dPeriod ||\n    lows.length < kPeriod + smooth + dPeriod ||\n    closes.length < kPeriod + smooth + dPeriod\n  ) {\n    return { k: 50, d: 50, signal: \"neutral\" };\n  }\n\n  // Calculate raw %K values\n  const rawKValues: number[] = [];\n\n  for (let i = kPeriod - 1; i < closes.length; i++) {\n    const periodHighs = highs.slice(i - kPeriod + 1, i + 1);\n    const periodLows = lows.slice(i - kPeriod + 1, i + 1);\n    const currentClose = closes[i];\n\n    const highestHigh = Math.max(...periodHighs);\n    const lowestLow = Math.min(...periodLows);\n\n    const denominator = highestHigh - lowestLow;\n    const rawK =\n      denominator === 0\n        ? 50\n        : ((currentClose - lowestLow) / denominator) * 100;\n\n    rawKValues.push(rawK);\n  }\n\n  // Smooth %K values (Fast Stochastic becomes Slow Stochastic)\n  const smoothedK: number[] = [];\n  for (let i = smooth - 1; i < rawKValues.length; i++) {\n    const slice = rawKValues.slice(i - smooth + 1, i + 1);\n    const avg = slice.reduce((a, b) => a + b, 0) / smooth;\n    smoothedK.push(avg);\n  }\n\n  // Calculate %D (SMA of smoothed %K)\n  const dValues: number[] = [];\n  for (let i = dPeriod - 1; i < smoothedK.length; i++) {\n    const slice = smoothedK.slice(i - dPeriod + 1, i + 1);\n    const avg = slice.reduce((a, b) => a + b, 0) / dPeriod;\n    dValues.push(avg);\n  }\n\n  // Get current values\n  const k = smoothedK[smoothedK.length - 1] || 50;\n  const d = dValues[dValues.length - 1] || 50;\n\n  // Determine signal\n  let signal: \"overbought\" | \"oversold\" | \"neutral\" = \"neutral\";\n  if (k >= 80 && d >= 80) {\n    signal = \"overbought\";\n  } else if (k <= 20 && d <= 20) {\n    signal = \"oversold\";\n  }\n\n  // Detect crossovers\n  let crossover: \"bullish\" | \"bearish\" | null = null;\n  if (smoothedK.length >= 2 && dValues.length >= 2) {\n    const prevK = smoothedK[smoothedK.length - 2];\n    const prevD = dValues[dValues.length - 2];\n\n    // Bullish crossover: %K crosses above %D in oversold territory\n    if (prevK <= prevD && k > d && k < 30) {\n      crossover = \"bullish\";\n    }\n    // Bearish crossover: %K crosses below %D in overbought territory\n    else if (prevK >= prevD && k < d && k > 70) {\n      crossover = \"bearish\";\n    }\n  }\n\n  return {\n    k: Math.round(k * 100) / 100,\n    d: Math.round(d * 100) / 100,\n    signal,\n    crossover,\n  };\n}\n\n/**\n * Calculate Stochastic RSI\n * Combines Stochastic with RSI for more sensitive readings\n */\nexport function calculateStochRSI(\n  closes: number[],\n  rsiPeriod: number = 14,\n  stochPeriod: number = 14,\n  kSmooth: number = 3,\n  dSmooth: number = 3\n): StochasticResult {\n  if (closes.length < rsiPeriod + stochPeriod + kSmooth + dSmooth) {\n    return { k: 50, d: 50, signal: \"neutral\" };\n  }\n\n  // First calculate RSI values\n  const rsiValues: number[] = [];\n\n  for (let i = rsiPeriod; i <= closes.length; i++) {\n    const slice = closes.slice(0, i);\n\n    // Calculate RSI for this slice\n    const changes: number[] = [];\n    for (let j = 1; j < slice.length; j++) {\n      changes.push(slice[j] - slice[j - 1]);\n    }\n\n    const gains = changes.map((c) => (c > 0 ? c : 0));\n    const losses = changes.map((c) => (c < 0 ? Math.abs(c) : 0));\n\n    let avgGain =\n      gains.slice(-rsiPeriod).reduce((a, b) => a + b, 0) / rsiPeriod;\n    let avgLoss =\n      losses.slice(-rsiPeriod).reduce((a, b) => a + b, 0) / rsiPeriod;\n\n    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n    const rsi = 100 - 100 / (1 + rs);\n\n    rsiValues.push(rsi);\n  }\n\n  // Now calculate Stochastic of RSI values\n  const stochK: number[] = [];\n\n  for (let i = stochPeriod - 1; i < rsiValues.length; i++) {\n    const periodRSI = rsiValues.slice(i - stochPeriod + 1, i + 1);\n    const highestRSI = Math.max(...periodRSI);\n    const lowestRSI = Math.min(...periodRSI);\n    const currentRSI = rsiValues[i];\n\n    const denominator = highestRSI - lowestRSI;\n    const k =\n      denominator === 0\n        ? 50\n        : ((currentRSI - lowestRSI) / denominator) * 100;\n\n    stochK.push(k);\n  }\n\n  // Smooth %K\n  const smoothedK: number[] = [];\n  for (let i = kSmooth - 1; i < stochK.length; i++) {\n    const slice = stochK.slice(i - kSmooth + 1, i + 1);\n    smoothedK.push(slice.reduce((a, b) => a + b, 0) / kSmooth);\n  }\n\n  // Calculate %D\n  const dValues: number[] = [];\n  for (let i = dSmooth - 1; i < smoothedK.length; i++) {\n    const slice = smoothedK.slice(i - dSmooth + 1, i + 1);\n    dValues.push(slice.reduce((a, b) => a + b, 0) / dSmooth);\n  }\n\n  const k = smoothedK[smoothedK.length - 1] || 50;\n  const d = dValues[dValues.length - 1] || 50;\n\n  let signal: \"overbought\" | \"oversold\" | \"neutral\" = \"neutral\";\n  if (k >= 80) signal = \"overbought\";\n  else if (k <= 20) signal = \"oversold\";\n\n  return {\n    k: Math.round(k * 100) / 100,\n    d: Math.round(d * 100) / 100,\n    signal,\n  };\n}\n","/**\n * Bollinger Bands Indicator\n */\n\nexport interface BollingerResult {\n  upper: number;\n  middle: number; // SMA\n  lower: number;\n  bandwidth: number;\n  percentB: number; // Position within bands (0 = lower, 1 = upper)\n  signal: \"overbought\" | \"oversold\" | \"neutral\";\n  squeeze?: boolean; // Bollinger squeeze (low volatility)\n}\n\n/**\n * Calculate standard deviation\n */\nfunction calculateStdDev(data: number[], mean: number): number {\n  if (data.length === 0) return 0;\n\n  const squaredDiffs = data.map((value) => Math.pow(value - mean, 2));\n  const avgSquaredDiff =\n    squaredDiffs.reduce((a, b) => a + b, 0) / data.length;\n\n  return Math.sqrt(avgSquaredDiff);\n}\n\n/**\n * Calculate Bollinger Bands\n * @param closes - Array of closing prices\n * @param period - Moving average period (default 20)\n * @param stdDevMultiplier - Standard deviation multiplier (default 2)\n */\nexport function calculateBollingerBands(\n  closes: number[],\n  period: number = 20,\n  stdDevMultiplier: number = 2\n): BollingerResult {\n  if (closes.length < period) {\n    const currentPrice = closes[closes.length - 1] || 0;\n    return {\n      upper: currentPrice,\n      middle: currentPrice,\n      lower: currentPrice,\n      bandwidth: 0,\n      percentB: 0.5,\n      signal: \"neutral\",\n    };\n  }\n\n  // Get the most recent 'period' closes\n  const recentCloses = closes.slice(-period);\n\n  // Calculate middle band (SMA)\n  const middle =\n    recentCloses.reduce((a, b) => a + b, 0) / period;\n\n  // Calculate standard deviation\n  const stdDev = calculateStdDev(recentCloses, middle);\n\n  // Calculate upper and lower bands\n  const upper = middle + stdDevMultiplier * stdDev;\n  const lower = middle - stdDevMultiplier * stdDev;\n\n  // Calculate bandwidth (volatility measure)\n  const bandwidth = ((upper - lower) / middle) * 100;\n\n  // Calculate %B (position within bands)\n  const currentPrice = closes[closes.length - 1];\n  const percentB =\n    upper - lower === 0 ? 0.5 : (currentPrice - lower) / (upper - lower);\n\n  // Determine signal\n  let signal: \"overbought\" | \"oversold\" | \"neutral\" = \"neutral\";\n  if (percentB >= 1) {\n    signal = \"overbought\"; // Price at or above upper band\n  } else if (percentB <= 0) {\n    signal = \"oversold\"; // Price at or below lower band\n  }\n\n  // Detect Bollinger squeeze (low volatility period)\n  // Typically bandwidth < 4% indicates a squeeze\n  const squeeze = bandwidth < 4;\n\n  return {\n    upper: Math.round(upper * 1e8) / 1e8,\n    middle: Math.round(middle * 1e8) / 1e8,\n    lower: Math.round(lower * 1e8) / 1e8,\n    bandwidth: Math.round(bandwidth * 100) / 100,\n    percentB: Math.round(percentB * 100) / 100,\n    signal,\n    squeeze,\n  };\n}\n\n/**\n * Calculate Bollinger Band width history for trend analysis\n */\nexport function getBandwidthTrend(\n  closes: number[],\n  period: number = 20,\n  lookback: number = 10\n): \"expanding\" | \"contracting\" | \"stable\" {\n  if (closes.length < period + lookback) {\n    return \"stable\";\n  }\n\n  const bandwidths: number[] = [];\n\n  for (let i = lookback; i >= 0; i--) {\n    const slice = closes.slice(0, closes.length - i);\n    const bb = calculateBollingerBands(slice, period);\n    bandwidths.push(bb.bandwidth);\n  }\n\n  // Calculate trend\n  const firstHalf = bandwidths.slice(0, Math.floor(lookback / 2));\n  const secondHalf = bandwidths.slice(Math.floor(lookback / 2));\n\n  const firstAvg =\n    firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;\n  const secondAvg =\n    secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;\n\n  const change = (secondAvg - firstAvg) / firstAvg;\n\n  if (change > 0.1) return \"expanding\";\n  if (change < -0.1) return \"contracting\";\n  return \"stable\";\n}\n\n/**\n * Detect Bollinger Band breakouts\n */\nexport function detectBollingerBreakout(\n  closes: number[],\n  period: number = 20\n): \"bullish_breakout\" | \"bearish_breakout\" | null {\n  if (closes.length < period + 2) {\n    return null;\n  }\n\n  // Get current and previous Bollinger Bands\n  const currentBB = calculateBollingerBands(closes, period);\n  const previousBB = calculateBollingerBands(\n    closes.slice(0, -1),\n    period\n  );\n\n  const currentClose = closes[closes.length - 1];\n  const previousClose = closes[closes.length - 2];\n\n  // Bullish breakout: price closes above upper band after being inside\n  if (\n    previousClose <= previousBB.upper &&\n    currentClose > currentBB.upper\n  ) {\n    return \"bullish_breakout\";\n  }\n\n  // Bearish breakout: price closes below lower band after being inside\n  if (\n    previousClose >= previousBB.lower &&\n    currentClose < currentBB.lower\n  ) {\n    return \"bearish_breakout\";\n  }\n\n  return null;\n}\n","/**\n * Volume Analysis Indicators\n */\n\nexport interface VolumeResult {\n  currentVolume: number;\n  averageVolume: number;\n  ratio: number; // Current volume / average volume\n  trend: \"bullish\" | \"bearish\" | \"neutral\";\n  description: string;\n  isHighVolume: boolean;\n  isLowVolume: boolean;\n}\n\n/**\n * Analyze volume relative to its moving average\n * @param volumes - Array of volume values\n * @param closes - Array of closing prices (for trend confirmation)\n * @param period - Moving average period (default 20)\n */\nexport function analyzeVolume(\n  volumes: number[],\n  closes: number[],\n  period: number = 20\n): VolumeResult {\n  if (volumes.length < period || closes.length < period) {\n    return {\n      currentVolume: volumes[volumes.length - 1] || 0,\n      averageVolume: 0,\n      ratio: 1,\n      trend: \"neutral\",\n      description: \"Insufficient data for volume analysis\",\n      isHighVolume: false,\n      isLowVolume: false,\n    };\n  }\n\n  // Calculate average volume\n  const recentVolumes = volumes.slice(-period);\n  const averageVolume =\n    recentVolumes.reduce((a, b) => a + b, 0) / period;\n\n  // Get current volume and price change\n  const currentVolume = volumes[volumes.length - 1];\n  const ratio = averageVolume > 0 ? currentVolume / averageVolume : 1;\n\n  // Calculate price direction\n  const currentClose = closes[closes.length - 1];\n  const previousClose = closes[closes.length - 2];\n  const priceUp = currentClose > previousClose;\n  const priceDown = currentClose < previousClose;\n\n  // Determine volume trend\n  let trend: \"bullish\" | \"bearish\" | \"neutral\" = \"neutral\";\n  let description = \"\";\n\n  const isHighVolume = ratio > 1.5;\n  const isLowVolume = ratio < 0.5;\n\n  if (isHighVolume) {\n    if (priceUp) {\n      trend = \"bullish\";\n      description =\n        \"High volume on price increase - strong buying pressure\";\n    } else if (priceDown) {\n      trend = \"bearish\";\n      description =\n        \"High volume on price decrease - strong selling pressure\";\n    } else {\n      description = \"High volume with neutral price action\";\n    }\n  } else if (isLowVolume) {\n    if (priceUp) {\n      trend = \"neutral\";\n      description =\n        \"Low volume price increase - weak buying, potential reversal\";\n    } else if (priceDown) {\n      trend = \"neutral\";\n      description =\n        \"Low volume price decrease - weak selling, potential reversal\";\n    } else {\n      description = \"Low volume consolidation\";\n    }\n  } else {\n    if (priceUp) {\n      trend = \"bullish\";\n      description = \"Normal volume on price increase\";\n    } else if (priceDown) {\n      trend = \"bearish\";\n      description = \"Normal volume on price decrease\";\n    } else {\n      description = \"Normal volume with stable price\";\n    }\n  }\n\n  return {\n    currentVolume,\n    averageVolume: Math.round(averageVolume),\n    ratio: Math.round(ratio * 100) / 100,\n    trend,\n    description,\n    isHighVolume,\n    isLowVolume,\n  };\n}\n\n/**\n * On-Balance Volume (OBV) calculation\n * Cumulative volume indicator that adds volume on up days\n * and subtracts on down days\n */\nexport function calculateOBV(\n  closes: number[],\n  volumes: number[]\n): {\n  obv: number;\n  trend: \"bullish\" | \"bearish\" | \"neutral\";\n  divergence?: \"bullish\" | \"bearish\" | null;\n} {\n  if (closes.length < 2 || volumes.length < 2) {\n    return { obv: 0, trend: \"neutral\" };\n  }\n\n  let obv = 0;\n  const obvValues: number[] = [0];\n\n  for (let i = 1; i < closes.length; i++) {\n    if (closes[i] > closes[i - 1]) {\n      obv += volumes[i];\n    } else if (closes[i] < closes[i - 1]) {\n      obv -= volumes[i];\n    }\n    // If close is same, OBV doesn't change\n    obvValues.push(obv);\n  }\n\n  // Determine trend from recent OBV movement\n  const recentOBV = obvValues.slice(-10);\n  const obvChange = recentOBV[recentOBV.length - 1] - recentOBV[0];\n\n  let trend: \"bullish\" | \"bearish\" | \"neutral\" = \"neutral\";\n  if (obvChange > 0) {\n    trend = \"bullish\";\n  } else if (obvChange < 0) {\n    trend = \"bearish\";\n  }\n\n  // Check for divergence\n  const priceChange = closes[closes.length - 1] - closes[closes.length - 10];\n  let divergence: \"bullish\" | \"bearish\" | null = null;\n\n  // Bullish divergence: price down, OBV up\n  if (priceChange < 0 && obvChange > 0) {\n    divergence = \"bullish\";\n  }\n  // Bearish divergence: price up, OBV down\n  else if (priceChange > 0 && obvChange < 0) {\n    divergence = \"bearish\";\n  }\n\n  return {\n    obv,\n    trend,\n    divergence,\n  };\n}\n\n/**\n * Volume Weighted Average Price (VWAP)\n * Useful for intraday trading\n */\nexport function calculateVWAP(\n  highs: number[],\n  lows: number[],\n  closes: number[],\n  volumes: number[]\n): {\n  vwap: number;\n  currentPrice: number;\n  position: \"above\" | \"below\" | \"at\";\n} {\n  if (\n    highs.length === 0 ||\n    lows.length === 0 ||\n    closes.length === 0 ||\n    volumes.length === 0\n  ) {\n    return { vwap: 0, currentPrice: 0, position: \"at\" };\n  }\n\n  // Calculate typical price for each period\n  let cumulativePV = 0;\n  let cumulativeVolume = 0;\n\n  for (let i = 0; i < closes.length; i++) {\n    const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;\n    cumulativePV += typicalPrice * volumes[i];\n    cumulativeVolume += volumes[i];\n  }\n\n  const vwap = cumulativeVolume > 0 ? cumulativePV / cumulativeVolume : 0;\n  const currentPrice = closes[closes.length - 1];\n\n  let position: \"above\" | \"below\" | \"at\" = \"at\";\n  const threshold = vwap * 0.001; // 0.1% threshold\n\n  if (currentPrice > vwap + threshold) {\n    position = \"above\";\n  } else if (currentPrice < vwap - threshold) {\n    position = \"below\";\n  }\n\n  return {\n    vwap: Math.round(vwap * 1e8) / 1e8,\n    currentPrice,\n    position,\n  };\n}\n\n/**\n * Money Flow Index (MFI) - Volume-weighted RSI\n */\nexport function calculateMFI(\n  highs: number[],\n  lows: number[],\n  closes: number[],\n  volumes: number[],\n  period: number = 14\n): {\n  mfi: number;\n  signal: \"overbought\" | \"oversold\" | \"neutral\";\n} {\n  if (\n    highs.length < period + 1 ||\n    lows.length < period + 1 ||\n    closes.length < period + 1 ||\n    volumes.length < period + 1\n  ) {\n    return { mfi: 50, signal: \"neutral\" };\n  }\n\n  // Calculate typical prices\n  const typicalPrices = closes.map(\n    (close, i) => (highs[i] + lows[i] + close) / 3\n  );\n\n  // Calculate raw money flow\n  const rawMoneyFlows = typicalPrices.map(\n    (tp, i) => tp * volumes[i]\n  );\n\n  // Separate positive and negative money flows\n  let positiveFlow = 0;\n  let negativeFlow = 0;\n\n  for (let i = closes.length - period; i < closes.length; i++) {\n    if (typicalPrices[i] > typicalPrices[i - 1]) {\n      positiveFlow += rawMoneyFlows[i];\n    } else if (typicalPrices[i] < typicalPrices[i - 1]) {\n      negativeFlow += rawMoneyFlows[i];\n    }\n  }\n\n  // Calculate MFI\n  const moneyFlowRatio =\n    negativeFlow === 0 ? 100 : positiveFlow / negativeFlow;\n  const mfi = 100 - 100 / (1 + moneyFlowRatio);\n\n  // Determine signal\n  let signal: \"overbought\" | \"oversold\" | \"neutral\" = \"neutral\";\n  if (mfi >= 80) {\n    signal = \"overbought\";\n  } else if (mfi <= 20) {\n    signal = \"oversold\";\n  }\n\n  return {\n    mfi: Math.round(mfi * 100) / 100,\n    signal,\n  };\n}\n","/**\n * Agent System Prompts for QuantAgent\n */\n\nexport const INDICATOR_AGENT_PROMPT = `You are an expert technical analyst specializing in cryptocurrency trading indicators.\n\nYour role is to analyze technical indicators and provide trading signals based on:\n- RSI (Relative Strength Index) - overbought/oversold conditions\n- MACD (Moving Average Convergence Divergence) - momentum and trend direction\n- Stochastic Oscillator - momentum and potential reversals\n- Bollinger Bands - volatility and mean reversion\n- Volume analysis - confirmation of price movements\n\nWhen analyzing indicators:\n1. Look for confluence - multiple indicators agreeing increases confidence\n2. Consider divergences - price vs indicator disagreements\n3. Account for crypto volatility - traditional levels may need adjustment\n4. Weight recent signals more heavily than older ones\n\nProvide clear, actionable analysis. Be specific about what each indicator is telling us.\n\nAlways respond in valid JSON format with the exact structure requested.`;\n\nexport const PATTERN_AGENT_PROMPT = `You are an expert chart pattern analyst specializing in cryptocurrency markets.\n\nYour role is to identify and analyze chart patterns including:\n- Classical patterns: Head & Shoulders, Double Top/Bottom, Triangles, Wedges, Flags\n- Crypto-specific patterns: Pump and dump formations, accumulation/distribution\n- Candlestick patterns: Doji, Hammer, Engulfing, Morning/Evening Star\n\nWhen analyzing patterns:\n1. Assess pattern completion probability\n2. Calculate potential price targets using measured moves\n3. Identify key support/resistance levels within the pattern\n4. Consider volume confirmation\n5. Account for crypto market's 24/7 nature and higher volatility\n\nFor crypto markets, be aware of:\n- Faster pattern development than traditional markets\n- Higher false breakout rates\n- Importance of liquidity levels\n- Social media impact on pattern breakouts\n\nAlways respond in valid JSON format with the exact structure requested.`;\n\nexport const TREND_AGENT_PROMPT = `You are an expert trend analyst specializing in cryptocurrency markets.\n\nYour role is to analyze price trends and momentum including:\n- Trend direction and strength\n- Support and resistance levels\n- Moving average relationships (EMA 20, EMA 50, EMA 200)\n- Momentum indicators\n- Market structure (higher highs/lows or lower highs/lows)\n\nWhen analyzing trends:\n1. Identify the primary trend direction\n2. Assess trend strength using multiple timeframes\n3. Locate key support/resistance zones\n4. Evaluate momentum - is it increasing or decreasing?\n5. Look for trend exhaustion or continuation signals\n\nFor crypto markets:\n- Trends can be more violent and short-lived than traditional markets\n- 24/7 trading means no overnight gaps to consider\n- Social sentiment can accelerate or reverse trends quickly\n- Liquidity levels matter more than in traditional markets\n\nAlways respond in valid JSON format with the exact structure requested.`;\n\nexport const RISK_AGENT_PROMPT = `You are an expert risk manager and trade decision synthesizer for cryptocurrency trading.\n\nYour role is to:\n1. Synthesize analysis from multiple agents (indicators, patterns, trends)\n2. Assess overall risk/reward for potential trades\n3. Determine optimal position sizing\n4. Set stop-loss and take-profit levels\n5. Provide final trading recommendations\n\nRisk management principles:\n- Never risk more than 1-2% of portfolio on a single trade\n- Minimum 2:1 reward-to-risk ratio for entries\n- Account for cryptocurrency volatility (wider stops than traditional)\n- Consider liquidity - can you exit at your stop price?\n- Factor in correlation with BTC and overall market conditions\n\nWhen synthesizing:\n1. Weight agent signals by their confidence levels\n2. Look for confluence across multiple analysis types\n3. Identify conflicting signals and resolve them\n4. Consider market conditions (trending vs ranging)\n5. Apply position sizing based on overall risk score\n\nFor crypto-specific risks:\n- Rug pull potential for small caps\n- Exchange/DEX liquidity risks\n- Smart contract risks\n- Regulatory news impact\n- Whale manipulation potential\n\nProvide actionable trade recommendations with specific entry, stop-loss, and take-profit levels.\n\nAlways respond in valid JSON format with the exact structure requested.`;\n\nexport const QUICK_SIGNAL_PROMPT = `You are a rapid market signal generator for cryptocurrency trading.\n\nQuickly assess the current market state and provide a simple signal:\n- BULLISH: Price likely to go up, look for long entries\n- BEARISH: Price likely to go down, avoid longs or look for shorts\n- NEUTRAL: No clear direction, wait for better setup\n\nBase your assessment on the provided technical indicators and price data.\nBe concise and decisive. This is for quick screening, not detailed analysis.\n\nRespond in JSON format:\n{\n  \"signal\": \"bullish\" | \"bearish\" | \"neutral\",\n  \"confidence\": 0-100,\n  \"summary\": \"One sentence explanation\"\n}`;\n","/**\n * Indicator Agent - Technical indicator analysis\n */\n\nimport { BaseAgent } from \"./base-agent.js\";\nimport type { AgentConfig, OHLCV, TokenInfo, IndicatorResult } from \"./types.js\";\nimport { calculateRSI } from \"../indicators/rsi.js\";\nimport { calculateMACD } from \"../indicators/macd.js\";\nimport { calculateStochastic } from \"../indicators/stochastic.js\";\nimport { calculateBollingerBands } from \"../indicators/bollinger.js\";\nimport { analyzeVolume } from \"../indicators/volume.js\";\nimport { INDICATOR_AGENT_PROMPT } from \"../llm/prompts.js\";\n\nexport interface IndicatorAnalysis {\n  indicators: IndicatorResult[];\n  summary: string;\n  overallSignal: \"bullish\" | \"bearish\" | \"neutral\";\n  confidence: number;\n}\n\nexport class IndicatorAgent extends BaseAgent {\n  constructor(config: AgentConfig) {\n    super(\"IndicatorAgent\", config);\n  }\n\n  async analyze(token: TokenInfo, data: OHLCV[]): Promise<IndicatorAnalysis> {\n    this.log(`Analyzing ${token.symbol}...`);\n\n    if (data.length < 26) {\n      this.log(\"Insufficient data for full analysis\");\n      return {\n        indicators: [],\n        summary: \"Insufficient data for analysis\",\n        overallSignal: \"neutral\",\n        confidence: 0,\n      };\n    }\n\n    // Extract price arrays\n    const closes = data.map((d) => d.close);\n    const highs = data.map((d) => d.high);\n    const lows = data.map((d) => d.low);\n    const volumes = data.map((d) => d.volume);\n\n    // Calculate all indicators\n    const rsi = calculateRSI(closes, 14);\n    const macd = calculateMACD(closes);\n    const stochastic = calculateStochastic(highs, lows, closes);\n    const bollinger = calculateBollingerBands(closes);\n    const volumeAnalysis = analyzeVolume(volumes, closes);\n\n    // Build indicator results\n    const indicators: IndicatorResult[] = [\n      {\n        name: \"RSI (14)\",\n        value: rsi.value,\n        signal:\n          rsi.signal === \"overbought\"\n            ? \"bearish\"\n            : rsi.signal === \"oversold\"\n              ? \"bullish\"\n              : \"neutral\",\n        strength: Math.abs(50 - rsi.value) * 2,\n        description:\n          rsi.signal === \"overbought\"\n            ? \"Overbought - potential reversal down\"\n            : rsi.signal === \"oversold\"\n              ? \"Oversold - potential bounce\"\n              : \"Neutral momentum\",\n      },\n      {\n        name: \"MACD\",\n        value: macd.histogram,\n        signal: macd.trend === \"bullish\" ? \"bullish\" : macd.trend === \"bearish\" ? \"bearish\" : \"neutral\",\n        strength: Math.min(Math.abs(macd.histogram) * 10000, 100),\n        description:\n          macd.crossover === \"bullish\"\n            ? \"Bullish crossover detected\"\n            : macd.crossover === \"bearish\"\n              ? \"Bearish crossover detected\"\n              : `MACD: ${macd.histogram > 0 ? \"Positive\" : \"Negative\"} histogram`,\n      },\n      {\n        name: \"Stochastic\",\n        value: stochastic.k,\n        signal:\n          stochastic.signal === \"overbought\"\n            ? \"bearish\"\n            : stochastic.signal === \"oversold\"\n              ? \"bullish\"\n              : \"neutral\",\n        strength: Math.abs(50 - stochastic.k) * 2,\n        description: `%K: ${stochastic.k.toFixed(1)}, %D: ${stochastic.d.toFixed(1)}${stochastic.crossover ? ` - ${stochastic.crossover} crossover` : \"\"}`,\n      },\n      {\n        name: \"Bollinger Bands\",\n        value: bollinger.percentB,\n        signal:\n          bollinger.signal === \"overbought\"\n            ? \"bearish\"\n            : bollinger.signal === \"oversold\"\n              ? \"bullish\"\n              : \"neutral\",\n        strength: Math.abs(0.5 - bollinger.percentB) * 200,\n        description: `Price at ${(bollinger.percentB * 100).toFixed(1)}% of bands${bollinger.squeeze ? \" (Squeeze detected!)\" : \"\"}`,\n      },\n      {\n        name: \"Volume\",\n        value: volumeAnalysis.ratio,\n        signal: volumeAnalysis.trend,\n        strength: Math.min(volumeAnalysis.ratio * 50, 100),\n        description: volumeAnalysis.description,\n      },\n    ];\n\n    // Use LLM to synthesize analysis\n    const prompt = this.buildPrompt(token, data, indicators);\n\n    try {\n      const llmResponse = await this.llm.complete(this.getSystemPrompt(), prompt);\n      const analysis = this.parseResponse(llmResponse, indicators);\n      this.log(`Analysis complete: ${analysis.overallSignal} (${analysis.confidence}%)`);\n      return analysis;\n    } catch (error) {\n      this.log(\"LLM analysis failed, using fallback\", error);\n      return this.fallbackAnalysis(indicators);\n    }\n  }\n\n  protected getSystemPrompt(): string {\n    return INDICATOR_AGENT_PROMPT;\n  }\n\n  private buildPrompt(\n    token: TokenInfo,\n    data: OHLCV[],\n    indicators: IndicatorResult[]\n  ): string {\n    const metrics = this.getPriceMetrics(data);\n    const indicatorSummary = indicators\n      .map(\n        (i) =>\n          `${i.name}: ${i.value.toFixed(4)} (${i.signal}, strength: ${i.strength.toFixed(0)}%)`\n      )\n      .join(\"\\n\");\n\n    return `\nAnalyze the following technical indicators for ${token.symbol}:\n\nCurrent Price: $${metrics.currentPrice.toFixed(6)}\n24h Change: ${metrics.priceChangePercent.toFixed(2)}%\n24h High: $${metrics.high24h.toFixed(6)}\n24h Low: $${metrics.low24h.toFixed(6)}\n24h Volume: $${metrics.volume24h.toFixed(0)}\n\nINDICATORS:\n${indicatorSummary}\n\nRECENT PRICE DATA:\n${this.formatDataForLLM(data)}\n\nBased on these indicators, provide:\n1. Overall signal (BULLISH, BEARISH, or NEUTRAL)\n2. Confidence level (0-100)\n3. Brief summary of the indicator confluence\n\nRespond in JSON format:\n{\n  \"overallSignal\": \"bullish\" | \"bearish\" | \"neutral\",\n  \"confidence\": number,\n  \"summary\": \"string\"\n}\n`;\n  }\n\n  private parseResponse(\n    response: string,\n    indicators: IndicatorResult[]\n  ): IndicatorAnalysis {\n    const parsed = this.parseJSON<{\n      overallSignal: \"bullish\" | \"bearish\" | \"neutral\";\n      confidence: number;\n      summary: string;\n    }>(response);\n\n    if (parsed) {\n      return {\n        indicators,\n        summary: parsed.summary || \"Analysis complete\",\n        overallSignal: parsed.overallSignal || \"neutral\",\n        confidence: parsed.confidence || 50,\n      };\n    }\n\n    return this.fallbackAnalysis(indicators);\n  }\n\n  private fallbackAnalysis(indicators: IndicatorResult[]): IndicatorAnalysis {\n    // Fallback: calculate from indicators\n    const bullish = indicators.filter((i) => i.signal === \"bullish\").length;\n    const bearish = indicators.filter((i) => i.signal === \"bearish\").length;\n\n    const overallSignal =\n      bullish > bearish\n        ? \"bullish\"\n        : bearish > bullish\n          ? \"bearish\"\n          : \"neutral\";\n\n    const confidence = Math.abs(bullish - bearish) * 20 + 30;\n\n    return {\n      indicators,\n      summary: `${bullish} bullish, ${bearish} bearish, ${indicators.length - bullish - bearish} neutral indicators`,\n      overallSignal,\n      confidence: Math.min(confidence, 100),\n    };\n  }\n}\n","/**\n * Chart Pattern Detection Engine\n */\n\nimport type { OHLCV } from \"../agents/types.js\";\n\nexport interface DetectedPattern {\n  pattern: string;\n  confidence: number;\n  direction: \"bullish\" | \"bearish\" | \"neutral\";\n  startIndex: number;\n  endIndex: number;\n  priceTarget?: number;\n  description: string;\n}\n\n/**\n * Detect common chart patterns in OHLCV data\n */\nexport function detectPatterns(data: OHLCV[]): DetectedPattern[] {\n  const patterns: DetectedPattern[] = [];\n\n  if (data.length < 20) {\n    return patterns;\n  }\n\n  // Detect various patterns\n  const doubleTop = detectDoubleTop(data);\n  if (doubleTop) patterns.push(doubleTop);\n\n  const doubleBottom = detectDoubleBottom(data);\n  if (doubleBottom) patterns.push(doubleBottom);\n\n  const headAndShoulders = detectHeadAndShoulders(data);\n  if (headAndShoulders) patterns.push(headAndShoulders);\n\n  const inverseHeadAndShoulders = detectInverseHeadAndShoulders(data);\n  if (inverseHeadAndShoulders) patterns.push(inverseHeadAndShoulders);\n\n  const ascendingTriangle = detectAscendingTriangle(data);\n  if (ascendingTriangle) patterns.push(ascendingTriangle);\n\n  const descendingTriangle = detectDescendingTriangle(data);\n  if (descendingTriangle) patterns.push(descendingTriangle);\n\n  const bullishFlag = detectBullishFlag(data);\n  if (bullishFlag) patterns.push(bullishFlag);\n\n  const bearishFlag = detectBearishFlag(data);\n  if (bearishFlag) patterns.push(bearishFlag);\n\n  return patterns.sort((a, b) => b.confidence - a.confidence);\n}\n\n/**\n * Find local peaks in the data\n */\nfunction findPeaks(data: OHLCV[], window: number = 3): number[] {\n  const peaks: number[] = [];\n\n  for (let i = window; i < data.length - window; i++) {\n    let isPeak = true;\n    const currentHigh = data[i].high;\n\n    for (let j = 1; j <= window; j++) {\n      if (\n        data[i - j].high >= currentHigh ||\n        data[i + j].high >= currentHigh\n      ) {\n        isPeak = false;\n        break;\n      }\n    }\n\n    if (isPeak) {\n      peaks.push(i);\n    }\n  }\n\n  return peaks;\n}\n\n/**\n * Find local troughs in the data\n */\nfunction findTroughs(data: OHLCV[], window: number = 3): number[] {\n  const troughs: number[] = [];\n\n  for (let i = window; i < data.length - window; i++) {\n    let isTrough = true;\n    const currentLow = data[i].low;\n\n    for (let j = 1; j <= window; j++) {\n      if (\n        data[i - j].low <= currentLow ||\n        data[i + j].low <= currentLow\n      ) {\n        isTrough = false;\n        break;\n      }\n    }\n\n    if (isTrough) {\n      troughs.push(i);\n    }\n  }\n\n  return troughs;\n}\n\n/**\n * Check if two prices are approximately equal\n */\nfunction pricesEqual(p1: number, p2: number, tolerance: number = 0.02): boolean {\n  return Math.abs(p1 - p2) / ((p1 + p2) / 2) < tolerance;\n}\n\n/**\n * Detect Double Top pattern (bearish)\n */\nfunction detectDoubleTop(data: OHLCV[]): DetectedPattern | null {\n  const peaks = findPeaks(data, 3);\n\n  if (peaks.length < 2) return null;\n\n  // Check last two peaks\n  const peak1 = peaks[peaks.length - 2];\n  const peak2 = peaks[peaks.length - 1];\n\n  const high1 = data[peak1].high;\n  const high2 = data[peak2].high;\n\n  // Peaks should be at similar levels\n  if (!pricesEqual(high1, high2, 0.03)) return null;\n\n  // Should have a valley between peaks\n  const middleData = data.slice(peak1, peak2 + 1);\n  const neckline = Math.min(...middleData.map((d) => d.low));\n\n  // Current price should be near or below neckline\n  const currentPrice = data[data.length - 1].close;\n  const peakAvg = (high1 + high2) / 2;\n\n  if (currentPrice > peakAvg) return null;\n\n  // Calculate confidence based on pattern clarity\n  const confidence =\n    60 +\n    (pricesEqual(high1, high2, 0.01) ? 20 : 0) +\n    (currentPrice < neckline ? 15 : 0);\n\n  // Price target: neckline - (peak - neckline)\n  const priceTarget = neckline - (peakAvg - neckline);\n\n  return {\n    pattern: \"Double Top\",\n    confidence,\n    direction: \"bearish\",\n    startIndex: peak1,\n    endIndex: data.length - 1,\n    priceTarget,\n    description: `Double top at $${peakAvg.toFixed(6)}, neckline at $${neckline.toFixed(6)}`,\n  };\n}\n\n/**\n * Detect Double Bottom pattern (bullish)\n */\nfunction detectDoubleBottom(data: OHLCV[]): DetectedPattern | null {\n  const troughs = findTroughs(data, 3);\n\n  if (troughs.length < 2) return null;\n\n  const trough1 = troughs[troughs.length - 2];\n  const trough2 = troughs[troughs.length - 1];\n\n  const low1 = data[trough1].low;\n  const low2 = data[trough2].low;\n\n  if (!pricesEqual(low1, low2, 0.03)) return null;\n\n  const middleData = data.slice(trough1, trough2 + 1);\n  const neckline = Math.max(...middleData.map((d) => d.high));\n\n  const currentPrice = data[data.length - 1].close;\n  const troughAvg = (low1 + low2) / 2;\n\n  if (currentPrice < troughAvg) return null;\n\n  const confidence =\n    60 +\n    (pricesEqual(low1, low2, 0.01) ? 20 : 0) +\n    (currentPrice > neckline ? 15 : 0);\n\n  const priceTarget = neckline + (neckline - troughAvg);\n\n  return {\n    pattern: \"Double Bottom\",\n    confidence,\n    direction: \"bullish\",\n    startIndex: trough1,\n    endIndex: data.length - 1,\n    priceTarget,\n    description: `Double bottom at $${troughAvg.toFixed(6)}, neckline at $${neckline.toFixed(6)}`,\n  };\n}\n\n/**\n * Detect Head and Shoulders pattern (bearish)\n */\nfunction detectHeadAndShoulders(data: OHLCV[]): DetectedPattern | null {\n  const peaks = findPeaks(data, 3);\n\n  if (peaks.length < 3) return null;\n\n  // Get last 3 peaks\n  const leftShoulder = peaks[peaks.length - 3];\n  const head = peaks[peaks.length - 2];\n  const rightShoulder = peaks[peaks.length - 1];\n\n  const leftHigh = data[leftShoulder].high;\n  const headHigh = data[head].high;\n  const rightHigh = data[rightShoulder].high;\n\n  // Head should be highest\n  if (headHigh <= leftHigh || headHigh <= rightHigh) return null;\n\n  // Shoulders should be at similar levels\n  if (!pricesEqual(leftHigh, rightHigh, 0.05)) return null;\n\n  // Find neckline\n  const leftTrough = Math.min(\n    ...data.slice(leftShoulder, head + 1).map((d) => d.low)\n  );\n  const rightTrough = Math.min(\n    ...data.slice(head, rightShoulder + 1).map((d) => d.low)\n  );\n  const neckline = (leftTrough + rightTrough) / 2;\n\n  const confidence =\n    55 +\n    (pricesEqual(leftHigh, rightHigh, 0.02) ? 20 : 0) +\n    (headHigh > leftHigh * 1.05 ? 15 : 0);\n\n  const priceTarget = neckline - (headHigh - neckline);\n\n  return {\n    pattern: \"Head and Shoulders\",\n    confidence,\n    direction: \"bearish\",\n    startIndex: leftShoulder,\n    endIndex: data.length - 1,\n    priceTarget,\n    description: `H&S with head at $${headHigh.toFixed(6)}, neckline at $${neckline.toFixed(6)}`,\n  };\n}\n\n/**\n * Detect Inverse Head and Shoulders pattern (bullish)\n */\nfunction detectInverseHeadAndShoulders(data: OHLCV[]): DetectedPattern | null {\n  const troughs = findTroughs(data, 3);\n\n  if (troughs.length < 3) return null;\n\n  const leftShoulder = troughs[troughs.length - 3];\n  const head = troughs[troughs.length - 2];\n  const rightShoulder = troughs[troughs.length - 1];\n\n  const leftLow = data[leftShoulder].low;\n  const headLow = data[head].low;\n  const rightLow = data[rightShoulder].low;\n\n  // Head should be lowest\n  if (headLow >= leftLow || headLow >= rightLow) return null;\n\n  // Shoulders should be at similar levels\n  if (!pricesEqual(leftLow, rightLow, 0.05)) return null;\n\n  const leftPeak = Math.max(\n    ...data.slice(leftShoulder, head + 1).map((d) => d.high)\n  );\n  const rightPeak = Math.max(\n    ...data.slice(head, rightShoulder + 1).map((d) => d.high)\n  );\n  const neckline = (leftPeak + rightPeak) / 2;\n\n  const confidence =\n    55 +\n    (pricesEqual(leftLow, rightLow, 0.02) ? 20 : 0) +\n    (headLow < leftLow * 0.95 ? 15 : 0);\n\n  const priceTarget = neckline + (neckline - headLow);\n\n  return {\n    pattern: \"Inverse Head and Shoulders\",\n    confidence,\n    direction: \"bullish\",\n    startIndex: leftShoulder,\n    endIndex: data.length - 1,\n    priceTarget,\n    description: `Inverse H&S with head at $${headLow.toFixed(6)}, neckline at $${neckline.toFixed(6)}`,\n  };\n}\n\n/**\n * Detect Ascending Triangle pattern (bullish)\n */\nfunction detectAscendingTriangle(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 15) return null;\n\n  const recent = data.slice(-15);\n  const highs = recent.map((d) => d.high);\n  const lows = recent.map((d) => d.low);\n\n  // Flat resistance (highs should be similar)\n  const maxHigh = Math.max(...highs);\n  const flatResistance = highs.filter((h) => h > maxHigh * 0.98).length >= 3;\n\n  // Rising support (lows should be increasing)\n  let risingSupport = true;\n  for (let i = 3; i < lows.length; i++) {\n    const recentLows = lows.slice(i - 3, i + 1);\n    const avgRecent = recentLows.reduce((a, b) => a + b, 0) / recentLows.length;\n    const earlierLows = lows.slice(0, i - 3);\n    const avgEarlier =\n      earlierLows.reduce((a, b) => a + b, 0) / earlierLows.length || avgRecent;\n\n    if (avgRecent < avgEarlier * 0.99) {\n      risingSupport = false;\n      break;\n    }\n  }\n\n  if (!flatResistance || !risingSupport) return null;\n\n  const currentPrice = recent[recent.length - 1].close;\n  const resistance = maxHigh;\n  const support = Math.min(...lows.slice(-5));\n\n  return {\n    pattern: \"Ascending Triangle\",\n    confidence: 65,\n    direction: \"bullish\",\n    startIndex: data.length - 15,\n    endIndex: data.length - 1,\n    priceTarget: resistance + (resistance - support),\n    description: `Ascending triangle with resistance at $${resistance.toFixed(6)}`,\n  };\n}\n\n/**\n * Detect Descending Triangle pattern (bearish)\n */\nfunction detectDescendingTriangle(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 15) return null;\n\n  const recent = data.slice(-15);\n  const highs = recent.map((d) => d.high);\n  const lows = recent.map((d) => d.low);\n\n  // Flat support (lows should be similar)\n  const minLow = Math.min(...lows);\n  const flatSupport = lows.filter((l) => l < minLow * 1.02).length >= 3;\n\n  // Declining resistance (highs should be decreasing)\n  let decliningResistance = true;\n  for (let i = 3; i < highs.length; i++) {\n    const recentHighs = highs.slice(i - 3, i + 1);\n    const avgRecent =\n      recentHighs.reduce((a, b) => a + b, 0) / recentHighs.length;\n    const earlierHighs = highs.slice(0, i - 3);\n    const avgEarlier =\n      earlierHighs.reduce((a, b) => a + b, 0) / earlierHighs.length || avgRecent;\n\n    if (avgRecent > avgEarlier * 1.01) {\n      decliningResistance = false;\n      break;\n    }\n  }\n\n  if (!flatSupport || !decliningResistance) return null;\n\n  const support = minLow;\n  const resistance = Math.max(...highs.slice(-5));\n\n  return {\n    pattern: \"Descending Triangle\",\n    confidence: 65,\n    direction: \"bearish\",\n    startIndex: data.length - 15,\n    endIndex: data.length - 1,\n    priceTarget: support - (resistance - support),\n    description: `Descending triangle with support at $${support.toFixed(6)}`,\n  };\n}\n\n/**\n * Detect Bullish Flag pattern\n */\nfunction detectBullishFlag(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 20) return null;\n\n  const recent = data.slice(-20);\n\n  // Look for a strong upward move (pole) followed by consolidation (flag)\n  const first5 = recent.slice(0, 5);\n  const pole = first5[first5.length - 1].close - first5[0].close;\n  const polePercent = (pole / first5[0].close) * 100;\n\n  if (polePercent < 5) return null; // Need at least 5% move\n\n  // Check for consolidation in the flag portion\n  const flag = recent.slice(5);\n  const flagHighs = flag.map((d) => d.high);\n  const flagLows = flag.map((d) => d.low);\n\n  const flagRange =\n    (Math.max(...flagHighs) - Math.min(...flagLows)) /\n    Math.min(...flagLows);\n\n  if (flagRange > 0.1) return null; // Consolidation should be tight\n\n  // Flag should slope slightly downward\n  const flagStart = (flag[0].high + flag[0].low) / 2;\n  const flagEnd = (flag[flag.length - 1].high + flag[flag.length - 1].low) / 2;\n\n  if (flagEnd > flagStart) return null;\n\n  return {\n    pattern: \"Bullish Flag\",\n    confidence: 60,\n    direction: \"bullish\",\n    startIndex: data.length - 20,\n    endIndex: data.length - 1,\n    priceTarget: recent[recent.length - 1].close + pole,\n    description: `Bullish flag after ${polePercent.toFixed(1)}% move`,\n  };\n}\n\n/**\n * Detect Bearish Flag pattern\n */\nfunction detectBearishFlag(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 20) return null;\n\n  const recent = data.slice(-20);\n\n  // Look for a strong downward move (pole) followed by consolidation (flag)\n  const first5 = recent.slice(0, 5);\n  const pole = first5[0].close - first5[first5.length - 1].close;\n  const polePercent = (pole / first5[0].close) * 100;\n\n  if (polePercent < 5) return null;\n\n  const flag = recent.slice(5);\n  const flagHighs = flag.map((d) => d.high);\n  const flagLows = flag.map((d) => d.low);\n\n  const flagRange =\n    (Math.max(...flagHighs) - Math.min(...flagLows)) /\n    Math.min(...flagLows);\n\n  if (flagRange > 0.1) return null;\n\n  // Flag should slope slightly upward\n  const flagStart = (flag[0].high + flag[0].low) / 2;\n  const flagEnd = (flag[flag.length - 1].high + flag[flag.length - 1].low) / 2;\n\n  if (flagEnd < flagStart) return null;\n\n  return {\n    pattern: \"Bearish Flag\",\n    confidence: 60,\n    direction: \"bearish\",\n    startIndex: data.length - 20,\n    endIndex: data.length - 1,\n    priceTarget: recent[recent.length - 1].close - pole,\n    description: `Bearish flag after ${polePercent.toFixed(1)}% drop`,\n  };\n}\n","/**\n * Crypto-Specific Pattern Detection\n * Patterns unique to cryptocurrency markets\n */\n\nimport type { OHLCV } from \"../agents/types.js\";\nimport type { DetectedPattern } from \"./detector.js\";\n\n/**\n * Detect crypto-specific patterns\n */\nexport function detectCryptoPatterns(data: OHLCV[]): DetectedPattern[] {\n  const patterns: DetectedPattern[] = [];\n\n  if (data.length < 10) {\n    return patterns;\n  }\n\n  const pumpPattern = detectPumpPattern(data);\n  if (pumpPattern) patterns.push(pumpPattern);\n\n  const dumpPattern = detectDumpPattern(data);\n  if (dumpPattern) patterns.push(dumpPattern);\n\n  const accumulation = detectAccumulation(data);\n  if (accumulation) patterns.push(accumulation);\n\n  const distribution = detectDistribution(data);\n  if (distribution) patterns.push(distribution);\n\n  const vShapeRecovery = detectVShapeRecovery(data);\n  if (vShapeRecovery) patterns.push(vShapeRecovery);\n\n  const roundingBottom = detectRoundingBottom(data);\n  if (roundingBottom) patterns.push(roundingBottom);\n\n  return patterns;\n}\n\n/**\n * Detect pump pattern (rapid price increase)\n * Common in memecoin markets\n */\nfunction detectPumpPattern(data: OHLCV[]): DetectedPattern | null {\n  const recent = data.slice(-10);\n\n  if (recent.length < 5) return null;\n\n  // Check for rapid price increase with high volume\n  const firstPrice = recent[0].close;\n  const lastPrice = recent[recent.length - 1].close;\n  const priceChange = ((lastPrice - firstPrice) / firstPrice) * 100;\n\n  if (priceChange < 20) return null; // Need at least 20% pump\n\n  // Check volume spike\n  const avgVolume =\n    data.slice(-30, -10).reduce((sum, d) => sum + d.volume, 0) / 20;\n  const recentVolume =\n    recent.reduce((sum, d) => sum + d.volume, 0) / recent.length;\n\n  const volumeMultiple = avgVolume > 0 ? recentVolume / avgVolume : 1;\n\n  if (volumeMultiple < 2) return null; // Need at least 2x volume\n\n  // Higher price change and volume = higher confidence\n  const confidence = Math.min(\n    50 +\n      Math.min(priceChange, 50) * 0.5 +\n      Math.min(volumeMultiple, 5) * 5,\n    95\n  );\n\n  return {\n    pattern: \"Pump Pattern\",\n    confidence,\n    direction: \"bullish\", // Currently bullish, but be cautious of dump\n    startIndex: data.length - 10,\n    endIndex: data.length - 1,\n    description: `${priceChange.toFixed(1)}% pump with ${volumeMultiple.toFixed(1)}x volume - watch for potential dump`,\n  };\n}\n\n/**\n * Detect dump pattern (rapid price decrease)\n */\nfunction detectDumpPattern(data: OHLCV[]): DetectedPattern | null {\n  const recent = data.slice(-10);\n\n  if (recent.length < 5) return null;\n\n  const firstPrice = recent[0].close;\n  const lastPrice = recent[recent.length - 1].close;\n  const priceChange = ((firstPrice - lastPrice) / firstPrice) * 100;\n\n  if (priceChange < 20) return null; // Need at least 20% dump\n\n  // Check for high selling volume\n  const avgVolume =\n    data.slice(-30, -10).reduce((sum, d) => sum + d.volume, 0) / 20;\n  const recentVolume =\n    recent.reduce((sum, d) => sum + d.volume, 0) / recent.length;\n\n  const volumeMultiple = avgVolume > 0 ? recentVolume / avgVolume : 1;\n\n  const confidence = Math.min(\n    50 +\n      Math.min(priceChange, 50) * 0.5 +\n      Math.min(volumeMultiple, 5) * 5,\n    95\n  );\n\n  return {\n    pattern: \"Dump Pattern\",\n    confidence,\n    direction: \"bearish\",\n    startIndex: data.length - 10,\n    endIndex: data.length - 1,\n    description: `${priceChange.toFixed(1)}% dump with ${volumeMultiple.toFixed(1)}x volume - potential capitulation`,\n  };\n}\n\n/**\n * Detect accumulation phase\n * Sideways price action with increasing buying volume\n */\nfunction detectAccumulation(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 20) return null;\n\n  const recent = data.slice(-20);\n\n  // Check for sideways price action\n  const highs = recent.map((d) => d.high);\n  const lows = recent.map((d) => d.low);\n  const priceRange = (Math.max(...highs) - Math.min(...lows)) / Math.min(...lows);\n\n  if (priceRange > 0.15) return null; // Range should be tight (< 15%)\n\n  // Check for increasing volume on up candles\n  let upVolume = 0;\n  let downVolume = 0;\n\n  for (let i = 1; i < recent.length; i++) {\n    if (recent[i].close > recent[i - 1].close) {\n      upVolume += recent[i].volume;\n    } else {\n      downVolume += recent[i].volume;\n    }\n  }\n\n  const volumeRatio = downVolume > 0 ? upVolume / downVolume : 2;\n\n  if (volumeRatio < 1.2) return null; // Up volume should exceed down volume\n\n  return {\n    pattern: \"Accumulation\",\n    confidence: 55 + Math.min(volumeRatio * 10, 30),\n    direction: \"bullish\",\n    startIndex: data.length - 20,\n    endIndex: data.length - 1,\n    description: `Accumulation phase with ${volumeRatio.toFixed(1)}x more buying volume`,\n  };\n}\n\n/**\n * Detect distribution phase\n * Sideways price action with increasing selling volume\n */\nfunction detectDistribution(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 20) return null;\n\n  const recent = data.slice(-20);\n\n  // Check for sideways price action\n  const highs = recent.map((d) => d.high);\n  const lows = recent.map((d) => d.low);\n  const priceRange = (Math.max(...highs) - Math.min(...lows)) / Math.min(...lows);\n\n  if (priceRange > 0.15) return null;\n\n  // Check for increasing volume on down candles\n  let upVolume = 0;\n  let downVolume = 0;\n\n  for (let i = 1; i < recent.length; i++) {\n    if (recent[i].close > recent[i - 1].close) {\n      upVolume += recent[i].volume;\n    } else {\n      downVolume += recent[i].volume;\n    }\n  }\n\n  const volumeRatio = upVolume > 0 ? downVolume / upVolume : 2;\n\n  if (volumeRatio < 1.2) return null;\n\n  return {\n    pattern: \"Distribution\",\n    confidence: 55 + Math.min(volumeRatio * 10, 30),\n    direction: \"bearish\",\n    startIndex: data.length - 20,\n    endIndex: data.length - 1,\n    description: `Distribution phase with ${volumeRatio.toFixed(1)}x more selling volume`,\n  };\n}\n\n/**\n * Detect V-shape recovery\n * Sharp drop followed by equally sharp recovery\n */\nfunction detectVShapeRecovery(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 15) return null;\n\n  const recent = data.slice(-15);\n  const midpoint = Math.floor(recent.length / 2);\n\n  // Find the lowest point\n  let lowestIndex = 0;\n  let lowestPrice = recent[0].low;\n\n  for (let i = 1; i < recent.length; i++) {\n    if (recent[i].low < lowestPrice) {\n      lowestPrice = recent[i].low;\n      lowestIndex = i;\n    }\n  }\n\n  // Lowest should be roughly in the middle\n  if (lowestIndex < 3 || lowestIndex > recent.length - 3) return null;\n\n  // Calculate drop and recovery\n  const startPrice = recent[0].close;\n  const endPrice = recent[recent.length - 1].close;\n  const drop = ((startPrice - lowestPrice) / startPrice) * 100;\n  const recovery = ((endPrice - lowestPrice) / lowestPrice) * 100;\n\n  if (drop < 10 || recovery < 10) return null;\n\n  // Recovery should be significant relative to drop\n  const recoveryRatio = recovery / drop;\n\n  if (recoveryRatio < 0.7) return null;\n\n  return {\n    pattern: \"V-Shape Recovery\",\n    confidence: 60 + Math.min(recovery, 30),\n    direction: \"bullish\",\n    startIndex: data.length - 15,\n    endIndex: data.length - 1,\n    priceTarget: startPrice * (1 + recovery / 100 * 0.5),\n    description: `V-shape with ${drop.toFixed(1)}% drop and ${recovery.toFixed(1)}% recovery`,\n  };\n}\n\n/**\n * Detect rounding bottom (cup without handle)\n */\nfunction detectRoundingBottom(data: OHLCV[]): DetectedPattern | null {\n  if (data.length < 20) return null;\n\n  const recent = data.slice(-20);\n\n  // Find the lowest point\n  let lowestIndex = 0;\n  let lowestPrice = recent[0].low;\n\n  for (let i = 1; i < recent.length; i++) {\n    if (recent[i].low < lowestPrice) {\n      lowestPrice = recent[i].low;\n      lowestIndex = i;\n    }\n  }\n\n  // Lowest should be in the middle third\n  if (lowestIndex < 6 || lowestIndex > 14) return null;\n\n  // Check for gradual decline before and rise after\n  const beforeLow = recent.slice(0, lowestIndex);\n  const afterLow = recent.slice(lowestIndex);\n\n  // Before should be declining\n  let declining = true;\n  for (let i = 1; i < beforeLow.length; i++) {\n    if (beforeLow[i].close > beforeLow[i - 1].close * 1.02) {\n      declining = false;\n      break;\n    }\n  }\n\n  // After should be rising\n  let rising = true;\n  for (let i = 1; i < afterLow.length; i++) {\n    if (afterLow[i].close < afterLow[i - 1].close * 0.98) {\n      rising = false;\n      break;\n    }\n  }\n\n  if (!declining || !rising) return null;\n\n  const startPrice = recent[0].close;\n  const endPrice = recent[recent.length - 1].close;\n\n  return {\n    pattern: \"Rounding Bottom\",\n    confidence: 65,\n    direction: \"bullish\",\n    startIndex: data.length - 20,\n    endIndex: data.length - 1,\n    priceTarget: Math.max(startPrice, endPrice) * 1.1,\n    description: `Rounding bottom with support at $${lowestPrice.toFixed(6)}`,\n  };\n}\n","/**\n * Pattern Agent - Chart pattern recognition\n */\n\nimport { BaseAgent } from \"./base-agent.js\";\nimport type { AgentConfig, OHLCV, TokenInfo, PatternResult } from \"./types.js\";\nimport { detectPatterns } from \"../patterns/detector.js\";\nimport { detectCryptoPatterns } from \"../patterns/crypto-patterns.js\";\nimport { PATTERN_AGENT_PROMPT } from \"../llm/prompts.js\";\n\nexport class PatternAgent extends BaseAgent {\n  constructor(config: AgentConfig) {\n    super(\"PatternAgent\", config);\n  }\n\n  async analyze(\n    token: TokenInfo,\n    data: OHLCV[]\n  ): Promise<PatternResult | null> {\n    this.log(`Scanning patterns for ${token.symbol}...`);\n\n    if (data.length < 20) {\n      this.log(\"Insufficient data for pattern detection\");\n      return null;\n    }\n\n    // Detect classical patterns\n    const classicalPatterns = detectPatterns(data);\n\n    // Detect crypto-specific patterns (pump/dump, accumulation, etc.)\n    const cryptoPatterns = detectCryptoPatterns(data);\n\n    const allPatterns = [...classicalPatterns, ...cryptoPatterns];\n\n    if (allPatterns.length === 0) {\n      this.log(\"No significant patterns detected\");\n      return null;\n    }\n\n    // Get the most significant pattern (highest confidence)\n    const topPattern = allPatterns.sort((a, b) => b.confidence - a.confidence)[0];\n\n    // Use LLM to analyze and refine the pattern detection\n    const prompt = this.buildPrompt(token, data, topPattern, allPatterns);\n\n    try {\n      const llmResponse = await this.llm.complete(this.getSystemPrompt(), prompt);\n      const result = this.parseResponse(llmResponse, topPattern);\n      this.log(`Pattern detected: ${result.pattern} (${result.confidence}% confidence)`);\n      return result;\n    } catch (error) {\n      this.log(\"LLM analysis failed, using detected pattern\", error);\n      return {\n        pattern: topPattern.pattern,\n        confidence: topPattern.confidence,\n        direction: topPattern.direction,\n        priceTarget: topPattern.priceTarget,\n        description: topPattern.description,\n      };\n    }\n  }\n\n  protected getSystemPrompt(): string {\n    return PATTERN_AGENT_PROMPT;\n  }\n\n  private buildPrompt(\n    token: TokenInfo,\n    data: OHLCV[],\n    topPattern: ReturnType<typeof detectPatterns>[0],\n    allPatterns: ReturnType<typeof detectPatterns>\n  ): string {\n    const metrics = this.getPriceMetrics(data);\n\n    return `\nAnalyze chart patterns for ${token.symbol}:\n\nCurrent Price: $${metrics.currentPrice.toFixed(6)}\n24h Range: $${metrics.low24h.toFixed(6)} - $${metrics.high24h.toFixed(6)}\n24h Change: ${metrics.priceChangePercent.toFixed(2)}%\n\nDETECTED PATTERNS:\n${allPatterns.map((p) => `- ${p.pattern}: ${p.confidence}% confidence, ${p.direction}`).join(\"\\n\")}\n\nTOP PATTERN: ${topPattern.pattern}\nInitial Confidence: ${topPattern.confidence}%\nDirection: ${topPattern.direction}\n${topPattern.priceTarget ? `Price Target: $${topPattern.priceTarget.toFixed(6)}` : \"\"}\nDescription: ${topPattern.description}\n\nPRICE DATA:\n${this.formatDataForLLM(data)}\n\nAnalyze this pattern and provide:\n1. Refined confidence level based on pattern clarity\n2. Price target if pattern completes\n3. Key levels to watch\n4. Brief description of the pattern\n\nRespond in JSON format:\n{\n  \"pattern\": \"string\",\n  \"confidence\": number,\n  \"direction\": \"bullish\" | \"bearish\" | \"neutral\",\n  \"priceTarget\": number | null,\n  \"description\": \"string\"\n}\n`;\n  }\n\n  private parseResponse(\n    response: string,\n    fallback: ReturnType<typeof detectPatterns>[0]\n  ): PatternResult {\n    const parsed = this.parseJSON<{\n      pattern: string;\n      confidence: number;\n      direction: \"bullish\" | \"bearish\" | \"neutral\";\n      priceTarget: number | null;\n      description: string;\n    }>(response);\n\n    if (parsed) {\n      return {\n        pattern: parsed.pattern || fallback.pattern,\n        confidence: parsed.confidence || fallback.confidence,\n        direction: parsed.direction || fallback.direction,\n        priceTarget: parsed.priceTarget ?? fallback.priceTarget,\n        description: parsed.description || fallback.description,\n      };\n    }\n\n    return {\n      pattern: fallback.pattern,\n      confidence: fallback.confidence,\n      direction: fallback.direction,\n      priceTarget: fallback.priceTarget,\n      description: fallback.description,\n    };\n  }\n}\n","/**\n * Trend Agent - Trend and momentum analysis\n */\n\nimport { BaseAgent } from \"./base-agent.js\";\nimport type { AgentConfig, OHLCV, TokenInfo, TrendResult } from \"./types.js\";\nimport { TREND_AGENT_PROMPT } from \"../llm/prompts.js\";\n\nexport class TrendAgent extends BaseAgent {\n  constructor(config: AgentConfig) {\n    super(\"TrendAgent\", config);\n  }\n\n  async analyze(token: TokenInfo, data: OHLCV[]): Promise<TrendResult> {\n    this.log(`Analyzing trend for ${token.symbol}...`);\n\n    if (data.length < 50) {\n      this.log(\"Insufficient data for trend analysis\");\n      const currentPrice = data[data.length - 1]?.close || 0;\n      return {\n        direction: \"sideways\",\n        strength: 0,\n        support: currentPrice * 0.95,\n        resistance: currentPrice * 1.05,\n        momentum: 0,\n        description: \"Insufficient data for trend analysis\",\n      };\n    }\n\n    // Calculate trend metrics\n    const trendMetrics = this.calculateTrendMetrics(data);\n\n    // Use LLM for deeper analysis\n    const prompt = this.buildPrompt(token, data, trendMetrics);\n\n    try {\n      const llmResponse = await this.llm.complete(this.getSystemPrompt(), prompt);\n      const result = this.parseResponse(llmResponse, trendMetrics);\n      this.log(`Trend: ${result.direction} (strength: ${result.strength}%)`);\n      return result;\n    } catch (error) {\n      this.log(\"LLM analysis failed, using calculated metrics\", error);\n      return {\n        ...trendMetrics,\n        description: `Trend is ${trendMetrics.direction} with ${trendMetrics.strength.toFixed(0)}% strength`,\n      };\n    }\n  }\n\n  protected getSystemPrompt(): string {\n    return TREND_AGENT_PROMPT;\n  }\n\n  private calculateTrendMetrics(data: OHLCV[]): {\n    direction: \"up\" | \"down\" | \"sideways\";\n    strength: number;\n    support: number;\n    resistance: number;\n    momentum: number;\n    ema20: number;\n    ema50: number;\n    ema200: number;\n  } {\n    const closes = data.map((d) => d.close);\n\n    // Calculate EMAs\n    const ema20 = this.calculateEMA(closes, 20);\n    const ema50 = this.calculateEMA(closes, 50);\n    const ema200 = closes.length >= 200 ? this.calculateEMA(closes, 200) : ema50;\n\n    // Determine trend direction\n    const currentPrice = closes[closes.length - 1];\n    let direction: \"up\" | \"down\" | \"sideways\" = \"sideways\";\n\n    if (currentPrice > ema20 && ema20 > ema50) {\n      direction = \"up\";\n    } else if (currentPrice < ema20 && ema20 < ema50) {\n      direction = \"down\";\n    }\n\n    // Calculate trend strength (0-100)\n    const priceVsEma20 = ((currentPrice - ema20) / ema20) * 100;\n    const ema20Vs50 = ((ema20 - ema50) / ema50) * 100;\n    const strength = Math.min(Math.abs(priceVsEma20 + ema20Vs50) * 5, 100);\n\n    // Find support and resistance levels\n    const { support, resistance } = this.findSupportResistance(data);\n\n    // Calculate momentum (rate of change)\n    const lookback = Math.min(20, closes.length - 1);\n    const previousPrice = closes[closes.length - lookback - 1];\n    const momentum = ((currentPrice - previousPrice) / previousPrice) * 100;\n\n    return {\n      direction,\n      strength,\n      support,\n      resistance,\n      momentum,\n      ema20,\n      ema50,\n      ema200,\n    };\n  }\n\n  private findSupportResistance(data: OHLCV[]): {\n    support: number;\n    resistance: number;\n  } {\n    // Use pivot points and recent highs/lows\n    const recent = data.slice(-50);\n    const lows = recent.map((d) => d.low);\n    const highs = recent.map((d) => d.high);\n\n    // Find significant lows (potential support)\n    const sortedLows = [...lows].sort((a, b) => a - b);\n    const support = sortedLows[Math.floor(sortedLows.length * 0.1)]; // 10th percentile\n\n    // Find significant highs (potential resistance)\n    const sortedHighs = [...highs].sort((a, b) => b - a);\n    const resistance = sortedHighs[Math.floor(sortedHighs.length * 0.1)]; // 90th percentile\n\n    return { support, resistance };\n  }\n\n  private buildPrompt(\n    token: TokenInfo,\n    data: OHLCV[],\n    metrics: ReturnType<typeof this.calculateTrendMetrics>\n  ): string {\n    const priceMetrics = this.getPriceMetrics(data);\n\n    return `\nAnalyze the trend for ${token.symbol}:\n\nCurrent Price: $${priceMetrics.currentPrice.toFixed(6)}\nEMA 20: $${metrics.ema20.toFixed(6)}\nEMA 50: $${metrics.ema50.toFixed(6)}\nEMA 200: $${metrics.ema200.toFixed(6)}\nSupport: $${metrics.support.toFixed(6)}\nResistance: $${metrics.resistance.toFixed(6)}\nMomentum (20 period): ${metrics.momentum.toFixed(2)}%\n\nInitial Assessment:\n- Direction: ${metrics.direction}\n- Strength: ${metrics.strength.toFixed(0)}%\n\nPRICE DATA:\n${this.formatDataForLLM(data)}\n\nProvide refined trend analysis:\n1. Confirm or adjust direction\n2. Strength score (0-100)\n3. Key support/resistance levels\n4. Brief description\n\nRespond in JSON format:\n{\n  \"direction\": \"up\" | \"down\" | \"sideways\",\n  \"strength\": number,\n  \"support\": number,\n  \"resistance\": number,\n  \"momentum\": number,\n  \"description\": \"string\"\n}\n`;\n  }\n\n  private parseResponse(\n    response: string,\n    fallback: ReturnType<typeof this.calculateTrendMetrics>\n  ): TrendResult {\n    const parsed = this.parseJSON<{\n      direction: \"up\" | \"down\" | \"sideways\";\n      strength: number;\n      support: number;\n      resistance: number;\n      momentum: number;\n      description: string;\n    }>(response);\n\n    if (parsed) {\n      return {\n        direction: parsed.direction || fallback.direction,\n        strength: parsed.strength || fallback.strength,\n        support: parsed.support || fallback.support,\n        resistance: parsed.resistance || fallback.resistance,\n        momentum: parsed.momentum || fallback.momentum,\n        description:\n          parsed.description ||\n          `Trend is ${fallback.direction} with ${fallback.strength}% strength`,\n      };\n    }\n\n    return {\n      direction: fallback.direction,\n      strength: fallback.strength,\n      support: fallback.support,\n      resistance: fallback.resistance,\n      momentum: fallback.momentum,\n      description: `Trend is ${fallback.direction} with ${fallback.strength.toFixed(0)}% strength`,\n    };\n  }\n}\n","/**\n * Risk Agent - Risk assessment and trade synthesis\n */\n\nimport { BaseAgent } from \"./base-agent.js\";\nimport type {\n  AgentConfig,\n  OHLCV,\n  TokenInfo,\n  RiskResult,\n  TradeDecision,\n  IndicatorResult,\n  PatternResult,\n  TrendResult,\n} from \"./types.js\";\nimport { RISK_AGENT_PROMPT } from \"../llm/prompts.js\";\n\nexport interface RiskAgentInput {\n  token: TokenInfo;\n  data: OHLCV[];\n  indicators: IndicatorResult[];\n  indicatorSignal: \"bullish\" | \"bearish\" | \"neutral\";\n  indicatorConfidence: number;\n  pattern: PatternResult | null;\n  trend: TrendResult;\n}\n\nexport class RiskAgent extends BaseAgent {\n  constructor(config: AgentConfig) {\n    super(\"RiskAgent\", config);\n  }\n\n  async analyze(input: RiskAgentInput): Promise<TradeDecision> {\n    const { token, data, indicators, pattern, trend } = input;\n    this.log(`Synthesizing trade decision for ${token.symbol}...`);\n\n    if (data.length === 0) {\n      return this.getDefaultDecision(token, input);\n    }\n\n    const metrics = this.getPriceMetrics(data);\n\n    // Calculate risk metrics\n    const riskMetrics = this.calculateRiskMetrics(data, trend);\n\n    // Build comprehensive prompt for LLM\n    const prompt = this.buildPrompt(input, metrics, riskMetrics);\n\n    try {\n      const llmResponse = await this.llm.complete(this.getSystemPrompt(), prompt);\n      const decision = this.parseResponse(llmResponse, {\n        token,\n        indicators,\n        pattern,\n        trend,\n        riskMetrics,\n        currentPrice: metrics.currentPrice,\n      });\n      this.log(`Decision: ${decision.action} (${decision.confidence}% confidence)`);\n      return decision;\n    } catch (error) {\n      this.log(\"LLM analysis failed, using calculated decision\", error);\n      return this.calculateFallbackDecision(input, metrics, riskMetrics);\n    }\n  }\n\n  protected getSystemPrompt(): string {\n    return RISK_AGENT_PROMPT;\n  }\n\n  private calculateRiskMetrics(data: OHLCV[], trend?: TrendResult): RiskResult {\n    const currentPrice = data[data.length - 1]?.close || 0;\n\n    if (currentPrice === 0) {\n      return {\n        riskScore: 100,\n        rewardRatio: 0,\n        stopLoss: 0,\n        takeProfit: 0,\n        positionSize: 0,\n        warnings: [\"No price data available\"],\n      };\n    }\n\n    // Calculate volatility using ATR\n    const atr = this.calculateATR(data, 14);\n    const volatility = (atr / currentPrice) * 100;\n\n    // Default stop loss: 2x ATR below current price\n    const stopLoss = currentPrice - atr * 2;\n\n    // Default take profit based on trend resistance or 3x ATR\n    const takeProfit = trend?.resistance || currentPrice + atr * 3;\n\n    // Calculate risk/reward ratio\n    const risk = currentPrice - stopLoss;\n    const reward = takeProfit - currentPrice;\n    const rewardRatio = risk > 0 ? reward / risk : 0;\n\n    // Calculate risk score (higher = riskier)\n    let riskScore = 50;\n\n    // Volatility adjustments\n    if (volatility > 10) riskScore += 15;\n    if (volatility > 20) riskScore += 15;\n\n    // Risk/reward adjustments\n    if (rewardRatio < 1.5) riskScore += 10;\n    if (rewardRatio < 1) riskScore += 15;\n\n    // Trend strength adjustments\n    if (trend?.strength && trend.strength < 30) riskScore += 10;\n\n    // Collect warnings\n    const warnings: string[] = [];\n\n    if (volatility > 15) {\n      warnings.push(\"High volatility detected - use wider stops\");\n    }\n    if (rewardRatio < 1.5) {\n      warnings.push(\"Poor risk/reward ratio - consider waiting for better entry\");\n    }\n    if (trend?.strength && trend.strength < 30) {\n      warnings.push(\"Weak trend - wait for confirmation\");\n    }\n    if (atr > currentPrice * 0.05) {\n      warnings.push(\"Very high ATR - reduce position size\");\n    }\n\n    // Calculate position size based on risk score\n    const positionSize = Math.max(100 - riskScore, 1);\n\n    return {\n      riskScore: Math.min(riskScore, 100),\n      rewardRatio: Math.round(rewardRatio * 100) / 100,\n      stopLoss: Math.round(stopLoss * 1e8) / 1e8,\n      takeProfit: Math.round(takeProfit * 1e8) / 1e8,\n      positionSize,\n      warnings,\n    };\n  }\n\n  private buildPrompt(\n    input: RiskAgentInput,\n    metrics: ReturnType<BaseAgent[\"getPriceMetrics\"]>,\n    riskMetrics: RiskResult\n  ): string {\n    const { token, indicators, indicatorSignal, indicatorConfidence, pattern, trend } = input;\n\n    const indicatorSummary = indicators\n      .map((i) => `${i.name}: ${i.signal} (strength: ${i.strength.toFixed(0)}%)`)\n      .join(\"\\n\");\n\n    return `\nTRADE DECISION REQUEST for ${token.symbol} (${token.chain})\n\nCURRENT MARKET STATE:\n- Price: $${metrics.currentPrice.toFixed(6)}\n- 24h Change: ${metrics.priceChangePercent.toFixed(2)}%\n- 24h Range: $${metrics.low24h.toFixed(6)} - $${metrics.high24h.toFixed(6)}\n- 24h Volume: $${metrics.volume24h.toFixed(0)}\n\nINDICATOR ANALYSIS (${indicatorSignal.toUpperCase()}, ${indicatorConfidence}% confidence):\n${indicatorSummary}\n\nPATTERN ANALYSIS:\n${\n  pattern\n    ? `${pattern.pattern} - ${pattern.direction} (${pattern.confidence}% confidence)\n   Price Target: ${pattern.priceTarget ? `$${pattern.priceTarget.toFixed(6)}` : \"N/A\"}\n   ${pattern.description}`\n    : \"No significant pattern detected\"\n}\n\nTREND ANALYSIS:\n- Direction: ${trend.direction}\n- Strength: ${trend.strength.toFixed(0)}%\n- Support: $${trend.support.toFixed(6)}\n- Resistance: $${trend.resistance.toFixed(6)}\n- Momentum: ${trend.momentum.toFixed(2)}%\n- ${trend.description}\n\nRISK METRICS:\n- Risk Score: ${riskMetrics.riskScore}/100 (higher = riskier)\n- Risk/Reward Ratio: ${riskMetrics.rewardRatio.toFixed(2)}\n- Suggested Stop Loss: $${riskMetrics.stopLoss.toFixed(6)}\n- Suggested Take Profit: $${riskMetrics.takeProfit.toFixed(6)}\n- Suggested Position Size: ${riskMetrics.positionSize}% of portfolio\n- Warnings: ${riskMetrics.warnings.length > 0 ? riskMetrics.warnings.join(\"; \") : \"None\"}\n\nBased on ALL the above analysis, provide a trade decision.\n\nConsider:\n1. Agent confluence - do multiple agents agree?\n2. Risk/reward - is it worth taking the trade?\n3. Current market conditions\n4. Any conflicting signals\n\nRespond in JSON format:\n{\n  \"action\": \"LONG\" | \"SHORT\" | \"HOLD\" | \"EXIT\",\n  \"confidence\": number (0-100),\n  \"entryPrice\": number,\n  \"stopLoss\": number,\n  \"takeProfit\": number,\n  \"rationale\": \"string (2-3 sentences explaining the decision)\"\n}\n`;\n  }\n\n  private parseResponse(\n    response: string,\n    context: {\n      token: TokenInfo;\n      indicators: IndicatorResult[];\n      pattern: PatternResult | null;\n      trend: TrendResult;\n      riskMetrics: RiskResult;\n      currentPrice: number;\n    }\n  ): TradeDecision {\n    const parsed = this.parseJSON<{\n      action: \"LONG\" | \"SHORT\" | \"HOLD\" | \"EXIT\";\n      confidence: number;\n      entryPrice: number;\n      stopLoss: number;\n      takeProfit: number;\n      rationale: string;\n    }>(response);\n\n    if (parsed) {\n      return {\n        action: parsed.action || \"HOLD\",\n        confidence: parsed.confidence || 50,\n        entryPrice: parsed.entryPrice || context.currentPrice,\n        stopLoss: parsed.stopLoss || context.riskMetrics.stopLoss,\n        takeProfit: parsed.takeProfit || context.riskMetrics.takeProfit,\n        timeframe: \"4h\",\n        rationale: parsed.rationale || \"Based on technical analysis\",\n        indicators: context.indicators,\n        pattern: context.pattern,\n        trend: context.trend,\n        risk: context.riskMetrics,\n        timestamp: Date.now(),\n        token: context.token,\n      };\n    }\n\n    // Fallback decision\n    return {\n      action: \"HOLD\",\n      confidence: 30,\n      entryPrice: context.currentPrice,\n      stopLoss: context.riskMetrics.stopLoss,\n      takeProfit: context.riskMetrics.takeProfit,\n      timeframe: \"4h\",\n      rationale: \"Insufficient confluence for high-confidence trade\",\n      indicators: context.indicators,\n      pattern: context.pattern,\n      trend: context.trend,\n      risk: context.riskMetrics,\n      timestamp: Date.now(),\n      token: context.token,\n    };\n  }\n\n  private calculateFallbackDecision(\n    input: RiskAgentInput,\n    metrics: ReturnType<BaseAgent[\"getPriceMetrics\"]>,\n    riskMetrics: RiskResult\n  ): TradeDecision {\n    const { token, indicators, indicatorSignal, indicatorConfidence, pattern, trend } = input;\n\n    // Determine action based on confluence\n    let bullishSignals = 0;\n    let bearishSignals = 0;\n\n    if (indicatorSignal === \"bullish\") bullishSignals++;\n    if (indicatorSignal === \"bearish\") bearishSignals++;\n    if (pattern?.direction === \"bullish\") bullishSignals++;\n    if (pattern?.direction === \"bearish\") bearishSignals++;\n    if (trend.direction === \"up\") bullishSignals++;\n    if (trend.direction === \"down\") bearishSignals++;\n\n    let action: \"LONG\" | \"SHORT\" | \"HOLD\" | \"EXIT\" = \"HOLD\";\n    let confidence = 30;\n\n    if (bullishSignals >= 2 && bearishSignals === 0) {\n      action = \"LONG\";\n      confidence = Math.min(50 + bullishSignals * 15, 80);\n    } else if (bearishSignals >= 2 && bullishSignals === 0) {\n      action = \"SHORT\";\n      confidence = Math.min(50 + bearishSignals * 15, 80);\n    }\n\n    // Reduce confidence if risk score is high\n    if (riskMetrics.riskScore > 70) {\n      confidence = Math.max(confidence - 20, 20);\n    }\n\n    const rationale =\n      action === \"HOLD\"\n        ? \"Mixed signals - waiting for clearer direction\"\n        : action === \"LONG\"\n          ? `${bullishSignals} bullish signals across agents`\n          : `${bearishSignals} bearish signals across agents`;\n\n    return {\n      action,\n      confidence,\n      entryPrice: metrics.currentPrice,\n      stopLoss: riskMetrics.stopLoss,\n      takeProfit: riskMetrics.takeProfit,\n      timeframe: \"4h\",\n      rationale,\n      indicators,\n      pattern,\n      trend,\n      risk: riskMetrics,\n      timestamp: Date.now(),\n      token,\n    };\n  }\n\n  private getDefaultDecision(token: TokenInfo, input: RiskAgentInput): TradeDecision {\n    return {\n      action: \"HOLD\",\n      confidence: 0,\n      entryPrice: 0,\n      stopLoss: 0,\n      takeProfit: 0,\n      timeframe: \"4h\",\n      rationale: \"Insufficient data for analysis\",\n      indicators: input.indicators,\n      pattern: input.pattern,\n      trend: input.trend,\n      risk: {\n        riskScore: 100,\n        rewardRatio: 0,\n        stopLoss: 0,\n        takeProfit: 0,\n        positionSize: 0,\n        warnings: [\"No data available\"],\n      },\n      timestamp: Date.now(),\n      token,\n    };\n  }\n}\n","/**\n * CoinGecko Data Provider - Free tier, no API key required\n * Docs: https://www.coingecko.com/en/api/documentation\n */\n\nimport type { CandleData, PriceData } from \"./types.js\";\n\nconst BASE_URL = \"https://api.coingecko.com/api/v3\";\n\n// Common token ID mappings\nconst TOKEN_IDS: Record<string, string> = {\n  BTC: \"bitcoin\",\n  ETH: \"ethereum\",\n  SOL: \"solana\",\n  BONK: \"bonk\",\n  WIF: \"dogwifcoin\",\n  JUP: \"jupiter-exchange-solana\",\n  RAY: \"raydium\",\n  ORCA: \"orca\",\n  PYTH: \"pyth-network\",\n  JTO: \"jito-governance-token\",\n  RENDER: \"render-token\",\n  HNT: \"helium\",\n  RNDR: \"render-token\",\n  INJ: \"injective-protocol\",\n  TIA: \"celestia\",\n  SEI: \"sei-network\",\n  SUI: \"sui\",\n  APT: \"aptos\",\n  ARB: \"arbitrum\",\n  OP: \"optimism\",\n  MATIC: \"matic-network\",\n  AVAX: \"avalanche-2\",\n  LINK: \"chainlink\",\n  UNI: \"uniswap\",\n  AAVE: \"aave\",\n};\n\nfunction getTokenId(symbol: string): string {\n  const upperSymbol = symbol.toUpperCase();\n  return TOKEN_IDS[upperSymbol] || symbol.toLowerCase();\n}\n\nexport async function fetchPrice(symbol: string): Promise<PriceData | null> {\n  try {\n    const id = getTokenId(symbol);\n    const response = await fetch(\n      `${BASE_URL}/simple/price?ids=${id}&vs_currencies=usd&include_24hr_vol=true&include_24hr_change=true&include_market_cap=true`\n    );\n\n    if (!response.ok) {\n      console.warn(`CoinGecko price fetch failed for ${symbol}: ${response.status}`);\n      return null;\n    }\n\n    const data = await response.json();\n    const tokenData = data[id];\n\n    if (!tokenData) {\n      return null;\n    }\n\n    return {\n      price: tokenData.usd || 0,\n      priceChange24h: 0, // Calculated from percent\n      priceChangePercent24h: tokenData.usd_24h_change || 0,\n      volume24h: tokenData.usd_24h_vol || 0,\n      marketCap: tokenData.usd_market_cap || 0,\n      high24h: 0, // Not available in simple endpoint\n      low24h: 0,\n    };\n  } catch (error) {\n    console.error(`CoinGecko error for ${symbol}:`, error);\n    return null;\n  }\n}\n\nexport async function fetchOHLCV(\n  symbol: string,\n  days: number = 7\n): Promise<CandleData[]> {\n  try {\n    const id = getTokenId(symbol);\n    const response = await fetch(\n      `${BASE_URL}/coins/${id}/ohlc?vs_currency=usd&days=${days}`\n    );\n\n    if (!response.ok) {\n      console.warn(`CoinGecko OHLCV fetch failed for ${symbol}: ${response.status}`);\n      return [];\n    }\n\n    const data = await response.json();\n\n    // CoinGecko returns [timestamp, open, high, low, close]\n    return data.map((candle: number[]) => ({\n      timestamp: candle[0],\n      open: candle[1],\n      high: candle[2],\n      low: candle[3],\n      close: candle[4],\n      volume: 0, // OHLC endpoint doesn't include volume\n    }));\n  } catch (error) {\n    console.error(`CoinGecko OHLCV error for ${symbol}:`, error);\n    return [];\n  }\n}\n\nexport async function fetchMarketChart(\n  symbol: string,\n  days: number = 7\n): Promise<CandleData[]> {\n  try {\n    const id = getTokenId(symbol);\n    const response = await fetch(\n      `${BASE_URL}/coins/${id}/market_chart?vs_currency=usd&days=${days}`\n    );\n\n    if (!response.ok) {\n      console.warn(`CoinGecko market_chart failed for ${symbol}: ${response.status}`);\n      return [];\n    }\n\n    const data = await response.json();\n    const prices = data.prices || [];\n    const volumes = data.total_volumes || [];\n\n    // Convert to OHLCV format (prices are [timestamp, price])\n    // Group into hourly candles\n    const candles: CandleData[] = [];\n    const hourMs = 60 * 60 * 1000;\n\n    for (let i = 0; i < prices.length; i++) {\n      const [timestamp, price] = prices[i];\n      const volume = volumes[i]?.[1] || 0;\n\n      // Round to hour\n      const hourTimestamp = Math.floor(timestamp / hourMs) * hourMs;\n\n      // Find or create candle for this hour\n      let candle = candles.find((c) => c.timestamp === hourTimestamp);\n      if (!candle) {\n        candle = {\n          timestamp: hourTimestamp,\n          open: price,\n          high: price,\n          low: price,\n          close: price,\n          volume: 0,\n        };\n        candles.push(candle);\n      }\n\n      // Update candle\n      candle.high = Math.max(candle.high, price);\n      candle.low = Math.min(candle.low, price);\n      candle.close = price;\n      candle.volume += volume / (prices.length / candles.length); // Approximate\n    }\n\n    return candles.sort((a, b) => a.timestamp - b.timestamp);\n  } catch (error) {\n    console.error(`CoinGecko market_chart error for ${symbol}:`, error);\n    return [];\n  }\n}\n\nexport async function fetchTokenInfo(symbol: string): Promise<{\n  id: string;\n  symbol: string;\n  name: string;\n  marketCap: number;\n  rank: number;\n  ath: number;\n  athChangePercent: number;\n  atl: number;\n  atlChangePercent: number;\n} | null> {\n  try {\n    const id = getTokenId(symbol);\n    const response = await fetch(`${BASE_URL}/coins/${id}`);\n\n    if (!response.ok) {\n      return null;\n    }\n\n    const data = await response.json();\n\n    return {\n      id: data.id,\n      symbol: data.symbol,\n      name: data.name,\n      marketCap: data.market_data?.market_cap?.usd || 0,\n      rank: data.market_cap_rank || 0,\n      ath: data.market_data?.ath?.usd || 0,\n      athChangePercent: data.market_data?.ath_change_percentage?.usd || 0,\n      atl: data.market_data?.atl?.usd || 0,\n      atlChangePercent: data.market_data?.atl_change_percentage?.usd || 0,\n    };\n  } catch (error) {\n    console.error(`CoinGecko token info error for ${symbol}:`, error);\n    return null;\n  }\n}\n","/**\n * DexScreener Data Provider - Free tier, no API key required\n * Docs: https://docs.dexscreener.com/api/reference\n */\n\nimport type { CandleData, PoolData, TokenMetadata } from \"./types.js\";\n\nconst BASE_URL = \"https://api.dexscreener.com\";\n\nexport interface DexScreenerPair {\n  chainId: string;\n  dexId: string;\n  url: string;\n  pairAddress: string;\n  baseToken: {\n    address: string;\n    name: string;\n    symbol: string;\n  };\n  quoteToken: {\n    address: string;\n    name: string;\n    symbol: string;\n  };\n  priceNative: string;\n  priceUsd: string;\n  txns: {\n    h24: { buys: number; sells: number };\n    h6: { buys: number; sells: number };\n    h1: { buys: number; sells: number };\n    m5: { buys: number; sells: number };\n  };\n  volume: {\n    h24: number;\n    h6: number;\n    h1: number;\n    m5: number;\n  };\n  priceChange: {\n    h24: number;\n    h6: number;\n    h1: number;\n    m5: number;\n  };\n  liquidity: {\n    usd: number;\n    base: number;\n    quote: number;\n  };\n  fdv: number;\n  marketCap: number;\n  pairCreatedAt: number;\n  info?: {\n    imageUrl?: string;\n    websites?: { url: string }[];\n    socials?: { type: string; url: string }[];\n  };\n}\n\nexport async function fetchTokenPairs(\n  tokenAddress: string\n): Promise<DexScreenerPair[]> {\n  try {\n    const response = await fetch(\n      `${BASE_URL}/latest/dex/tokens/${tokenAddress}`\n    );\n\n    if (!response.ok) {\n      console.warn(`DexScreener fetch failed for ${tokenAddress}: ${response.status}`);\n      return [];\n    }\n\n    const data = await response.json();\n    return data.pairs || [];\n  } catch (error) {\n    console.error(`DexScreener error for ${tokenAddress}:`, error);\n    return [];\n  }\n}\n\nexport async function fetchPairByAddress(\n  pairAddress: string,\n  chainId: string = \"solana\"\n): Promise<DexScreenerPair | null> {\n  try {\n    const response = await fetch(\n      `${BASE_URL}/latest/dex/pairs/${chainId}/${pairAddress}`\n    );\n\n    if (!response.ok) {\n      return null;\n    }\n\n    const data = await response.json();\n    return data.pair || null;\n  } catch (error) {\n    console.error(`DexScreener pair error:`, error);\n    return null;\n  }\n}\n\nexport async function searchTokens(query: string): Promise<DexScreenerPair[]> {\n  try {\n    const response = await fetch(\n      `${BASE_URL}/latest/dex/search?q=${encodeURIComponent(query)}`\n    );\n\n    if (!response.ok) {\n      return [];\n    }\n\n    const data = await response.json();\n    return data.pairs || [];\n  } catch (error) {\n    console.error(`DexScreener search error:`, error);\n    return [];\n  }\n}\n\nexport function pairToPoolData(pair: DexScreenerPair): PoolData {\n  return {\n    address: pair.pairAddress,\n    dex: pair.dexId,\n    baseToken: {\n      symbol: pair.baseToken.symbol,\n      name: pair.baseToken.name,\n      address: pair.baseToken.address,\n    },\n    quoteToken: {\n      symbol: pair.quoteToken.symbol,\n      name: pair.quoteToken.name,\n      address: pair.quoteToken.address,\n    },\n    liquidity: pair.liquidity?.usd || 0,\n    volume24h: pair.volume?.h24 || 0,\n    priceUsd: parseFloat(pair.priceUsd) || 0,\n    priceChange24h: pair.priceChange?.h24 || 0,\n    txCount24h: (pair.txns?.h24?.buys || 0) + (pair.txns?.h24?.sells || 0),\n    createdAt: pair.pairCreatedAt,\n  };\n}\n\nexport async function fetchSolanaToken(\n  address: string\n): Promise<{\n  price: number;\n  priceChange24h: number;\n  volume24h: number;\n  liquidity: number;\n  marketCap: number;\n  fdv: number;\n  txCount24h: number;\n  poolAddress: string;\n  dex: string;\n} | null> {\n  const pairs = await fetchTokenPairs(address);\n\n  if (pairs.length === 0) {\n    return null;\n  }\n\n  // Get the pair with highest liquidity\n  const bestPair = pairs\n    .filter((p) => p.chainId === \"solana\")\n    .sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];\n\n  if (!bestPair) {\n    return null;\n  }\n\n  return {\n    price: parseFloat(bestPair.priceUsd) || 0,\n    priceChange24h: bestPair.priceChange?.h24 || 0,\n    volume24h: bestPair.volume?.h24 || 0,\n    liquidity: bestPair.liquidity?.usd || 0,\n    marketCap: bestPair.marketCap || 0,\n    fdv: bestPair.fdv || 0,\n    txCount24h:\n      (bestPair.txns?.h24?.buys || 0) + (bestPair.txns?.h24?.sells || 0),\n    poolAddress: bestPair.pairAddress,\n    dex: bestPair.dexId,\n  };\n}\n\n// Note: DexScreener doesn't provide OHLCV data directly\n// For Solana tokens, we'll need to aggregate from the pair data\n// or use Jupiter/Birdeye for OHLCV\nexport async function generatePseudoOHLCV(\n  tokenAddress: string,\n  _timeframe: \"1h\" | \"4h\" | \"1d\" = \"1h\"\n): Promise<CandleData[]> {\n  // DexScreener doesn't provide historical OHLCV\n  // This returns current price as a single data point\n  const token = await fetchSolanaToken(tokenAddress);\n\n  if (!token) {\n    return [];\n  }\n\n  const now = Date.now();\n  const price = token.price;\n\n  // Generate synthetic candles based on price change\n  // This is a placeholder - real implementation should use Jupiter or Birdeye\n  const priceChange = token.priceChange24h / 100;\n  const previousPrice = price / (1 + priceChange);\n\n  return [\n    {\n      timestamp: now - 24 * 60 * 60 * 1000,\n      open: previousPrice,\n      high: Math.max(previousPrice, price) * 1.02,\n      low: Math.min(previousPrice, price) * 0.98,\n      close: price,\n      volume: token.volume24h,\n    },\n  ];\n}\n","/**\n * Data Layer - Aggregates all data providers\n * Uses free-tier APIs: CoinGecko, DexScreener, Jupiter\n */\n\nimport type { OHLCV, TokenInfo } from \"../agents/types.js\";\nimport * as coingecko from \"./coingecko.js\";\nimport * as dexscreener from \"./dexscreener.js\";\nimport * as jupiter from \"./jupiter.js\";\n\nexport { coingecko, dexscreener, jupiter };\n\n/**\n * Fetch OHLCV data for a token\n * Automatically selects the best data source based on token info\n */\nexport async function fetchTokenData(\n  token: TokenInfo,\n  timeframe: \"1h\" | \"4h\" | \"1d\"\n): Promise<OHLCV[]> {\n  const days = timeframe === \"1d\" ? 30 : timeframe === \"4h\" ? 7 : 3;\n\n  // For Solana tokens with address, try DexScreener first for current price\n  // then fall back to CoinGecko for OHLCV\n  if (token.chain === \"solana\" && token.address) {\n    // Get current price from DexScreener\n    const dexData = await dexscreener.fetchSolanaToken(token.address);\n\n    if (dexData) {\n      // Try to get OHLCV from CoinGecko by symbol\n      const ohlcv = await coingecko.fetchMarketChart(token.symbol, days);\n\n      if (ohlcv.length > 0) {\n        return ohlcv.map((candle) => ({\n          timestamp: candle.timestamp,\n          open: candle.open,\n          high: candle.high,\n          low: candle.low,\n          close: candle.close,\n          volume: candle.volume,\n        }));\n      }\n\n      // If no OHLCV available, generate minimal data from current price\n      const now = Date.now();\n      const hourMs = 60 * 60 * 1000;\n      const candles: OHLCV[] = [];\n\n      // Generate synthetic candles based on price change\n      const priceChange = dexData.priceChange24h / 100;\n      const currentPrice = dexData.price;\n\n      for (let i = 23; i >= 0; i--) {\n        const timestamp = now - i * hourMs;\n        const progress = (24 - i) / 24;\n        const previousPrice = currentPrice / (1 + priceChange);\n        const price = previousPrice + (currentPrice - previousPrice) * progress;\n\n        // Add some randomness for realistic candles\n        const volatility = Math.abs(priceChange) * 0.1 + 0.005;\n        const high = price * (1 + volatility * Math.random());\n        const low = price * (1 - volatility * Math.random());\n\n        candles.push({\n          timestamp,\n          open: i === 23 ? previousPrice : candles[candles.length - 1]?.close || price,\n          high,\n          low,\n          close: price,\n          volume: dexData.volume24h / 24,\n        });\n      }\n\n      return candles;\n    }\n  }\n\n  // For non-Solana tokens or tokens without address, use CoinGecko\n  const ohlcv = await coingecko.fetchMarketChart(token.symbol, days);\n\n  if (ohlcv.length > 0) {\n    return ohlcv.map((candle) => ({\n      timestamp: candle.timestamp,\n      open: candle.open,\n      high: candle.high,\n      low: candle.low,\n      close: candle.close,\n      volume: candle.volume,\n    }));\n  }\n\n  // Try OHLC endpoint as fallback\n  const ohlc = await coingecko.fetchOHLCV(token.symbol, days);\n  return ohlc.map((candle) => ({\n    timestamp: candle.timestamp,\n    open: candle.open,\n    high: candle.high,\n    low: candle.low,\n    close: candle.close,\n    volume: candle.volume,\n  }));\n}\n\n/**\n * Fetch comprehensive market data for a token\n */\nexport async function fetchMarketData(token: TokenInfo): Promise<{\n  price: number;\n  priceChange24h: number;\n  volume24h: number;\n  marketCap: number;\n  liquidity?: number;\n  fdv?: number;\n  ath?: number;\n  athChange?: number;\n}> {\n  // For Solana tokens with address\n  if (token.chain === \"solana\" && token.address) {\n    const dexData = await dexscreener.fetchSolanaToken(token.address);\n\n    if (dexData) {\n      return {\n        price: dexData.price,\n        priceChange24h: dexData.priceChange24h,\n        volume24h: dexData.volume24h,\n        marketCap: dexData.marketCap,\n        liquidity: dexData.liquidity,\n        fdv: dexData.fdv,\n      };\n    }\n  }\n\n  // Use CoinGecko for other tokens\n  const [priceData, tokenInfo] = await Promise.all([\n    coingecko.fetchPrice(token.symbol),\n    coingecko.fetchTokenInfo(token.symbol),\n  ]);\n\n  return {\n    price: priceData?.price || 0,\n    priceChange24h: priceData?.priceChangePercent24h || 0,\n    volume24h: priceData?.volume24h || 0,\n    marketCap: priceData?.marketCap || tokenInfo?.marketCap || 0,\n    ath: tokenInfo?.ath,\n    athChange: tokenInfo?.athChangePercent,\n  };\n}\n\n/**\n * Search for tokens by symbol or name\n */\nexport async function searchTokens(\n  query: string,\n  chain?: \"solana\" | \"ethereum\" | \"base\"\n): Promise<\n  Array<{\n    symbol: string;\n    name: string;\n    address?: string;\n    chain: string;\n    price: number;\n    marketCap: number;\n  }>\n> {\n  const pairs = await dexscreener.searchTokens(query);\n\n  return pairs\n    .filter((pair) => !chain || pair.chainId === chain)\n    .slice(0, 20)\n    .map((pair) => ({\n      symbol: pair.baseToken.symbol,\n      name: pair.baseToken.name,\n      address: pair.baseToken.address,\n      chain: pair.chainId,\n      price: parseFloat(pair.priceUsd) || 0,\n      marketCap: pair.marketCap || 0,\n    }));\n}\n\n/**\n * Get Jupiter swap quote for Solana tokens\n */\nexport async function getSwapQuote(\n  inputToken: string,\n  outputToken: string,\n  amountIn: number\n): Promise<{\n  amountOut: number;\n  priceImpact: number;\n  route: string[];\n} | null> {\n  // Convert symbols to addresses\n  const inputAddress =\n    jupiter.getTokenAddress(inputToken) || inputToken;\n  const outputAddress =\n    jupiter.getTokenAddress(outputToken) || outputToken;\n\n  const quote = await jupiter.getSwapQuote(inputAddress, outputAddress, amountIn);\n\n  if (!quote) {\n    return null;\n  }\n\n  return {\n    amountOut: parseFloat(quote.outAmount),\n    priceImpact: quote.priceImpactPct,\n    route: quote.routePlan.map((r) => r.swapInfo.label),\n  };\n}\n","/**\n * Trading Graph - Orchestrates all agents for multi-agent trading analysis\n */\n\nimport type {\n  AgentConfig,\n  OHLCV,\n  TokenInfo,\n  TradeDecision,\n  AnalysisRequest,\n} from \"../agents/types.js\";\nimport { IndicatorAgent } from \"../agents/indicator-agent.js\";\nimport { PatternAgent } from \"../agents/pattern-agent.js\";\nimport { TrendAgent } from \"../agents/trend-agent.js\";\nimport { RiskAgent } from \"../agents/risk-agent.js\";\nimport { fetchTokenData } from \"../data/index.js\";\n\nexport interface TradingGraphConfig {\n  agentConfig: AgentConfig;\n  defaultTimeframe?: \"1h\" | \"4h\" | \"1d\";\n  showLogs?: boolean;\n}\n\nexport class TradingGraph {\n  private indicatorAgent: IndicatorAgent;\n  private patternAgent: PatternAgent;\n  private trendAgent: TrendAgent;\n  private riskAgent: RiskAgent;\n  private config: TradingGraphConfig;\n\n  constructor(config: TradingGraphConfig) {\n    this.config = config;\n\n    // Initialize all agents with the same config\n    this.indicatorAgent = new IndicatorAgent(config.agentConfig);\n    this.patternAgent = new PatternAgent(config.agentConfig);\n    this.trendAgent = new TrendAgent(config.agentConfig);\n    this.riskAgent = new RiskAgent(config.agentConfig);\n  }\n\n  /**\n   * Run full analysis pipeline\n   * Executes all agents and synthesizes a trading decision\n   */\n  async analyze(request: AnalysisRequest): Promise<TradeDecision> {\n    const { token, timeframe = this.config.defaultTimeframe || \"4h\" } = request;\n\n    this.log(`\\nStarting QuantAgent analysis for ${token.symbol}...`);\n    this.log(`Timeframe: ${timeframe}`);\n\n    // Fetch data if not provided\n    let data = request.klineData;\n    if (!data || data.length === 0) {\n      this.log(\"Fetching market data...\");\n      try {\n        data = await fetchTokenData(token, timeframe);\n      } catch (error) {\n        this.log(`Data fetch error: ${error}`);\n        data = [];\n      }\n    }\n\n    if (data.length < 50) {\n      this.log(`Warning: Only ${data.length} candles available (need 50+ for full analysis)`);\n    }\n\n    // Run indicator, pattern, and trend agents in parallel\n    this.log(\"\\nRunning agents...\");\n\n    const startTime = Date.now();\n\n    const [indicatorResult, patternResult, trendResult] = await Promise.all([\n      this.runWithTiming(\"Indicator Agent\", () =>\n        this.indicatorAgent.analyze(token, data!)\n      ),\n      this.runWithTiming(\"Pattern Agent\", () =>\n        this.patternAgent.analyze(token, data!)\n      ),\n      this.runWithTiming(\"Trend Agent\", () =>\n        this.trendAgent.analyze(token, data!)\n      ),\n    ]);\n\n    // Risk agent synthesizes all results into a final decision\n    const decision = await this.runWithTiming(\"Risk Agent\", () =>\n      this.riskAgent.analyze({\n        token,\n        data: data!,\n        indicators: indicatorResult.indicators,\n        indicatorSignal: indicatorResult.overallSignal,\n        indicatorConfidence: indicatorResult.confidence,\n        pattern: patternResult,\n        trend: trendResult,\n      })\n    );\n\n    const totalTime = Date.now() - startTime;\n    this.log(`\\nAnalysis complete in ${totalTime}ms`);\n    this.log(`Decision: ${decision.action} (${decision.confidence}% confidence)`);\n\n    return decision;\n  }\n\n  /**\n   * Quick analysis - indicators only (faster)\n   * Good for initial screening\n   */\n  async quickAnalysis(request: AnalysisRequest): Promise<{\n    signal: \"bullish\" | \"bearish\" | \"neutral\";\n    confidence: number;\n    summary: string;\n  }> {\n    const { token, timeframe = \"4h\" } = request;\n\n    let data = request.klineData;\n    if (!data) {\n      data = await fetchTokenData(token, timeframe);\n    }\n\n    const result = await this.indicatorAgent.analyze(token, data);\n\n    return {\n      signal: result.overallSignal,\n      confidence: result.confidence,\n      summary: result.summary,\n    };\n  }\n\n  /**\n   * Get individual agent results without final synthesis\n   * Useful for debugging or custom analysis\n   */\n  async getAgentResults(request: AnalysisRequest): Promise<{\n    indicators: Awaited<ReturnType<IndicatorAgent[\"analyze\"]>>;\n    pattern: Awaited<ReturnType<PatternAgent[\"analyze\"]>>;\n    trend: Awaited<ReturnType<TrendAgent[\"analyze\"]>>;\n  }> {\n    const { token, timeframe = \"4h\" } = request;\n\n    let data = request.klineData;\n    if (!data) {\n      data = await fetchTokenData(token, timeframe);\n    }\n\n    const [indicators, pattern, trend] = await Promise.all([\n      this.indicatorAgent.analyze(token, data),\n      this.patternAgent.analyze(token, data),\n      this.trendAgent.analyze(token, data),\n    ]);\n\n    return { indicators, pattern, trend };\n  }\n\n  private async runWithTiming<T>(\n    name: string,\n    fn: () => Promise<T>\n  ): Promise<T> {\n    const start = Date.now();\n    try {\n      const result = await fn();\n      const duration = Date.now() - start;\n      this.log(`  ${name}: ${duration}ms`);\n      return result;\n    } catch (error) {\n      const duration = Date.now() - start;\n      this.log(`  ${name}: FAILED after ${duration}ms - ${error}`);\n      throw error;\n    }\n  }\n\n  private log(message: string): void {\n    if (this.config.showLogs !== false) {\n      console.log(`[TradingGraph] ${message}`);\n    }\n  }\n}\n\n/**\n * Factory function for easy instantiation\n */\nexport function createTradingGraph(options?: {\n  provider?: \"anthropic\" | \"openai\";\n  model?: string;\n  showLogs?: boolean;\n}): TradingGraph {\n  const provider = options?.provider || \"anthropic\";\n  const model =\n    options?.model ||\n    (provider === \"anthropic\" ? \"claude-sonnet-4-20250514\" : \"gpt-4o\");\n\n  return new TradingGraph({\n    agentConfig: {\n      llmProvider: provider,\n      model,\n      temperature: 0.3,\n      maxTokens: 1000,\n    },\n    defaultTimeframe: \"4h\",\n    showLogs: options?.showLogs ?? true,\n  });\n}\n","/**\n * @gicm/quantagent - Multi-agent LLM trading signals for crypto\n *\n * A gICM marketplace skill that provides AI-powered trading analysis\n * using 4 specialized agents:\n * - IndicatorAgent: Technical indicator analysis (RSI, MACD, etc.)\n * - PatternAgent: Chart pattern recognition\n * - TrendAgent: Trend and momentum analysis\n * - RiskAgent: Risk assessment and trade synthesis\n */\n\n// Main orchestrator\nexport {\n  TradingGraph,\n  createTradingGraph,\n} from \"./orchestrator/trading-graph.js\";\nexport type { TradingGraphConfig } from \"./orchestrator/trading-graph.js\";\n\n// Agents\nexport { IndicatorAgent } from \"./agents/indicator-agent.js\";\nexport { PatternAgent } from \"./agents/pattern-agent.js\";\nexport { TrendAgent } from \"./agents/trend-agent.js\";\nexport { RiskAgent } from \"./agents/risk-agent.js\";\n\n// Types\nexport type {\n  OHLCV,\n  TokenInfo,\n  TradeDecision,\n  IndicatorResult,\n  PatternResult,\n  TrendResult,\n  RiskResult,\n  AnalysisRequest,\n  AgentConfig,\n} from \"./agents/types.js\";\n\n// Data fetching\nexport { fetchTokenData, fetchMarketData, searchTokens } from \"./data/index.js\";\n\n// Indicators\nexport { calculateRSI, calculateRSIWithDivergence } from \"./indicators/rsi.js\";\nexport { calculateMACD, getMACDHistogramTrend } from \"./indicators/macd.js\";\nexport { calculateStochastic, calculateStochRSI } from \"./indicators/stochastic.js\";\nexport { calculateBollingerBands, getBandwidthTrend, detectBollingerBreakout } from \"./indicators/bollinger.js\";\nexport { analyzeVolume, calculateOBV, calculateVWAP, calculateMFI } from \"./indicators/volume.js\";\n\n// Patterns\nexport { detectPatterns } from \"./patterns/detector.js\";\nexport { detectCryptoPatterns } from \"./patterns/crypto-patterns.js\";\n\n// LLM\nexport { LLMClient, createDefaultClient } from \"./llm/client.js\";\n\n/**\n * Quick analysis function - analyze a token with minimal setup\n *\n * @example\n * ```typescript\n * import { analyzeToken } from '@gicm/quantagent';\n *\n * const decision = await analyzeToken('SOL', {\n *   timeframe: '4h',\n *   provider: 'anthropic'\n * });\n *\n * console.log(decision.action);     // \"LONG\" | \"SHORT\" | \"HOLD\"\n * console.log(decision.confidence); // 0-100\n * console.log(decision.rationale);  // Explanation\n * ```\n */\nexport async function analyzeToken(\n  symbol: string,\n  options?: {\n    address?: string;\n    chain?: \"solana\" | \"ethereum\" | \"base\";\n    timeframe?: \"1h\" | \"4h\" | \"1d\";\n    provider?: \"anthropic\" | \"openai\";\n    model?: string;\n  }\n): Promise<import(\"./agents/types.js\").TradeDecision> {\n  const graph = createTradingGraph({\n    provider: options?.provider || \"anthropic\",\n    model: options?.model,\n    showLogs: true,\n  });\n\n  return graph.analyze({\n    token: {\n      symbol: symbol.toUpperCase(),\n      name: symbol,\n      address: options?.address,\n      chain: options?.chain || \"solana\",\n    },\n    timeframe: options?.timeframe || \"4h\",\n  });\n}\n\n/**\n * Quick signal function - get a fast bullish/bearish/neutral signal\n *\n * @example\n * ```typescript\n * import { quickSignal } from '@gicm/quantagent';\n *\n * const signal = await quickSignal('BONK');\n * console.log(signal.signal);     // \"bullish\" | \"bearish\" | \"neutral\"\n * console.log(signal.confidence); // 0-100\n * ```\n */\nexport async function quickSignal(\n  symbol: string,\n  options?: {\n    address?: string;\n    chain?: \"solana\" | \"ethereum\" | \"base\";\n    timeframe?: \"1h\" | \"4h\" | \"1d\";\n    provider?: \"anthropic\" | \"openai\";\n  }\n): Promise<{\n  signal: \"bullish\" | \"bearish\" | \"neutral\";\n  confidence: number;\n  summary: string;\n}> {\n  const graph = createTradingGraph({\n    provider: options?.provider || \"anthropic\",\n    showLogs: false,\n  });\n\n  return graph.quickAnalysis({\n    token: {\n      symbol: symbol.toUpperCase(),\n      name: symbol,\n      address: options?.address,\n      chain: options?.chain || \"solana\",\n    },\n    timeframe: options?.timeframe || \"4h\",\n  });\n}\n"],"mappings":"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","names":["k","currentPrice","BASE_URL","BASE_URL","ohlcv","searchTokens","createTradingGraph"]}