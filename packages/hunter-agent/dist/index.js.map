{"version":3,"sources":["../src/hunter-agent.ts"],"sourcesContent":["import { BaseAgent } from \"@gicm/agent-core\";\nimport type { AgentConfig, AgentContext, AgentResult } from \"@gicm/agent-core\";\nimport { CronJob } from \"cron\";\nimport {\n  type BaseHunterSource,\n  DEFAULT_SCHEDULES,\n  type HunterConfig,\n  type HuntDiscovery,\n  type HuntSource,\n} from \"./types.js\";\nimport { GitHubHunter } from \"./sources/github-hunter.js\";\nimport { HackerNewsHunter } from \"./sources/hackernews-hunter.js\";\nimport { TwitterHunter } from \"./sources/twitter-hunter.js\";\n\nexport interface HunterAgentConfig extends AgentConfig {\n  sources: HunterConfig[];\n  deduplicationTTL?: number; // ms\n  onDiscovery?: (discoveries: HuntDiscovery[]) => Promise<void>;\n}\n\nexport class HunterAgent extends BaseAgent {\n  private hunters: Map<HuntSource, BaseHunterSource> = new Map();\n  private jobs: Map<HuntSource, CronJob> = new Map();\n  private seen: Map<string, number> = new Map(); // fingerprint -> timestamp\n  private deduplicationTTL: number;\n  private onDiscovery?: (discoveries: HuntDiscovery[]) => Promise<void>;\n  private isRunning = false;\n\n  constructor(config: HunterAgentConfig) {\n    super(\"hunter\", config);\n    this.deduplicationTTL = config.deduplicationTTL ?? 7 * 24 * 60 * 60 * 1000; // 7 days\n    this.onDiscovery = config.onDiscovery;\n\n    // Initialize hunters\n    for (const sourceConfig of config.sources) {\n      if (!sourceConfig.enabled) continue;\n\n      const hunter = this.createHunter(sourceConfig);\n      if (hunter) {\n        this.hunters.set(sourceConfig.source, hunter);\n      }\n    }\n  }\n\n  getSystemPrompt(): string {\n    return `You are a tech discovery agent for gICM.\nYour role is to find valuable opportunities from GitHub, HackerNews, and Twitter\nthat are relevant to Web3, AI, and developer tooling.\n\nYou hunt for:\n- Trending GitHub repos in crypto/AI\n- HackerNews posts about web3 and AI\n- Twitter discussions about emerging tech\n\nYou evaluate discoveries based on:\n- Relevance to gICM (Web3/AI focus)\n- Quality signals (stars, engagement)\n- Recency and momentum`;\n  }\n\n  async analyze(context: AgentContext): Promise<AgentResult> {\n    const action = context.action ?? \"hunt\";\n\n    switch (action) {\n      case \"hunt\":\n        return this.performHunt(context.params?.sources as HuntSource[] | undefined);\n\n      case \"status\":\n        return this.getStatus();\n\n      default:\n        return this.createResult(false, null, `Unknown action: ${action}`);\n    }\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      this.log(\"Hunter agent already running\");\n      return;\n    }\n\n    this.isRunning = true;\n    this.log(\"Starting hunter agent\");\n\n    // Schedule jobs for each hunter\n    for (const [source, hunter] of this.hunters) {\n      const schedule = this.getSchedule(source);\n\n      const job = new CronJob(schedule, async () => {\n        this.log(`Running scheduled hunt for ${source}`);\n        await this.huntSource(source, hunter);\n      });\n\n      job.start();\n      this.jobs.set(source, job);\n      this.log(`Scheduled ${source} hunter with cron: ${schedule}`);\n    }\n  }\n\n  async stop(): Promise<void> {\n    this.log(\"Stopping hunter agent\");\n    this.isRunning = false;\n\n    for (const [source, job] of this.jobs) {\n      job.stop();\n      this.log(`Stopped ${source} hunter`);\n    }\n\n    this.jobs.clear();\n  }\n\n  async huntNow(sources?: HuntSource[]): Promise<HuntDiscovery[]> {\n    const targetSources = sources ?? Array.from(this.hunters.keys());\n    const allDiscoveries: HuntDiscovery[] = [];\n\n    for (const source of targetSources) {\n      const hunter = this.hunters.get(source);\n      if (!hunter) continue;\n\n      const discoveries = await this.huntSource(source, hunter);\n      allDiscoveries.push(...discoveries);\n    }\n\n    return allDiscoveries;\n  }\n\n  private async performHunt(\n    sources?: HuntSource[]\n  ): Promise<AgentResult> {\n    try {\n      const discoveries = await this.huntNow(sources);\n\n      return this.createResult(\n        true,\n        {\n          count: discoveries.length,\n          discoveries,\n          sources: sources ?? Array.from(this.hunters.keys()),\n        },\n        undefined,\n        0.9,\n        `Found ${discoveries.length} new discoveries`\n      );\n    } catch (error) {\n      const message = error instanceof Error ? error.message : \"Unknown error\";\n      return this.createResult(false, null, message);\n    }\n  }\n\n  private async huntSource(\n    source: HuntSource,\n    hunter: BaseHunterSource\n  ): Promise<HuntDiscovery[]> {\n    try {\n      this.log(`Hunting ${source}...`);\n\n      // Fetch raw discoveries\n      const rawDiscoveries = await hunter.hunt();\n      this.log(`${source}: Found ${rawDiscoveries.length} raw discoveries`);\n\n      // Transform and filter\n      const discoveries: HuntDiscovery[] = [];\n\n      for (const raw of rawDiscoveries) {\n        const discovery = hunter.transform(raw);\n\n        // Check deduplication\n        if (this.hasSeen(discovery.fingerprint)) {\n          continue;\n        }\n\n        // Mark as seen\n        this.markSeen(discovery.fingerprint);\n        discoveries.push(discovery);\n      }\n\n      this.log(`${source}: ${discoveries.length} new unique discoveries`);\n\n      // Notify callback if provided\n      if (this.onDiscovery && discoveries.length > 0) {\n        await this.onDiscovery(discoveries);\n      }\n\n      return discoveries;\n    } catch (error) {\n      this.log(`${source} hunt failed: ${error}`);\n      return [];\n    }\n  }\n\n  private getStatus(): AgentResult {\n    const status = {\n      isRunning: this.isRunning,\n      hunters: Array.from(this.hunters.keys()),\n      jobs: Array.from(this.jobs.entries()).map(([source, job]) => ({\n        source,\n        running: job.running,\n        nextRun: job.nextDate()?.toISO(),\n      })),\n      seenCount: this.seen.size,\n    };\n\n    return this.createResult(true, status, undefined, 1.0, \"Status retrieved\");\n  }\n\n  private createHunter(config: HunterConfig): BaseHunterSource | null {\n    switch (config.source) {\n      case \"github\":\n        return new GitHubHunter(config);\n      case \"hackernews\":\n        return new HackerNewsHunter(config);\n      case \"twitter\":\n        return new TwitterHunter(config);\n      default:\n        this.log(`Unknown source: ${config.source}`);\n        return null;\n    }\n  }\n\n  private getSchedule(source: HuntSource): string {\n    const config = this.findSourceConfig(source);\n    return config?.schedule ?? DEFAULT_SCHEDULES[source];\n  }\n\n  private findSourceConfig(source: HuntSource): HunterConfig | undefined {\n    const agentConfig = this.config as HunterAgentConfig;\n    return agentConfig.sources.find((s) => s.source === source);\n  }\n\n  private hasSeen(fingerprint: string): boolean {\n    const timestamp = this.seen.get(fingerprint);\n    if (!timestamp) return false;\n\n    // Check if expired\n    if (Date.now() - timestamp > this.deduplicationTTL) {\n      this.seen.delete(fingerprint);\n      return false;\n    }\n\n    return true;\n  }\n\n  private markSeen(fingerprint: string): void {\n    this.seen.set(fingerprint, Date.now());\n\n    // Cleanup old entries periodically\n    if (this.seen.size > 10000) {\n      this.cleanupSeen();\n    }\n  }\n\n  private cleanupSeen(): void {\n    const now = Date.now();\n    for (const [fingerprint, timestamp] of this.seen) {\n      if (now - timestamp > this.deduplicationTTL) {\n        this.seen.delete(fingerprint);\n      }\n    }\n  }\n}\n"],"mappings":"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","names":[]}