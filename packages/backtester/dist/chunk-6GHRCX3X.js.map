{"version":3,"sources":["../src/core/types.ts","../src/core/portfolio.ts","../src/analytics/metrics.ts","../src/core/engine.ts","../src/data/providers/csv.ts","../src/strategies/base.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const BacktesterConfigSchema = z.object({\n  initialCapital: z.number().default(10000),\n  currency: z.string().default(\"USD\"),\n  slippage: z.number().default(0.001), // 0.1%\n  commission: z.number().default(0.001), // 0.1%\n  marginEnabled: z.boolean().default(false),\n  maxLeverage: z.number().default(1),\n  riskFreeRate: z.number().default(0.05), // 5% annual\n});\n\nexport type BacktesterConfig = z.infer<typeof BacktesterConfigSchema>;\n\nexport interface OHLCV {\n  timestamp: Date;\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  volume: number;\n}\n\nexport interface Trade {\n  id: string;\n  symbol: string;\n  side: \"long\" | \"short\";\n  entryPrice: number;\n  exitPrice?: number;\n  quantity: number;\n  entryTime: Date;\n  exitTime?: Date;\n  pnl?: number;\n  pnlPercent?: number;\n  fees: number;\n  status: \"open\" | \"closed\";\n  stopLoss?: number;\n  takeProfit?: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface Position {\n  symbol: string;\n  side: \"long\" | \"short\";\n  quantity: number;\n  avgEntryPrice: number;\n  currentPrice: number;\n  unrealizedPnl: number;\n  realizedPnl: number;\n  openTime: Date;\n  trades: Trade[];\n}\n\nexport interface Order {\n  id: string;\n  symbol: string;\n  side: \"buy\" | \"sell\";\n  type: \"market\" | \"limit\" | \"stop\" | \"stopLimit\";\n  quantity: number;\n  price?: number;\n  stopPrice?: number;\n  status: \"pending\" | \"filled\" | \"cancelled\" | \"rejected\";\n  createdAt: Date;\n  filledAt?: Date;\n  filledPrice?: number;\n  filledQuantity?: number;\n}\n\nexport interface PortfolioSnapshot {\n  timestamp: Date;\n  equity: number;\n  cash: number;\n  positionsValue: number;\n  positions: Position[];\n  drawdown: number;\n  drawdownPercent: number;\n}\n\nexport interface BacktestResult {\n  startDate: Date;\n  endDate: Date;\n  initialCapital: number;\n  finalEquity: number;\n  totalReturn: number;\n  totalReturnPercent: number;\n  trades: Trade[];\n  snapshots: PortfolioSnapshot[];\n  metrics: PerformanceMetrics;\n}\n\nexport interface PerformanceMetrics {\n  // Returns\n  totalReturn: number;\n  annualizedReturn: number;\n  cagr: number;\n\n  // Risk\n  volatility: number;\n  maxDrawdown: number;\n  maxDrawdownDuration: number; // days\n  calmarRatio: number;\n\n  // Risk-adjusted\n  sharpeRatio: number;\n  sortinoRatio: number;\n  informationRatio?: number;\n\n  // Trading\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  winRate: number;\n  avgWin: number;\n  avgLoss: number;\n  profitFactor: number;\n  avgTradeDuration: number; // hours\n  maxConsecutiveWins: number;\n  maxConsecutiveLosses: number;\n\n  // Exposure\n  avgExposure: number;\n  maxExposure: number;\n  avgLeverage: number;\n}\n\nexport interface Signal {\n  symbol: string;\n  action: \"buy\" | \"sell\" | \"hold\";\n  strength: number; // 0-1\n  price: number;\n  timestamp: Date;\n  reason?: string;\n  confidence?: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface DataProvider {\n  name: string;\n  getOHLCV(symbol: string, interval: string, start: Date, end: Date): Promise<OHLCV[]>;\n  getLatestPrice(symbol: string): Promise<number>;\n}\n","import type { Position, Trade, PortfolioSnapshot, Order, BacktesterConfig } from \"./types.js\";\n\nexport class Portfolio {\n  private cash: number;\n  private positions: Map<string, Position> = new Map();\n  private trades: Trade[] = [];\n  private orders: Map<string, Order> = new Map();\n  private snapshots: PortfolioSnapshot[] = [];\n  private config: BacktesterConfig;\n  private highWaterMark: number;\n  private tradeCounter = 0;\n  private orderCounter = 0;\n\n  constructor(config: BacktesterConfig) {\n    this.config = config;\n    this.cash = config.initialCapital;\n    this.highWaterMark = config.initialCapital;\n  }\n\n  getEquity(prices: Map<string, number>): number {\n    let positionsValue = 0;\n    for (const [symbol, position] of this.positions) {\n      const price = prices.get(symbol) ?? position.currentPrice;\n      positionsValue += position.quantity * price;\n    }\n    return this.cash + positionsValue;\n  }\n\n  getCash(): number {\n    return this.cash;\n  }\n\n  getPosition(symbol: string): Position | undefined {\n    return this.positions.get(symbol);\n  }\n\n  getAllPositions(): Position[] {\n    return Array.from(this.positions.values());\n  }\n\n  getTrades(): Trade[] {\n    return this.trades;\n  }\n\n  placeOrder(order: Omit<Order, \"id\" | \"createdAt\" | \"status\">): Order {\n    const newOrder: Order = {\n      ...order,\n      id: `order_${++this.orderCounter}`,\n      createdAt: new Date(),\n      status: \"pending\",\n    };\n    this.orders.set(newOrder.id, newOrder);\n    return newOrder;\n  }\n\n  executeOrder(orderId: string, price: number, timestamp: Date): Trade | null {\n    const order = this.orders.get(orderId);\n    if (!order || order.status !== \"pending\") return null;\n\n    // Apply slippage\n    const slippage = order.side === \"buy\"\n      ? price * (1 + this.config.slippage)\n      : price * (1 - this.config.slippage);\n    const executionPrice = slippage;\n\n    // Calculate commission\n    const commission = order.quantity * executionPrice * this.config.commission;\n\n    // Check if we have enough cash for buys\n    if (order.side === \"buy\") {\n      const totalCost = order.quantity * executionPrice + commission;\n      if (totalCost > this.cash) {\n        order.status = \"rejected\";\n        return null;\n      }\n    }\n\n    // Update order status\n    order.status = \"filled\";\n    order.filledAt = timestamp;\n    order.filledPrice = executionPrice;\n    order.filledQuantity = order.quantity;\n\n    // Create or update position\n    const trade = this.processTrade(order, executionPrice, timestamp, commission);\n    return trade;\n  }\n\n  private processTrade(\n    order: Order,\n    price: number,\n    timestamp: Date,\n    commission: number\n  ): Trade {\n    const symbol = order.symbol;\n    let position = this.positions.get(symbol);\n\n    const trade: Trade = {\n      id: `trade_${++this.tradeCounter}`,\n      symbol,\n      side: order.side === \"buy\" ? \"long\" : \"short\",\n      entryPrice: price,\n      quantity: order.quantity,\n      entryTime: timestamp,\n      fees: commission,\n      status: \"open\",\n    };\n\n    if (order.side === \"buy\") {\n      // Opening or adding to long position\n      this.cash -= order.quantity * price + commission;\n\n      if (!position) {\n        position = {\n          symbol,\n          side: \"long\",\n          quantity: order.quantity,\n          avgEntryPrice: price,\n          currentPrice: price,\n          unrealizedPnl: 0,\n          realizedPnl: 0,\n          openTime: timestamp,\n          trades: [trade],\n        };\n      } else {\n        // Average up/down\n        const totalQuantity = position.quantity + order.quantity;\n        position.avgEntryPrice =\n          (position.avgEntryPrice * position.quantity + price * order.quantity) /\n          totalQuantity;\n        position.quantity = totalQuantity;\n        position.trades.push(trade);\n      }\n    } else {\n      // Closing long position or opening short\n      if (position && position.side === \"long\") {\n        const closeQuantity = Math.min(position.quantity, order.quantity);\n        const pnl = (price - position.avgEntryPrice) * closeQuantity - commission;\n\n        trade.exitPrice = price;\n        trade.exitTime = timestamp;\n        trade.pnl = pnl;\n        trade.pnlPercent = (pnl / (position.avgEntryPrice * closeQuantity)) * 100;\n        trade.status = \"closed\";\n\n        this.cash += closeQuantity * price - commission;\n        position.realizedPnl += pnl;\n        position.quantity -= closeQuantity;\n\n        if (position.quantity <= 0) {\n          this.positions.delete(symbol);\n        }\n      }\n    }\n\n    if (position && position.quantity > 0) {\n      this.positions.set(symbol, position);\n    }\n\n    this.trades.push(trade);\n    return trade;\n  }\n\n  updatePrices(prices: Map<string, number>, timestamp: Date): void {\n    for (const [symbol, position] of this.positions) {\n      const price = prices.get(symbol);\n      if (price !== undefined) {\n        position.currentPrice = price;\n        position.unrealizedPnl =\n          (price - position.avgEntryPrice) * position.quantity *\n          (position.side === \"long\" ? 1 : -1);\n      }\n    }\n\n    // Record snapshot\n    const equity = this.getEquity(prices);\n    this.highWaterMark = Math.max(this.highWaterMark, equity);\n    const drawdown = this.highWaterMark - equity;\n    const drawdownPercent = this.highWaterMark > 0 ? (drawdown / this.highWaterMark) * 100 : 0;\n\n    this.snapshots.push({\n      timestamp,\n      equity,\n      cash: this.cash,\n      positionsValue: equity - this.cash,\n      positions: this.getAllPositions().map((p) => ({ ...p })),\n      drawdown,\n      drawdownPercent,\n    });\n  }\n\n  getSnapshots(): PortfolioSnapshot[] {\n    return this.snapshots;\n  }\n\n  getHighWaterMark(): number {\n    return this.highWaterMark;\n  }\n\n  reset(): void {\n    this.cash = this.config.initialCapital;\n    this.positions.clear();\n    this.trades = [];\n    this.orders.clear();\n    this.snapshots = [];\n    this.highWaterMark = this.config.initialCapital;\n    this.tradeCounter = 0;\n    this.orderCounter = 0;\n  }\n}\n","import type {\n  PerformanceMetrics,\n  PortfolioSnapshot,\n  Trade,\n  BacktesterConfig,\n} from \"../core/types.js\";\n\nexport class MetricsCalculator {\n  private config: BacktesterConfig;\n\n  constructor(config: BacktesterConfig) {\n    this.config = config;\n  }\n\n  calculate(\n    snapshots: PortfolioSnapshot[],\n    trades: Trade[],\n    startDate: Date,\n    endDate: Date\n  ): PerformanceMetrics {\n    const closedTrades = trades.filter((t) => t.status === \"closed\");\n\n    // Returns\n    const returns = this.calculateReturns(snapshots);\n    const totalReturn = this.calculateTotalReturn(snapshots);\n    const annualizedReturn = this.calculateAnnualizedReturn(\n      totalReturn,\n      startDate,\n      endDate\n    );\n    const cagr = this.calculateCAGR(snapshots, startDate, endDate);\n\n    // Risk\n    const volatility = this.calculateVolatility(returns);\n    const { maxDrawdown, maxDrawdownDuration } = this.calculateMaxDrawdown(snapshots);\n    const calmarRatio = this.calculateCalmarRatio(annualizedReturn, maxDrawdown);\n\n    // Risk-adjusted\n    const sharpeRatio = this.calculateSharpeRatio(returns, volatility);\n    const sortinoRatio = this.calculateSortinoRatio(returns);\n\n    // Trading metrics\n    const tradingMetrics = this.calculateTradingMetrics(closedTrades);\n\n    // Exposure\n    const exposureMetrics = this.calculateExposureMetrics(snapshots);\n\n    return {\n      totalReturn,\n      annualizedReturn,\n      cagr,\n      volatility,\n      maxDrawdown,\n      maxDrawdownDuration,\n      calmarRatio,\n      sharpeRatio,\n      sortinoRatio,\n      ...tradingMetrics,\n      ...exposureMetrics,\n    };\n  }\n\n  private calculateReturns(snapshots: PortfolioSnapshot[]): number[] {\n    const returns: number[] = [];\n    for (let i = 1; i < snapshots.length; i++) {\n      const prev = snapshots[i - 1]!.equity;\n      const curr = snapshots[i]!.equity;\n      returns.push((curr - prev) / prev);\n    }\n    return returns;\n  }\n\n  private calculateTotalReturn(snapshots: PortfolioSnapshot[]): number {\n    if (snapshots.length < 2) return 0;\n    const first = snapshots[0]!.equity;\n    const last = snapshots[snapshots.length - 1]!.equity;\n    return (last - first) / first;\n  }\n\n  private calculateAnnualizedReturn(\n    totalReturn: number,\n    startDate: Date,\n    endDate: Date\n  ): number {\n    const years =\n      (endDate.getTime() - startDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n    if (years === 0) return 0;\n    return Math.pow(1 + totalReturn, 1 / years) - 1;\n  }\n\n  private calculateCAGR(\n    snapshots: PortfolioSnapshot[],\n    startDate: Date,\n    endDate: Date\n  ): number {\n    if (snapshots.length < 2) return 0;\n    const first = snapshots[0]!.equity;\n    const last = snapshots[snapshots.length - 1]!.equity;\n    const years =\n      (endDate.getTime() - startDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000);\n    if (years === 0) return 0;\n    return Math.pow(last / first, 1 / years) - 1;\n  }\n\n  private calculateVolatility(returns: number[]): number {\n    if (returns.length < 2) return 0;\n    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance =\n      returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) /\n      (returns.length - 1);\n    // Annualize assuming daily returns\n    return Math.sqrt(variance) * Math.sqrt(252);\n  }\n\n  private calculateMaxDrawdown(\n    snapshots: PortfolioSnapshot[]\n  ): { maxDrawdown: number; maxDrawdownDuration: number } {\n    let maxDrawdown = 0;\n    let maxDrawdownDuration = 0;\n    let peak = snapshots[0]?.equity ?? 0;\n    let drawdownStart: Date | null = null;\n    let currentDuration = 0;\n\n    for (const snapshot of snapshots) {\n      if (snapshot.equity > peak) {\n        peak = snapshot.equity;\n        if (drawdownStart) {\n          const duration =\n            (snapshot.timestamp.getTime() - drawdownStart.getTime()) /\n            (24 * 60 * 60 * 1000);\n          maxDrawdownDuration = Math.max(maxDrawdownDuration, duration);\n          drawdownStart = null;\n        }\n        currentDuration = 0;\n      } else {\n        const drawdown = (peak - snapshot.equity) / peak;\n        if (drawdown > maxDrawdown) {\n          maxDrawdown = drawdown;\n        }\n        if (!drawdownStart) {\n          drawdownStart = snapshot.timestamp;\n        }\n      }\n    }\n\n    return { maxDrawdown, maxDrawdownDuration };\n  }\n\n  private calculateSharpeRatio(returns: number[], volatility: number): number {\n    if (volatility === 0 || returns.length === 0) return 0;\n    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const annualizedReturn = avgReturn * 252;\n    return (annualizedReturn - this.config.riskFreeRate) / volatility;\n  }\n\n  private calculateSortinoRatio(returns: number[]): number {\n    if (returns.length === 0) return 0;\n\n    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const negativeReturns = returns.filter((r) => r < 0);\n\n    if (negativeReturns.length === 0) return Infinity;\n\n    const downsideVariance =\n      negativeReturns.reduce((sum, r) => sum + r * r, 0) / negativeReturns.length;\n    const downsideDeviation = Math.sqrt(downsideVariance) * Math.sqrt(252);\n\n    if (downsideDeviation === 0) return Infinity;\n\n    const annualizedReturn = avgReturn * 252;\n    return (annualizedReturn - this.config.riskFreeRate) / downsideDeviation;\n  }\n\n  private calculateCalmarRatio(\n    annualizedReturn: number,\n    maxDrawdown: number\n  ): number {\n    if (maxDrawdown === 0) return Infinity;\n    return annualizedReturn / maxDrawdown;\n  }\n\n  private calculateTradingMetrics(trades: Trade[]): {\n    totalTrades: number;\n    winningTrades: number;\n    losingTrades: number;\n    winRate: number;\n    avgWin: number;\n    avgLoss: number;\n    profitFactor: number;\n    avgTradeDuration: number;\n    maxConsecutiveWins: number;\n    maxConsecutiveLosses: number;\n  } {\n    const winners = trades.filter((t) => (t.pnl ?? 0) > 0);\n    const losers = trades.filter((t) => (t.pnl ?? 0) < 0);\n\n    const avgWin =\n      winners.length > 0\n        ? winners.reduce((sum, t) => sum + (t.pnl ?? 0), 0) / winners.length\n        : 0;\n\n    const avgLoss =\n      losers.length > 0\n        ? Math.abs(losers.reduce((sum, t) => sum + (t.pnl ?? 0), 0)) / losers.length\n        : 0;\n\n    const totalWins = winners.reduce((sum, t) => sum + (t.pnl ?? 0), 0);\n    const totalLosses = Math.abs(losers.reduce((sum, t) => sum + (t.pnl ?? 0), 0));\n    const profitFactor = totalLosses > 0 ? totalWins / totalLosses : Infinity;\n\n    // Average trade duration\n    const durations = trades\n      .filter((t) => t.exitTime)\n      .map((t) => (t.exitTime!.getTime() - t.entryTime.getTime()) / (1000 * 60 * 60));\n    const avgTradeDuration =\n      durations.length > 0\n        ? durations.reduce((a, b) => a + b, 0) / durations.length\n        : 0;\n\n    // Consecutive wins/losses\n    let maxConsecutiveWins = 0;\n    let maxConsecutiveLosses = 0;\n    let currentWins = 0;\n    let currentLosses = 0;\n\n    for (const trade of trades) {\n      if ((trade.pnl ?? 0) > 0) {\n        currentWins++;\n        currentLosses = 0;\n        maxConsecutiveWins = Math.max(maxConsecutiveWins, currentWins);\n      } else if ((trade.pnl ?? 0) < 0) {\n        currentLosses++;\n        currentWins = 0;\n        maxConsecutiveLosses = Math.max(maxConsecutiveLosses, currentLosses);\n      }\n    }\n\n    return {\n      totalTrades: trades.length,\n      winningTrades: winners.length,\n      losingTrades: losers.length,\n      winRate: trades.length > 0 ? winners.length / trades.length : 0,\n      avgWin,\n      avgLoss,\n      profitFactor,\n      avgTradeDuration,\n      maxConsecutiveWins,\n      maxConsecutiveLosses,\n    };\n  }\n\n  private calculateExposureMetrics(snapshots: PortfolioSnapshot[]): {\n    avgExposure: number;\n    maxExposure: number;\n    avgLeverage: number;\n  } {\n    if (snapshots.length === 0) {\n      return { avgExposure: 0, maxExposure: 0, avgLeverage: 0 };\n    }\n\n    const exposures = snapshots.map((s) => s.positionsValue / s.equity);\n    const avgExposure = exposures.reduce((a, b) => a + b, 0) / exposures.length;\n    const maxExposure = Math.max(...exposures);\n\n    return {\n      avgExposure,\n      maxExposure,\n      avgLeverage: avgExposure, // For non-margin, exposure = leverage\n    };\n  }\n}\n","import type {\n  BacktesterConfig,\n  OHLCV,\n  BacktestResult,\n  Signal,\n  DataProvider,\n} from \"./types.js\";\nimport { BacktesterConfigSchema } from \"./types.js\";\nimport { Portfolio } from \"./portfolio.js\";\nimport type { Strategy } from \"../strategies/base.js\";\nimport { MetricsCalculator } from \"../analytics/metrics.js\";\n\nexport interface BacktestOptions {\n  startDate: Date;\n  endDate: Date;\n  symbols: string[];\n  interval: string;\n  warmupPeriod?: number;\n}\n\nexport class BacktestEngine {\n  private config: BacktesterConfig;\n  private portfolio: Portfolio;\n  private strategy?: Strategy;\n  private dataProvider?: DataProvider;\n  private metricsCalculator: MetricsCalculator;\n\n  constructor(config: Partial<BacktesterConfig> = {}) {\n    this.config = BacktesterConfigSchema.parse(config);\n    this.portfolio = new Portfolio(this.config);\n    this.metricsCalculator = new MetricsCalculator(this.config);\n  }\n\n  setStrategy(strategy: Strategy): void {\n    this.strategy = strategy;\n  }\n\n  setDataProvider(provider: DataProvider): void {\n    this.dataProvider = provider;\n  }\n\n  async run(options: BacktestOptions): Promise<BacktestResult> {\n    if (!this.strategy) {\n      throw new Error(\"Strategy not set\");\n    }\n    if (!this.dataProvider) {\n      throw new Error(\"Data provider not set\");\n    }\n\n    this.portfolio.reset();\n    this.strategy.reset();\n\n    // Fetch data for all symbols\n    const dataMap = new Map<string, OHLCV[]>();\n    for (const symbol of options.symbols) {\n      const data = await this.dataProvider.getOHLCV(\n        symbol,\n        options.interval,\n        options.startDate,\n        options.endDate\n      );\n      dataMap.set(symbol, data);\n    }\n\n    // Align data by timestamp\n    const alignedData = this.alignData(dataMap);\n    const warmupPeriod = options.warmupPeriod ?? 20;\n\n    // Run simulation\n    for (let i = 0; i < alignedData.length; i++) {\n      const bar = alignedData[i]!;\n      const timestamp = bar.timestamp;\n      const historicalBars = alignedData.slice(Math.max(0, i - 100), i + 1);\n\n      // Update prices\n      const prices = new Map<string, number>();\n      for (const symbol of options.symbols) {\n        const symbolData = dataMap.get(symbol);\n        const currentBar = symbolData?.find(\n          (b) => b.timestamp.getTime() === timestamp.getTime()\n        );\n        if (currentBar) {\n          prices.set(symbol, currentBar.close);\n        }\n      }\n\n      this.portfolio.updatePrices(prices, timestamp);\n\n      // Skip warmup period\n      if (i < warmupPeriod) continue;\n\n      // Generate signals\n      const signals = await this.strategy.generateSignals(\n        historicalBars,\n        this.portfolio.getAllPositions()\n      );\n\n      // Execute signals\n      for (const signal of signals) {\n        await this.executeSignal(signal, prices, timestamp);\n      }\n    }\n\n    // Close all open positions at end\n    const finalBar = alignedData[alignedData.length - 1];\n    if (finalBar) {\n      const finalPrices = new Map<string, number>();\n      for (const symbol of options.symbols) {\n        const symbolData = dataMap.get(symbol);\n        const lastBar = symbolData?.[symbolData.length - 1];\n        if (lastBar) {\n          finalPrices.set(symbol, lastBar.close);\n        }\n      }\n      this.closeAllPositions(finalPrices, finalBar.timestamp);\n    }\n\n    // Calculate metrics\n    const metrics = this.metricsCalculator.calculate(\n      this.portfolio.getSnapshots(),\n      this.portfolio.getTrades(),\n      options.startDate,\n      options.endDate\n    );\n\n    const finalEquity = this.portfolio.getEquity(new Map());\n\n    return {\n      startDate: options.startDate,\n      endDate: options.endDate,\n      initialCapital: this.config.initialCapital,\n      finalEquity,\n      totalReturn: finalEquity - this.config.initialCapital,\n      totalReturnPercent:\n        ((finalEquity - this.config.initialCapital) / this.config.initialCapital) * 100,\n      trades: this.portfolio.getTrades(),\n      snapshots: this.portfolio.getSnapshots(),\n      metrics,\n    };\n  }\n\n  private alignData(dataMap: Map<string, OHLCV[]>): OHLCV[] {\n    // Get all unique timestamps\n    const timestamps = new Set<number>();\n    for (const data of dataMap.values()) {\n      for (const bar of data) {\n        timestamps.add(bar.timestamp.getTime());\n      }\n    }\n\n    // Sort timestamps\n    const sortedTimestamps = Array.from(timestamps).sort((a, b) => a - b);\n\n    // Create aligned data (using first symbol as reference)\n    const firstSymbol = Array.from(dataMap.keys())[0];\n    const firstData = dataMap.get(firstSymbol!);\n    if (!firstData) return [];\n\n    return sortedTimestamps\n      .map((ts) => firstData.find((b) => b.timestamp.getTime() === ts))\n      .filter((b): b is OHLCV => b !== undefined);\n  }\n\n  private async executeSignal(\n    signal: Signal,\n    prices: Map<string, number>,\n    timestamp: Date\n  ): Promise<void> {\n    const currentPrice = prices.get(signal.symbol);\n    if (!currentPrice) return;\n\n    const position = this.portfolio.getPosition(signal.symbol);\n    const equity = this.portfolio.getEquity(prices);\n\n    if (signal.action === \"buy\" && !position) {\n      // Calculate position size (example: 10% of equity)\n      const positionValue = equity * 0.1;\n      const quantity = positionValue / currentPrice;\n\n      const order = this.portfolio.placeOrder({\n        symbol: signal.symbol,\n        side: \"buy\",\n        type: \"market\",\n        quantity,\n      });\n\n      this.portfolio.executeOrder(order.id, currentPrice, timestamp);\n    } else if (signal.action === \"sell\" && position) {\n      const order = this.portfolio.placeOrder({\n        symbol: signal.symbol,\n        side: \"sell\",\n        type: \"market\",\n        quantity: position.quantity,\n      });\n\n      this.portfolio.executeOrder(order.id, currentPrice, timestamp);\n    }\n  }\n\n  private closeAllPositions(prices: Map<string, number>, timestamp: Date): void {\n    for (const position of this.portfolio.getAllPositions()) {\n      const price = prices.get(position.symbol);\n      if (price) {\n        const order = this.portfolio.placeOrder({\n          symbol: position.symbol,\n          side: \"sell\",\n          type: \"market\",\n          quantity: position.quantity,\n        });\n        this.portfolio.executeOrder(order.id, price, timestamp);\n      }\n    }\n  }\n\n  getPortfolio(): Portfolio {\n    return this.portfolio;\n  }\n}\n","import type { DataProvider, OHLCV } from \"../../core/types.js\";\n\nexport interface CSVDataConfig {\n  data: string;\n  dateColumn?: string;\n  dateFormat?: string;\n  openColumn?: string;\n  highColumn?: string;\n  lowColumn?: string;\n  closeColumn?: string;\n  volumeColumn?: string;\n  delimiter?: string;\n}\n\nexport class CSVDataProvider implements DataProvider {\n  name = \"csv\";\n  private data: Map<string, OHLCV[]> = new Map();\n\n  async loadFromString(symbol: string, csv: string, config: Partial<CSVDataConfig> = {}): Promise<void> {\n    const delimiter = config.delimiter ?? \",\";\n    const lines = csv.trim().split(\"\\n\");\n\n    if (lines.length < 2) return;\n\n    const headers = lines[0]!.split(delimiter).map((h) => h.trim().toLowerCase());\n\n    // Find column indices\n    const dateCol = headers.indexOf(config.dateColumn?.toLowerCase() ?? \"date\");\n    const openCol = headers.indexOf(config.openColumn?.toLowerCase() ?? \"open\");\n    const highCol = headers.indexOf(config.highColumn?.toLowerCase() ?? \"high\");\n    const lowCol = headers.indexOf(config.lowColumn?.toLowerCase() ?? \"low\");\n    const closeCol = headers.indexOf(config.closeColumn?.toLowerCase() ?? \"close\");\n    const volumeCol = headers.indexOf(config.volumeColumn?.toLowerCase() ?? \"volume\");\n\n    const bars: OHLCV[] = [];\n\n    for (let i = 1; i < lines.length; i++) {\n      const line = lines[i]!.trim();\n      if (!line) continue;\n\n      const values = line.split(delimiter);\n\n      try {\n        const timestamp = this.parseDate(values[dateCol] ?? \"\", config.dateFormat);\n        const open = parseFloat(values[openCol] ?? \"0\");\n        const high = parseFloat(values[highCol] ?? \"0\");\n        const low = parseFloat(values[lowCol] ?? \"0\");\n        const close = parseFloat(values[closeCol] ?? \"0\");\n        const volume = parseFloat(values[volumeCol] ?? \"0\");\n\n        if (!isNaN(timestamp.getTime()) && !isNaN(close)) {\n          bars.push({ timestamp, open, high, low, close, volume });\n        }\n      } catch {\n        // Skip invalid lines\n        continue;\n      }\n    }\n\n    // Sort by timestamp\n    bars.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n    this.data.set(symbol, bars);\n  }\n\n  private parseDate(dateStr: string, format?: string): Date {\n    // Try ISO format first\n    const isoDate = new Date(dateStr);\n    if (!isNaN(isoDate.getTime())) {\n      return isoDate;\n    }\n\n    // Try Unix timestamp\n    const timestamp = parseInt(dateStr);\n    if (!isNaN(timestamp)) {\n      // Detect if milliseconds or seconds\n      if (timestamp > 1e12) {\n        return new Date(timestamp);\n      } else {\n        return new Date(timestamp * 1000);\n      }\n    }\n\n    // Default to current date if parsing fails\n    return new Date();\n  }\n\n  async getOHLCV(\n    symbol: string,\n    _interval: string,\n    start: Date,\n    end: Date\n  ): Promise<OHLCV[]> {\n    const allData = this.data.get(symbol) ?? [];\n\n    return allData.filter(\n      (bar) => bar.timestamp >= start && bar.timestamp <= end\n    );\n  }\n\n  async getLatestPrice(symbol: string): Promise<number> {\n    const data = this.data.get(symbol);\n    if (!data || data.length === 0) return 0;\n    return data[data.length - 1]!.close;\n  }\n\n  getSymbols(): string[] {\n    return Array.from(this.data.keys());\n  }\n\n  hasData(symbol: string): boolean {\n    return this.data.has(symbol) && this.data.get(symbol)!.length > 0;\n  }\n\n  getDataRange(symbol: string): { start: Date; end: Date } | null {\n    const data = this.data.get(symbol);\n    if (!data || data.length === 0) return null;\n\n    return {\n      start: data[0]!.timestamp,\n      end: data[data.length - 1]!.timestamp,\n    };\n  }\n}\n","import type { OHLCV, Signal, Position } from \"../core/types.js\";\n\nexport interface StrategyConfig {\n  name: string;\n  description?: string;\n  parameters: Record<string, unknown>;\n}\n\nexport abstract class Strategy {\n  protected name: string;\n  protected description: string;\n  protected parameters: Record<string, unknown>;\n\n  constructor(config: StrategyConfig) {\n    this.name = config.name;\n    this.description = config.description ?? \"\";\n    this.parameters = config.parameters;\n  }\n\n  abstract generateSignals(\n    bars: OHLCV[],\n    positions: Position[]\n  ): Promise<Signal[]>;\n\n  abstract reset(): void;\n\n  getName(): string {\n    return this.name;\n  }\n\n  getDescription(): string {\n    return this.description;\n  }\n\n  getParameters(): Record<string, unknown> {\n    return this.parameters;\n  }\n\n  setParameter(key: string, value: unknown): void {\n    this.parameters[key] = value;\n  }\n}\n\n// Simple Moving Average Crossover Strategy\nexport class SMACrossoverStrategy extends Strategy {\n  private shortPeriod: number;\n  private longPeriod: number;\n  private symbol: string;\n\n  constructor(config: { symbol: string; shortPeriod?: number; longPeriod?: number }) {\n    super({\n      name: \"SMA Crossover\",\n      description: \"Buy when short SMA crosses above long SMA, sell when it crosses below\",\n      parameters: {\n        shortPeriod: config.shortPeriod ?? 10,\n        longPeriod: config.longPeriod ?? 30,\n        symbol: config.symbol,\n      },\n    });\n    this.shortPeriod = config.shortPeriod ?? 10;\n    this.longPeriod = config.longPeriod ?? 30;\n    this.symbol = config.symbol;\n  }\n\n  async generateSignals(bars: OHLCV[], positions: Position[]): Promise<Signal[]> {\n    if (bars.length < this.longPeriod + 1) return [];\n\n    const signals: Signal[] = [];\n    const closes = bars.map((b) => b.close);\n\n    // Calculate SMAs\n    const shortSMA = this.calculateSMA(closes, this.shortPeriod);\n    const longSMA = this.calculateSMA(closes, this.longPeriod);\n    const prevShortSMA = this.calculateSMA(closes.slice(0, -1), this.shortPeriod);\n    const prevLongSMA = this.calculateSMA(closes.slice(0, -1), this.longPeriod);\n\n    const currentBar = bars[bars.length - 1]!;\n    const hasPosition = positions.some((p) => p.symbol === this.symbol);\n\n    // Golden cross (buy signal)\n    if (prevShortSMA <= prevLongSMA && shortSMA > longSMA && !hasPosition) {\n      signals.push({\n        symbol: this.symbol,\n        action: \"buy\",\n        strength: 0.8,\n        price: currentBar.close,\n        timestamp: currentBar.timestamp,\n        reason: \"Golden cross: Short SMA crossed above Long SMA\",\n      });\n    }\n\n    // Death cross (sell signal)\n    if (prevShortSMA >= prevLongSMA && shortSMA < longSMA && hasPosition) {\n      signals.push({\n        symbol: this.symbol,\n        action: \"sell\",\n        strength: 0.8,\n        price: currentBar.close,\n        timestamp: currentBar.timestamp,\n        reason: \"Death cross: Short SMA crossed below Long SMA\",\n      });\n    }\n\n    return signals;\n  }\n\n  private calculateSMA(prices: number[], period: number): number {\n    if (prices.length < period) return 0;\n    const slice = prices.slice(-period);\n    return slice.reduce((a, b) => a + b, 0) / period;\n  }\n\n  reset(): void {\n    // No state to reset for this strategy\n  }\n}\n\n// RSI Strategy\nexport class RSIStrategy extends Strategy {\n  private period: number;\n  private oversoldThreshold: number;\n  private overboughtThreshold: number;\n  private symbol: string;\n\n  constructor(config: {\n    symbol: string;\n    period?: number;\n    oversoldThreshold?: number;\n    overboughtThreshold?: number;\n  }) {\n    super({\n      name: \"RSI Strategy\",\n      description: \"Buy when RSI is oversold, sell when overbought\",\n      parameters: {\n        period: config.period ?? 14,\n        oversoldThreshold: config.oversoldThreshold ?? 30,\n        overboughtThreshold: config.overboughtThreshold ?? 70,\n        symbol: config.symbol,\n      },\n    });\n    this.period = config.period ?? 14;\n    this.oversoldThreshold = config.oversoldThreshold ?? 30;\n    this.overboughtThreshold = config.overboughtThreshold ?? 70;\n    this.symbol = config.symbol;\n  }\n\n  async generateSignals(bars: OHLCV[], positions: Position[]): Promise<Signal[]> {\n    if (bars.length < this.period + 1) return [];\n\n    const signals: Signal[] = [];\n    const rsi = this.calculateRSI(bars);\n    const currentBar = bars[bars.length - 1]!;\n    const hasPosition = positions.some((p) => p.symbol === this.symbol);\n\n    // Oversold (buy signal)\n    if (rsi < this.oversoldThreshold && !hasPosition) {\n      signals.push({\n        symbol: this.symbol,\n        action: \"buy\",\n        strength: (this.oversoldThreshold - rsi) / this.oversoldThreshold,\n        price: currentBar.close,\n        timestamp: currentBar.timestamp,\n        reason: `RSI oversold at ${rsi.toFixed(2)}`,\n      });\n    }\n\n    // Overbought (sell signal)\n    if (rsi > this.overboughtThreshold && hasPosition) {\n      signals.push({\n        symbol: this.symbol,\n        action: \"sell\",\n        strength: (rsi - this.overboughtThreshold) / (100 - this.overboughtThreshold),\n        price: currentBar.close,\n        timestamp: currentBar.timestamp,\n        reason: `RSI overbought at ${rsi.toFixed(2)}`,\n      });\n    }\n\n    return signals;\n  }\n\n  private calculateRSI(bars: OHLCV[]): number {\n    const closes = bars.map((b) => b.close);\n    const changes: number[] = [];\n\n    for (let i = 1; i < closes.length; i++) {\n      changes.push(closes[i]! - closes[i - 1]!);\n    }\n\n    const recentChanges = changes.slice(-this.period);\n    const gains = recentChanges.filter((c) => c > 0);\n    const losses = recentChanges.filter((c) => c < 0).map((c) => Math.abs(c));\n\n    const avgGain = gains.length > 0\n      ? gains.reduce((a, b) => a + b, 0) / this.period\n      : 0;\n    const avgLoss = losses.length > 0\n      ? losses.reduce((a, b) => a + b, 0) / this.period\n      : 0;\n\n    if (avgLoss === 0) return 100;\n    const rs = avgGain / avgLoss;\n    return 100 - 100 / (1 + rs);\n  }\n\n  reset(): void {\n    // No state to reset\n  }\n}\n"],"mappings":";AAAA,SAAS,SAAS;AAEX,IAAM,yBAAyB,EAAE,OAAO;AAAA,EAC7C,gBAAgB,EAAE,OAAO,EAAE,QAAQ,GAAK;AAAA,EACxC,UAAU,EAAE,OAAO,EAAE,QAAQ,KAAK;AAAA,EAClC,UAAU,EAAE,OAAO,EAAE,QAAQ,IAAK;AAAA;AAAA,EAClC,YAAY,EAAE,OAAO,EAAE,QAAQ,IAAK;AAAA;AAAA,EACpC,eAAe,EAAE,QAAQ,EAAE,QAAQ,KAAK;AAAA,EACxC,aAAa,EAAE,OAAO,EAAE,QAAQ,CAAC;AAAA,EACjC,cAAc,EAAE,OAAO,EAAE,QAAQ,IAAI;AAAA;AACvC,CAAC;;;ACRM,IAAM,YAAN,MAAgB;AAAA,EACb;AAAA,EACA,YAAmC,oBAAI,IAAI;AAAA,EAC3C,SAAkB,CAAC;AAAA,EACnB,SAA6B,oBAAI,IAAI;AAAA,EACrC,YAAiC,CAAC;AAAA,EAClC;AAAA,EACA;AAAA,EACA,eAAe;AAAA,EACf,eAAe;AAAA,EAEvB,YAAY,QAA0B;AACpC,SAAK,SAAS;AACd,SAAK,OAAO,OAAO;AACnB,SAAK,gBAAgB,OAAO;AAAA,EAC9B;AAAA,EAEA,UAAU,QAAqC;AAC7C,QAAI,iBAAiB;AACrB,eAAW,CAAC,QAAQ,QAAQ,KAAK,KAAK,WAAW;AAC/C,YAAM,QAAQ,OAAO,IAAI,MAAM,KAAK,SAAS;AAC7C,wBAAkB,SAAS,WAAW;AAAA,IACxC;AACA,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,UAAkB;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,YAAY,QAAsC;AAChD,WAAO,KAAK,UAAU,IAAI,MAAM;AAAA,EAClC;AAAA,EAEA,kBAA8B;AAC5B,WAAO,MAAM,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,EAC3C;AAAA,EAEA,YAAqB;AACnB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,WAAW,OAA0D;AACnE,UAAM,WAAkB;AAAA,MACtB,GAAG;AAAA,MACH,IAAI,SAAS,EAAE,KAAK,YAAY;AAAA,MAChC,WAAW,oBAAI,KAAK;AAAA,MACpB,QAAQ;AAAA,IACV;AACA,SAAK,OAAO,IAAI,SAAS,IAAI,QAAQ;AACrC,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,SAAiB,OAAe,WAA+B;AAC1E,UAAM,QAAQ,KAAK,OAAO,IAAI,OAAO;AACrC,QAAI,CAAC,SAAS,MAAM,WAAW,UAAW,QAAO;AAGjD,UAAM,WAAW,MAAM,SAAS,QAC5B,SAAS,IAAI,KAAK,OAAO,YACzB,SAAS,IAAI,KAAK,OAAO;AAC7B,UAAM,iBAAiB;AAGvB,UAAM,aAAa,MAAM,WAAW,iBAAiB,KAAK,OAAO;AAGjE,QAAI,MAAM,SAAS,OAAO;AACxB,YAAM,YAAY,MAAM,WAAW,iBAAiB;AACpD,UAAI,YAAY,KAAK,MAAM;AACzB,cAAM,SAAS;AACf,eAAO;AAAA,MACT;AAAA,IACF;AAGA,UAAM,SAAS;AACf,UAAM,WAAW;AACjB,UAAM,cAAc;AACpB,UAAM,iBAAiB,MAAM;AAG7B,UAAM,QAAQ,KAAK,aAAa,OAAO,gBAAgB,WAAW,UAAU;AAC5E,WAAO;AAAA,EACT;AAAA,EAEQ,aACN,OACA,OACA,WACA,YACO;AACP,UAAM,SAAS,MAAM;AACrB,QAAI,WAAW,KAAK,UAAU,IAAI,MAAM;AAExC,UAAM,QAAe;AAAA,MACnB,IAAI,SAAS,EAAE,KAAK,YAAY;AAAA,MAChC;AAAA,MACA,MAAM,MAAM,SAAS,QAAQ,SAAS;AAAA,MACtC,YAAY;AAAA,MACZ,UAAU,MAAM;AAAA,MAChB,WAAW;AAAA,MACX,MAAM;AAAA,MACN,QAAQ;AAAA,IACV;AAEA,QAAI,MAAM,SAAS,OAAO;AAExB,WAAK,QAAQ,MAAM,WAAW,QAAQ;AAEtC,UAAI,CAAC,UAAU;AACb,mBAAW;AAAA,UACT;AAAA,UACA,MAAM;AAAA,UACN,UAAU,MAAM;AAAA,UAChB,eAAe;AAAA,UACf,cAAc;AAAA,UACd,eAAe;AAAA,UACf,aAAa;AAAA,UACb,UAAU;AAAA,UACV,QAAQ,CAAC,KAAK;AAAA,QAChB;AAAA,MACF,OAAO;AAEL,cAAM,gBAAgB,SAAS,WAAW,MAAM;AAChD,iBAAS,iBACN,SAAS,gBAAgB,SAAS,WAAW,QAAQ,MAAM,YAC5D;AACF,iBAAS,WAAW;AACpB,iBAAS,OAAO,KAAK,KAAK;AAAA,MAC5B;AAAA,IACF,OAAO;AAEL,UAAI,YAAY,SAAS,SAAS,QAAQ;AACxC,cAAM,gBAAgB,KAAK,IAAI,SAAS,UAAU,MAAM,QAAQ;AAChE,cAAM,OAAO,QAAQ,SAAS,iBAAiB,gBAAgB;AAE/D,cAAM,YAAY;AAClB,cAAM,WAAW;AACjB,cAAM,MAAM;AACZ,cAAM,aAAc,OAAO,SAAS,gBAAgB,iBAAkB;AACtE,cAAM,SAAS;AAEf,aAAK,QAAQ,gBAAgB,QAAQ;AACrC,iBAAS,eAAe;AACxB,iBAAS,YAAY;AAErB,YAAI,SAAS,YAAY,GAAG;AAC1B,eAAK,UAAU,OAAO,MAAM;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAEA,QAAI,YAAY,SAAS,WAAW,GAAG;AACrC,WAAK,UAAU,IAAI,QAAQ,QAAQ;AAAA,IACrC;AAEA,SAAK,OAAO,KAAK,KAAK;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,QAA6B,WAAuB;AAC/D,eAAW,CAAC,QAAQ,QAAQ,KAAK,KAAK,WAAW;AAC/C,YAAM,QAAQ,OAAO,IAAI,MAAM;AAC/B,UAAI,UAAU,QAAW;AACvB,iBAAS,eAAe;AACxB,iBAAS,iBACN,QAAQ,SAAS,iBAAiB,SAAS,YAC3C,SAAS,SAAS,SAAS,IAAI;AAAA,MACpC;AAAA,IACF;AAGA,UAAM,SAAS,KAAK,UAAU,MAAM;AACpC,SAAK,gBAAgB,KAAK,IAAI,KAAK,eAAe,MAAM;AACxD,UAAM,WAAW,KAAK,gBAAgB;AACtC,UAAM,kBAAkB,KAAK,gBAAgB,IAAK,WAAW,KAAK,gBAAiB,MAAM;AAEzF,SAAK,UAAU,KAAK;AAAA,MAClB;AAAA,MACA;AAAA,MACA,MAAM,KAAK;AAAA,MACX,gBAAgB,SAAS,KAAK;AAAA,MAC9B,WAAW,KAAK,gBAAgB,EAAE,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE;AAAA,MACvD;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,eAAoC;AAClC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,mBAA2B;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,QAAc;AACZ,SAAK,OAAO,KAAK,OAAO;AACxB,SAAK,UAAU,MAAM;AACrB,SAAK,SAAS,CAAC;AACf,SAAK,OAAO,MAAM;AAClB,SAAK,YAAY,CAAC;AAClB,SAAK,gBAAgB,KAAK,OAAO;AACjC,SAAK,eAAe;AACpB,SAAK,eAAe;AAAA,EACtB;AACF;;;AC1MO,IAAM,oBAAN,MAAwB;AAAA,EACrB;AAAA,EAER,YAAY,QAA0B;AACpC,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,UACE,WACA,QACA,WACA,SACoB;AACpB,UAAM,eAAe,OAAO,OAAO,CAAC,MAAM,EAAE,WAAW,QAAQ;AAG/D,UAAM,UAAU,KAAK,iBAAiB,SAAS;AAC/C,UAAM,cAAc,KAAK,qBAAqB,SAAS;AACvD,UAAM,mBAAmB,KAAK;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,OAAO,KAAK,cAAc,WAAW,WAAW,OAAO;AAG7D,UAAM,aAAa,KAAK,oBAAoB,OAAO;AACnD,UAAM,EAAE,aAAa,oBAAoB,IAAI,KAAK,qBAAqB,SAAS;AAChF,UAAM,cAAc,KAAK,qBAAqB,kBAAkB,WAAW;AAG3E,UAAM,cAAc,KAAK,qBAAqB,SAAS,UAAU;AACjE,UAAM,eAAe,KAAK,sBAAsB,OAAO;AAGvD,UAAM,iBAAiB,KAAK,wBAAwB,YAAY;AAGhE,UAAM,kBAAkB,KAAK,yBAAyB,SAAS;AAE/D,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACF;AAAA,EAEQ,iBAAiB,WAA0C;AACjE,UAAM,UAAoB,CAAC;AAC3B,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,OAAO,UAAU,IAAI,CAAC,EAAG;AAC/B,YAAM,OAAO,UAAU,CAAC,EAAG;AAC3B,cAAQ,MAAM,OAAO,QAAQ,IAAI;AAAA,IACnC;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,qBAAqB,WAAwC;AACnE,QAAI,UAAU,SAAS,EAAG,QAAO;AACjC,UAAM,QAAQ,UAAU,CAAC,EAAG;AAC5B,UAAM,OAAO,UAAU,UAAU,SAAS,CAAC,EAAG;AAC9C,YAAQ,OAAO,SAAS;AAAA,EAC1B;AAAA,EAEQ,0BACN,aACA,WACA,SACQ;AACR,UAAM,SACH,QAAQ,QAAQ,IAAI,UAAU,QAAQ,MAAM,SAAS,KAAK,KAAK,KAAK;AACvE,QAAI,UAAU,EAAG,QAAO;AACxB,WAAO,KAAK,IAAI,IAAI,aAAa,IAAI,KAAK,IAAI;AAAA,EAChD;AAAA,EAEQ,cACN,WACA,WACA,SACQ;AACR,QAAI,UAAU,SAAS,EAAG,QAAO;AACjC,UAAM,QAAQ,UAAU,CAAC,EAAG;AAC5B,UAAM,OAAO,UAAU,UAAU,SAAS,CAAC,EAAG;AAC9C,UAAM,SACH,QAAQ,QAAQ,IAAI,UAAU,QAAQ,MAAM,SAAS,KAAK,KAAK,KAAK;AACvE,QAAI,UAAU,EAAG,QAAO;AACxB,WAAO,KAAK,IAAI,OAAO,OAAO,IAAI,KAAK,IAAI;AAAA,EAC7C;AAAA,EAEQ,oBAAoB,SAA2B;AACrD,QAAI,QAAQ,SAAS,EAAG,QAAO;AAC/B,UAAM,OAAO,QAAQ,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,QAAQ;AAC1D,UAAM,WACJ,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,KAAK,IAAI,IAAI,MAAM,CAAC,GAAG,CAAC,KACxD,QAAQ,SAAS;AAEpB,WAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,GAAG;AAAA,EAC5C;AAAA,EAEQ,qBACN,WACsD;AACtD,QAAI,cAAc;AAClB,QAAI,sBAAsB;AAC1B,QAAI,OAAO,UAAU,CAAC,GAAG,UAAU;AACnC,QAAI,gBAA6B;AACjC,QAAI,kBAAkB;AAEtB,eAAW,YAAY,WAAW;AAChC,UAAI,SAAS,SAAS,MAAM;AAC1B,eAAO,SAAS;AAChB,YAAI,eAAe;AACjB,gBAAM,YACH,SAAS,UAAU,QAAQ,IAAI,cAAc,QAAQ,MACrD,KAAK,KAAK,KAAK;AAClB,gCAAsB,KAAK,IAAI,qBAAqB,QAAQ;AAC5D,0BAAgB;AAAA,QAClB;AACA,0BAAkB;AAAA,MACpB,OAAO;AACL,cAAM,YAAY,OAAO,SAAS,UAAU;AAC5C,YAAI,WAAW,aAAa;AAC1B,wBAAc;AAAA,QAChB;AACA,YAAI,CAAC,eAAe;AAClB,0BAAgB,SAAS;AAAA,QAC3B;AAAA,MACF;AAAA,IACF;AAEA,WAAO,EAAE,aAAa,oBAAoB;AAAA,EAC5C;AAAA,EAEQ,qBAAqB,SAAmB,YAA4B;AAC1E,QAAI,eAAe,KAAK,QAAQ,WAAW,EAAG,QAAO;AACrD,UAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,QAAQ;AAC/D,UAAM,mBAAmB,YAAY;AACrC,YAAQ,mBAAmB,KAAK,OAAO,gBAAgB;AAAA,EACzD;AAAA,EAEQ,sBAAsB,SAA2B;AACvD,QAAI,QAAQ,WAAW,EAAG,QAAO;AAEjC,UAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,QAAQ;AAC/D,UAAM,kBAAkB,QAAQ,OAAO,CAAC,MAAM,IAAI,CAAC;AAEnD,QAAI,gBAAgB,WAAW,EAAG,QAAO;AAEzC,UAAM,mBACJ,gBAAgB,OAAO,CAAC,KAAK,MAAM,MAAM,IAAI,GAAG,CAAC,IAAI,gBAAgB;AACvE,UAAM,oBAAoB,KAAK,KAAK,gBAAgB,IAAI,KAAK,KAAK,GAAG;AAErE,QAAI,sBAAsB,EAAG,QAAO;AAEpC,UAAM,mBAAmB,YAAY;AACrC,YAAQ,mBAAmB,KAAK,OAAO,gBAAgB;AAAA,EACzD;AAAA,EAEQ,qBACN,kBACA,aACQ;AACR,QAAI,gBAAgB,EAAG,QAAO;AAC9B,WAAO,mBAAmB;AAAA,EAC5B;AAAA,EAEQ,wBAAwB,QAW9B;AACA,UAAM,UAAU,OAAO,OAAO,CAAC,OAAO,EAAE,OAAO,KAAK,CAAC;AACrD,UAAM,SAAS,OAAO,OAAO,CAAC,OAAO,EAAE,OAAO,KAAK,CAAC;AAEpD,UAAM,SACJ,QAAQ,SAAS,IACb,QAAQ,OAAO,CAAC,KAAK,MAAM,OAAO,EAAE,OAAO,IAAI,CAAC,IAAI,QAAQ,SAC5D;AAEN,UAAM,UACJ,OAAO,SAAS,IACZ,KAAK,IAAI,OAAO,OAAO,CAAC,KAAK,MAAM,OAAO,EAAE,OAAO,IAAI,CAAC,CAAC,IAAI,OAAO,SACpE;AAEN,UAAM,YAAY,QAAQ,OAAO,CAAC,KAAK,MAAM,OAAO,EAAE,OAAO,IAAI,CAAC;AAClE,UAAM,cAAc,KAAK,IAAI,OAAO,OAAO,CAAC,KAAK,MAAM,OAAO,EAAE,OAAO,IAAI,CAAC,CAAC;AAC7E,UAAM,eAAe,cAAc,IAAI,YAAY,cAAc;AAGjE,UAAM,YAAY,OACf,OAAO,CAAC,MAAM,EAAE,QAAQ,EACxB,IAAI,CAAC,OAAO,EAAE,SAAU,QAAQ,IAAI,EAAE,UAAU,QAAQ,MAAM,MAAO,KAAK,GAAG;AAChF,UAAM,mBACJ,UAAU,SAAS,IACf,UAAU,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,UAAU,SACjD;AAGN,QAAI,qBAAqB;AACzB,QAAI,uBAAuB;AAC3B,QAAI,cAAc;AAClB,QAAI,gBAAgB;AAEpB,eAAW,SAAS,QAAQ;AAC1B,WAAK,MAAM,OAAO,KAAK,GAAG;AACxB;AACA,wBAAgB;AAChB,6BAAqB,KAAK,IAAI,oBAAoB,WAAW;AAAA,MAC/D,YAAY,MAAM,OAAO,KAAK,GAAG;AAC/B;AACA,sBAAc;AACd,+BAAuB,KAAK,IAAI,sBAAsB,aAAa;AAAA,MACrE;AAAA,IACF;AAEA,WAAO;AAAA,MACL,aAAa,OAAO;AAAA,MACpB,eAAe,QAAQ;AAAA,MACvB,cAAc,OAAO;AAAA,MACrB,SAAS,OAAO,SAAS,IAAI,QAAQ,SAAS,OAAO,SAAS;AAAA,MAC9D;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,yBAAyB,WAI/B;AACA,QAAI,UAAU,WAAW,GAAG;AAC1B,aAAO,EAAE,aAAa,GAAG,aAAa,GAAG,aAAa,EAAE;AAAA,IAC1D;AAEA,UAAM,YAAY,UAAU,IAAI,CAAC,MAAM,EAAE,iBAAiB,EAAE,MAAM;AAClE,UAAM,cAAc,UAAU,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,UAAU;AACrE,UAAM,cAAc,KAAK,IAAI,GAAG,SAAS;AAEzC,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,aAAa;AAAA;AAAA,IACf;AAAA,EACF;AACF;;;AC1PO,IAAM,iBAAN,MAAqB;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAAoC,CAAC,GAAG;AAClD,SAAK,SAAS,uBAAuB,MAAM,MAAM;AACjD,SAAK,YAAY,IAAI,UAAU,KAAK,MAAM;AAC1C,SAAK,oBAAoB,IAAI,kBAAkB,KAAK,MAAM;AAAA,EAC5D;AAAA,EAEA,YAAY,UAA0B;AACpC,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,gBAAgB,UAA8B;AAC5C,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,MAAM,IAAI,SAAmD;AAC3D,QAAI,CAAC,KAAK,UAAU;AAClB,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AACA,QAAI,CAAC,KAAK,cAAc;AACtB,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAEA,SAAK,UAAU,MAAM;AACrB,SAAK,SAAS,MAAM;AAGpB,UAAM,UAAU,oBAAI,IAAqB;AACzC,eAAW,UAAU,QAAQ,SAAS;AACpC,YAAM,OAAO,MAAM,KAAK,aAAa;AAAA,QACnC;AAAA,QACA,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ;AAAA,MACV;AACA,cAAQ,IAAI,QAAQ,IAAI;AAAA,IAC1B;AAGA,UAAM,cAAc,KAAK,UAAU,OAAO;AAC1C,UAAM,eAAe,QAAQ,gBAAgB;AAG7C,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,YAAM,MAAM,YAAY,CAAC;AACzB,YAAM,YAAY,IAAI;AACtB,YAAM,iBAAiB,YAAY,MAAM,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,CAAC;AAGpE,YAAM,SAAS,oBAAI,IAAoB;AACvC,iBAAW,UAAU,QAAQ,SAAS;AACpC,cAAM,aAAa,QAAQ,IAAI,MAAM;AACrC,cAAM,aAAa,YAAY;AAAA,UAC7B,CAAC,MAAM,EAAE,UAAU,QAAQ,MAAM,UAAU,QAAQ;AAAA,QACrD;AACA,YAAI,YAAY;AACd,iBAAO,IAAI,QAAQ,WAAW,KAAK;AAAA,QACrC;AAAA,MACF;AAEA,WAAK,UAAU,aAAa,QAAQ,SAAS;AAG7C,UAAI,IAAI,aAAc;AAGtB,YAAM,UAAU,MAAM,KAAK,SAAS;AAAA,QAClC;AAAA,QACA,KAAK,UAAU,gBAAgB;AAAA,MACjC;AAGA,iBAAW,UAAU,SAAS;AAC5B,cAAM,KAAK,cAAc,QAAQ,QAAQ,SAAS;AAAA,MACpD;AAAA,IACF;AAGA,UAAM,WAAW,YAAY,YAAY,SAAS,CAAC;AACnD,QAAI,UAAU;AACZ,YAAM,cAAc,oBAAI,IAAoB;AAC5C,iBAAW,UAAU,QAAQ,SAAS;AACpC,cAAM,aAAa,QAAQ,IAAI,MAAM;AACrC,cAAM,UAAU,aAAa,WAAW,SAAS,CAAC;AAClD,YAAI,SAAS;AACX,sBAAY,IAAI,QAAQ,QAAQ,KAAK;AAAA,QACvC;AAAA,MACF;AACA,WAAK,kBAAkB,aAAa,SAAS,SAAS;AAAA,IACxD;AAGA,UAAM,UAAU,KAAK,kBAAkB;AAAA,MACrC,KAAK,UAAU,aAAa;AAAA,MAC5B,KAAK,UAAU,UAAU;AAAA,MACzB,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAEA,UAAM,cAAc,KAAK,UAAU,UAAU,oBAAI,IAAI,CAAC;AAEtD,WAAO;AAAA,MACL,WAAW,QAAQ;AAAA,MACnB,SAAS,QAAQ;AAAA,MACjB,gBAAgB,KAAK,OAAO;AAAA,MAC5B;AAAA,MACA,aAAa,cAAc,KAAK,OAAO;AAAA,MACvC,qBACI,cAAc,KAAK,OAAO,kBAAkB,KAAK,OAAO,iBAAkB;AAAA,MAC9E,QAAQ,KAAK,UAAU,UAAU;AAAA,MACjC,WAAW,KAAK,UAAU,aAAa;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,UAAU,SAAwC;AAExD,UAAM,aAAa,oBAAI,IAAY;AACnC,eAAW,QAAQ,QAAQ,OAAO,GAAG;AACnC,iBAAW,OAAO,MAAM;AACtB,mBAAW,IAAI,IAAI,UAAU,QAAQ,CAAC;AAAA,MACxC;AAAA,IACF;AAGA,UAAM,mBAAmB,MAAM,KAAK,UAAU,EAAE,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAGpE,UAAM,cAAc,MAAM,KAAK,QAAQ,KAAK,CAAC,EAAE,CAAC;AAChD,UAAM,YAAY,QAAQ,IAAI,WAAY;AAC1C,QAAI,CAAC,UAAW,QAAO,CAAC;AAExB,WAAO,iBACJ,IAAI,CAAC,OAAO,UAAU,KAAK,CAAC,MAAM,EAAE,UAAU,QAAQ,MAAM,EAAE,CAAC,EAC/D,OAAO,CAAC,MAAkB,MAAM,MAAS;AAAA,EAC9C;AAAA,EAEA,MAAc,cACZ,QACA,QACA,WACe;AACf,UAAM,eAAe,OAAO,IAAI,OAAO,MAAM;AAC7C,QAAI,CAAC,aAAc;AAEnB,UAAM,WAAW,KAAK,UAAU,YAAY,OAAO,MAAM;AACzD,UAAM,SAAS,KAAK,UAAU,UAAU,MAAM;AAE9C,QAAI,OAAO,WAAW,SAAS,CAAC,UAAU;AAExC,YAAM,gBAAgB,SAAS;AAC/B,YAAM,WAAW,gBAAgB;AAEjC,YAAM,QAAQ,KAAK,UAAU,WAAW;AAAA,QACtC,QAAQ,OAAO;AAAA,QACf,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,MACF,CAAC;AAED,WAAK,UAAU,aAAa,MAAM,IAAI,cAAc,SAAS;AAAA,IAC/D,WAAW,OAAO,WAAW,UAAU,UAAU;AAC/C,YAAM,QAAQ,KAAK,UAAU,WAAW;AAAA,QACtC,QAAQ,OAAO;AAAA,QACf,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU,SAAS;AAAA,MACrB,CAAC;AAED,WAAK,UAAU,aAAa,MAAM,IAAI,cAAc,SAAS;AAAA,IAC/D;AAAA,EACF;AAAA,EAEQ,kBAAkB,QAA6B,WAAuB;AAC5E,eAAW,YAAY,KAAK,UAAU,gBAAgB,GAAG;AACvD,YAAM,QAAQ,OAAO,IAAI,SAAS,MAAM;AACxC,UAAI,OAAO;AACT,cAAM,QAAQ,KAAK,UAAU,WAAW;AAAA,UACtC,QAAQ,SAAS;AAAA,UACjB,MAAM;AAAA,UACN,MAAM;AAAA,UACN,UAAU,SAAS;AAAA,QACrB,CAAC;AACD,aAAK,UAAU,aAAa,MAAM,IAAI,OAAO,SAAS;AAAA,MACxD;AAAA,IACF;AAAA,EACF;AAAA,EAEA,eAA0B;AACxB,WAAO,KAAK;AAAA,EACd;AACF;;;AC3MO,IAAM,kBAAN,MAA8C;AAAA,EACnD,OAAO;AAAA,EACC,OAA6B,oBAAI,IAAI;AAAA,EAE7C,MAAM,eAAe,QAAgB,KAAa,SAAiC,CAAC,GAAkB;AACpG,UAAM,YAAY,OAAO,aAAa;AACtC,UAAM,QAAQ,IAAI,KAAK,EAAE,MAAM,IAAI;AAEnC,QAAI,MAAM,SAAS,EAAG;AAEtB,UAAM,UAAU,MAAM,CAAC,EAAG,MAAM,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,YAAY,CAAC;AAG5E,UAAM,UAAU,QAAQ,QAAQ,OAAO,YAAY,YAAY,KAAK,MAAM;AAC1E,UAAM,UAAU,QAAQ,QAAQ,OAAO,YAAY,YAAY,KAAK,MAAM;AAC1E,UAAM,UAAU,QAAQ,QAAQ,OAAO,YAAY,YAAY,KAAK,MAAM;AAC1E,UAAM,SAAS,QAAQ,QAAQ,OAAO,WAAW,YAAY,KAAK,KAAK;AACvE,UAAM,WAAW,QAAQ,QAAQ,OAAO,aAAa,YAAY,KAAK,OAAO;AAC7E,UAAM,YAAY,QAAQ,QAAQ,OAAO,cAAc,YAAY,KAAK,QAAQ;AAEhF,UAAM,OAAgB,CAAC;AAEvB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC,EAAG,KAAK;AAC5B,UAAI,CAAC,KAAM;AAEX,YAAM,SAAS,KAAK,MAAM,SAAS;AAEnC,UAAI;AACF,cAAM,YAAY,KAAK,UAAU,OAAO,OAAO,KAAK,IAAI,OAAO,UAAU;AACzE,cAAM,OAAO,WAAW,OAAO,OAAO,KAAK,GAAG;AAC9C,cAAM,OAAO,WAAW,OAAO,OAAO,KAAK,GAAG;AAC9C,cAAM,MAAM,WAAW,OAAO,MAAM,KAAK,GAAG;AAC5C,cAAM,QAAQ,WAAW,OAAO,QAAQ,KAAK,GAAG;AAChD,cAAM,SAAS,WAAW,OAAO,SAAS,KAAK,GAAG;AAElD,YAAI,CAAC,MAAM,UAAU,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,GAAG;AAChD,eAAK,KAAK,EAAE,WAAW,MAAM,MAAM,KAAK,OAAO,OAAO,CAAC;AAAA,QACzD;AAAA,MACF,QAAQ;AAEN;AAAA,MACF;AAAA,IACF;AAGA,SAAK,KAAK,CAAC,GAAG,MAAM,EAAE,UAAU,QAAQ,IAAI,EAAE,UAAU,QAAQ,CAAC;AACjE,SAAK,KAAK,IAAI,QAAQ,IAAI;AAAA,EAC5B;AAAA,EAEQ,UAAU,SAAiB,QAAuB;AAExD,UAAM,UAAU,IAAI,KAAK,OAAO;AAChC,QAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,GAAG;AAC7B,aAAO;AAAA,IACT;AAGA,UAAM,YAAY,SAAS,OAAO;AAClC,QAAI,CAAC,MAAM,SAAS,GAAG;AAErB,UAAI,YAAY,MAAM;AACpB,eAAO,IAAI,KAAK,SAAS;AAAA,MAC3B,OAAO;AACL,eAAO,IAAI,KAAK,YAAY,GAAI;AAAA,MAClC;AAAA,IACF;AAGA,WAAO,oBAAI,KAAK;AAAA,EAClB;AAAA,EAEA,MAAM,SACJ,QACA,WACA,OACA,KACkB;AAClB,UAAM,UAAU,KAAK,KAAK,IAAI,MAAM,KAAK,CAAC;AAE1C,WAAO,QAAQ;AAAA,MACb,CAAC,QAAQ,IAAI,aAAa,SAAS,IAAI,aAAa;AAAA,IACtD;AAAA,EACF;AAAA,EAEA,MAAM,eAAe,QAAiC;AACpD,UAAM,OAAO,KAAK,KAAK,IAAI,MAAM;AACjC,QAAI,CAAC,QAAQ,KAAK,WAAW,EAAG,QAAO;AACvC,WAAO,KAAK,KAAK,SAAS,CAAC,EAAG;AAAA,EAChC;AAAA,EAEA,aAAuB;AACrB,WAAO,MAAM,KAAK,KAAK,KAAK,KAAK,CAAC;AAAA,EACpC;AAAA,EAEA,QAAQ,QAAyB;AAC/B,WAAO,KAAK,KAAK,IAAI,MAAM,KAAK,KAAK,KAAK,IAAI,MAAM,EAAG,SAAS;AAAA,EAClE;AAAA,EAEA,aAAa,QAAmD;AAC9D,UAAM,OAAO,KAAK,KAAK,IAAI,MAAM;AACjC,QAAI,CAAC,QAAQ,KAAK,WAAW,EAAG,QAAO;AAEvC,WAAO;AAAA,MACL,OAAO,KAAK,CAAC,EAAG;AAAA,MAChB,KAAK,KAAK,KAAK,SAAS,CAAC,EAAG;AAAA,IAC9B;AAAA,EACF;AACF;;;AClHO,IAAe,WAAf,MAAwB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EAEV,YAAY,QAAwB;AAClC,SAAK,OAAO,OAAO;AACnB,SAAK,cAAc,OAAO,eAAe;AACzC,SAAK,aAAa,OAAO;AAAA,EAC3B;AAAA,EASA,UAAkB;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,iBAAyB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,gBAAyC;AACvC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,aAAa,KAAa,OAAsB;AAC9C,SAAK,WAAW,GAAG,IAAI;AAAA,EACzB;AACF;AAGO,IAAM,uBAAN,cAAmC,SAAS;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,QAAuE;AACjF,UAAM;AAAA,MACJ,MAAM;AAAA,MACN,aAAa;AAAA,MACb,YAAY;AAAA,QACV,aAAa,OAAO,eAAe;AAAA,QACnC,YAAY,OAAO,cAAc;AAAA,QACjC,QAAQ,OAAO;AAAA,MACjB;AAAA,IACF,CAAC;AACD,SAAK,cAAc,OAAO,eAAe;AACzC,SAAK,aAAa,OAAO,cAAc;AACvC,SAAK,SAAS,OAAO;AAAA,EACvB;AAAA,EAEA,MAAM,gBAAgB,MAAe,WAA0C;AAC7E,QAAI,KAAK,SAAS,KAAK,aAAa,EAAG,QAAO,CAAC;AAE/C,UAAM,UAAoB,CAAC;AAC3B,UAAM,SAAS,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK;AAGtC,UAAM,WAAW,KAAK,aAAa,QAAQ,KAAK,WAAW;AAC3D,UAAM,UAAU,KAAK,aAAa,QAAQ,KAAK,UAAU;AACzD,UAAM,eAAe,KAAK,aAAa,OAAO,MAAM,GAAG,EAAE,GAAG,KAAK,WAAW;AAC5E,UAAM,cAAc,KAAK,aAAa,OAAO,MAAM,GAAG,EAAE,GAAG,KAAK,UAAU;AAE1E,UAAM,aAAa,KAAK,KAAK,SAAS,CAAC;AACvC,UAAM,cAAc,UAAU,KAAK,CAAC,MAAM,EAAE,WAAW,KAAK,MAAM;AAGlE,QAAI,gBAAgB,eAAe,WAAW,WAAW,CAAC,aAAa;AACrE,cAAQ,KAAK;AAAA,QACX,QAAQ,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,UAAU;AAAA,QACV,OAAO,WAAW;AAAA,QAClB,WAAW,WAAW;AAAA,QACtB,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAGA,QAAI,gBAAgB,eAAe,WAAW,WAAW,aAAa;AACpE,cAAQ,KAAK;AAAA,QACX,QAAQ,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,UAAU;AAAA,QACV,OAAO,WAAW;AAAA,QAClB,WAAW,WAAW;AAAA,QACtB,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa,QAAkB,QAAwB;AAC7D,QAAI,OAAO,SAAS,OAAQ,QAAO;AACnC,UAAM,QAAQ,OAAO,MAAM,CAAC,MAAM;AAClC,WAAO,MAAM,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI;AAAA,EAC5C;AAAA,EAEA,QAAc;AAAA,EAEd;AACF;AAGO,IAAM,cAAN,cAA0B,SAAS;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,QAKT;AACD,UAAM;AAAA,MACJ,MAAM;AAAA,MACN,aAAa;AAAA,MACb,YAAY;AAAA,QACV,QAAQ,OAAO,UAAU;AAAA,QACzB,mBAAmB,OAAO,qBAAqB;AAAA,QAC/C,qBAAqB,OAAO,uBAAuB;AAAA,QACnD,QAAQ,OAAO;AAAA,MACjB;AAAA,IACF,CAAC;AACD,SAAK,SAAS,OAAO,UAAU;AAC/B,SAAK,oBAAoB,OAAO,qBAAqB;AACrD,SAAK,sBAAsB,OAAO,uBAAuB;AACzD,SAAK,SAAS,OAAO;AAAA,EACvB;AAAA,EAEA,MAAM,gBAAgB,MAAe,WAA0C;AAC7E,QAAI,KAAK,SAAS,KAAK,SAAS,EAAG,QAAO,CAAC;AAE3C,UAAM,UAAoB,CAAC;AAC3B,UAAM,MAAM,KAAK,aAAa,IAAI;AAClC,UAAM,aAAa,KAAK,KAAK,SAAS,CAAC;AACvC,UAAM,cAAc,UAAU,KAAK,CAAC,MAAM,EAAE,WAAW,KAAK,MAAM;AAGlE,QAAI,MAAM,KAAK,qBAAqB,CAAC,aAAa;AAChD,cAAQ,KAAK;AAAA,QACX,QAAQ,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,WAAW,KAAK,oBAAoB,OAAO,KAAK;AAAA,QAChD,OAAO,WAAW;AAAA,QAClB,WAAW,WAAW;AAAA,QACtB,QAAQ,mBAAmB,IAAI,QAAQ,CAAC,CAAC;AAAA,MAC3C,CAAC;AAAA,IACH;AAGA,QAAI,MAAM,KAAK,uBAAuB,aAAa;AACjD,cAAQ,KAAK;AAAA,QACX,QAAQ,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,WAAW,MAAM,KAAK,wBAAwB,MAAM,KAAK;AAAA,QACzD,OAAO,WAAW;AAAA,QAClB,WAAW,WAAW;AAAA,QACtB,QAAQ,qBAAqB,IAAI,QAAQ,CAAC,CAAC;AAAA,MAC7C,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,aAAa,MAAuB;AAC1C,UAAM,SAAS,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK;AACtC,UAAM,UAAoB,CAAC;AAE3B,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,cAAQ,KAAK,OAAO,CAAC,IAAK,OAAO,IAAI,CAAC,CAAE;AAAA,IAC1C;AAEA,UAAM,gBAAgB,QAAQ,MAAM,CAAC,KAAK,MAAM;AAChD,UAAM,QAAQ,cAAc,OAAO,CAAC,MAAM,IAAI,CAAC;AAC/C,UAAM,SAAS,cAAc,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,CAAC;AAExE,UAAM,UAAU,MAAM,SAAS,IAC3B,MAAM,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,KAAK,SACxC;AACJ,UAAM,UAAU,OAAO,SAAS,IAC5B,OAAO,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,IAAI,KAAK,SACzC;AAEJ,QAAI,YAAY,EAAG,QAAO;AAC1B,UAAM,KAAK,UAAU;AACrB,WAAO,MAAM,OAAO,IAAI;AAAA,EAC1B;AAAA,EAEA,QAAc;AAAA,EAEd;AACF;","names":[]}