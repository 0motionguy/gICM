{"version":3,"sources":["../src/strategies/indicators.ts","../src/analytics/risk.ts","../src/analytics/monte-carlo.ts"],"sourcesContent":["import type { OHLCV } from \"../core/types.js\";\n\nexport class Indicators {\n  // Simple Moving Average\n  static SMA(prices: number[], period: number): number[] {\n    const result: number[] = [];\n    for (let i = 0; i < prices.length; i++) {\n      if (i < period - 1) {\n        result.push(NaN);\n      } else {\n        const slice = prices.slice(i - period + 1, i + 1);\n        result.push(slice.reduce((a, b) => a + b, 0) / period);\n      }\n    }\n    return result;\n  }\n\n  // Exponential Moving Average\n  static EMA(prices: number[], period: number): number[] {\n    const result: number[] = [];\n    const multiplier = 2 / (period + 1);\n\n    for (let i = 0; i < prices.length; i++) {\n      if (i < period - 1) {\n        result.push(NaN);\n      } else if (i === period - 1) {\n        // First EMA is SMA\n        const sma = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;\n        result.push(sma);\n      } else {\n        const prevEMA = result[i - 1]!;\n        const currentPrice = prices[i]!;\n        result.push((currentPrice - prevEMA) * multiplier + prevEMA);\n      }\n    }\n    return result;\n  }\n\n  // Relative Strength Index\n  static RSI(bars: OHLCV[], period = 14): number[] {\n    const closes = bars.map((b) => b.close);\n    const result: number[] = [];\n    const gains: number[] = [];\n    const losses: number[] = [];\n\n    for (let i = 1; i < closes.length; i++) {\n      const change = closes[i]! - closes[i - 1]!;\n      gains.push(change > 0 ? change : 0);\n      losses.push(change < 0 ? Math.abs(change) : 0);\n    }\n\n    result.push(NaN); // First bar has no RSI\n\n    for (let i = 0; i < gains.length; i++) {\n      if (i < period - 1) {\n        result.push(NaN);\n      } else {\n        const recentGains = gains.slice(i - period + 1, i + 1);\n        const recentLosses = losses.slice(i - period + 1, i + 1);\n\n        const avgGain = recentGains.reduce((a, b) => a + b, 0) / period;\n        const avgLoss = recentLosses.reduce((a, b) => a + b, 0) / period;\n\n        if (avgLoss === 0) {\n          result.push(100);\n        } else {\n          const rs = avgGain / avgLoss;\n          result.push(100 - 100 / (1 + rs));\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // MACD\n  static MACD(\n    prices: number[],\n    fastPeriod = 12,\n    slowPeriod = 26,\n    signalPeriod = 9\n  ): { macd: number[]; signal: number[]; histogram: number[] } {\n    const fastEMA = this.EMA(prices, fastPeriod);\n    const slowEMA = this.EMA(prices, slowPeriod);\n\n    const macdLine: number[] = [];\n    for (let i = 0; i < prices.length; i++) {\n      if (isNaN(fastEMA[i]!) || isNaN(slowEMA[i]!)) {\n        macdLine.push(NaN);\n      } else {\n        macdLine.push(fastEMA[i]! - slowEMA[i]!);\n      }\n    }\n\n    const validMacd = macdLine.filter((v) => !isNaN(v));\n    const signalEMA = this.EMA(validMacd, signalPeriod);\n\n    // Align signal with MACD\n    const signal: number[] = [];\n    let signalIdx = 0;\n    for (let i = 0; i < macdLine.length; i++) {\n      if (isNaN(macdLine[i]!)) {\n        signal.push(NaN);\n      } else {\n        signal.push(signalEMA[signalIdx++] ?? NaN);\n      }\n    }\n\n    const histogram: number[] = [];\n    for (let i = 0; i < prices.length; i++) {\n      if (isNaN(macdLine[i]!) || isNaN(signal[i]!)) {\n        histogram.push(NaN);\n      } else {\n        histogram.push(macdLine[i]! - signal[i]!);\n      }\n    }\n\n    return { macd: macdLine, signal, histogram };\n  }\n\n  // Bollinger Bands\n  static BollingerBands(\n    prices: number[],\n    period = 20,\n    stdDev = 2\n  ): { upper: number[]; middle: number[]; lower: number[] } {\n    const middle = this.SMA(prices, period);\n    const upper: number[] = [];\n    const lower: number[] = [];\n\n    for (let i = 0; i < prices.length; i++) {\n      if (i < period - 1) {\n        upper.push(NaN);\n        lower.push(NaN);\n      } else {\n        const slice = prices.slice(i - period + 1, i + 1);\n        const mean = middle[i]!;\n        const variance =\n          slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;\n        const sd = Math.sqrt(variance);\n\n        upper.push(mean + stdDev * sd);\n        lower.push(mean - stdDev * sd);\n      }\n    }\n\n    return { upper, middle, lower };\n  }\n\n  // Average True Range\n  static ATR(bars: OHLCV[], period = 14): number[] {\n    const trueRanges: number[] = [];\n\n    for (let i = 0; i < bars.length; i++) {\n      const current = bars[i]!;\n      if (i === 0) {\n        trueRanges.push(current.high - current.low);\n      } else {\n        const prev = bars[i - 1]!;\n        const tr = Math.max(\n          current.high - current.low,\n          Math.abs(current.high - prev.close),\n          Math.abs(current.low - prev.close)\n        );\n        trueRanges.push(tr);\n      }\n    }\n\n    return this.SMA(trueRanges, period);\n  }\n\n  // Stochastic Oscillator\n  static Stochastic(\n    bars: OHLCV[],\n    kPeriod = 14,\n    dPeriod = 3\n  ): { k: number[]; d: number[] } {\n    const k: number[] = [];\n\n    for (let i = 0; i < bars.length; i++) {\n      if (i < kPeriod - 1) {\n        k.push(NaN);\n      } else {\n        const slice = bars.slice(i - kPeriod + 1, i + 1);\n        const highs = slice.map((b) => b.high);\n        const lows = slice.map((b) => b.low);\n\n        const highestHigh = Math.max(...highs);\n        const lowestLow = Math.min(...lows);\n        const currentClose = bars[i]!.close;\n\n        if (highestHigh === lowestLow) {\n          k.push(50);\n        } else {\n          k.push(((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100);\n        }\n      }\n    }\n\n    const validK = k.filter((v) => !isNaN(v));\n    const dValues = this.SMA(validK, dPeriod);\n\n    // Align D with K\n    const d: number[] = [];\n    let dIdx = 0;\n    for (let i = 0; i < k.length; i++) {\n      if (isNaN(k[i]!)) {\n        d.push(NaN);\n      } else {\n        d.push(dValues[dIdx++] ?? NaN);\n      }\n    }\n\n    return { k, d };\n  }\n\n  // Volume Weighted Average Price\n  static VWAP(bars: OHLCV[]): number[] {\n    const result: number[] = [];\n    let cumulativeTPV = 0;\n    let cumulativeVolume = 0;\n\n    for (const bar of bars) {\n      const typicalPrice = (bar.high + bar.low + bar.close) / 3;\n      cumulativeTPV += typicalPrice * bar.volume;\n      cumulativeVolume += bar.volume;\n\n      if (cumulativeVolume === 0) {\n        result.push(typicalPrice);\n      } else {\n        result.push(cumulativeTPV / cumulativeVolume);\n      }\n    }\n\n    return result;\n  }\n}\n","import type { PortfolioSnapshot, Trade } from \"../core/types.js\";\n\nexport interface VaRResult {\n  var95: number;\n  var99: number;\n  cvar95: number;\n  cvar99: number;\n}\n\nexport interface DrawdownAnalysis {\n  currentDrawdown: number;\n  maxDrawdown: number;\n  avgDrawdown: number;\n  drawdownPeriods: Array<{\n    start: Date;\n    end: Date;\n    depth: number;\n    duration: number;\n    recovery: number;\n  }>;\n}\n\nexport class RiskAnalyzer {\n  // Value at Risk calculation (Historical method)\n  calculateVaR(returns: number[]): VaRResult {\n    if (returns.length === 0) {\n      return { var95: 0, var99: 0, cvar95: 0, cvar99: 0 };\n    }\n\n    const sorted = [...returns].sort((a, b) => a - b);\n    const n = sorted.length;\n\n    // VaR at 95% and 99% confidence\n    const idx95 = Math.floor(n * 0.05);\n    const idx99 = Math.floor(n * 0.01);\n\n    const var95 = -sorted[idx95]!;\n    const var99 = -sorted[idx99]!;\n\n    // Conditional VaR (Expected Shortfall)\n    const cvar95 = -sorted.slice(0, idx95 + 1).reduce((a, b) => a + b, 0) / (idx95 + 1);\n    const cvar99 = -sorted.slice(0, idx99 + 1).reduce((a, b) => a + b, 0) / (idx99 + 1);\n\n    return { var95, var99, cvar95, cvar99 };\n  }\n\n  // Parametric VaR (assumes normal distribution)\n  calculateParametricVaR(\n    mean: number,\n    stdDev: number,\n    confidence: number\n  ): number {\n    // Z-scores for common confidence levels\n    const zScores: Record<number, number> = {\n      0.9: 1.28,\n      0.95: 1.645,\n      0.99: 2.33,\n    };\n\n    const z = zScores[confidence] ?? 1.645;\n    return mean - z * stdDev;\n  }\n\n  // Analyze drawdown periods\n  analyzeDrawdowns(snapshots: PortfolioSnapshot[]): DrawdownAnalysis {\n    if (snapshots.length === 0) {\n      return {\n        currentDrawdown: 0,\n        maxDrawdown: 0,\n        avgDrawdown: 0,\n        drawdownPeriods: [],\n      };\n    }\n\n    const periods: DrawdownAnalysis[\"drawdownPeriods\"] = [];\n    let peak = snapshots[0]!.equity;\n    let drawdownStart: PortfolioSnapshot | null = null;\n    let maxDrawdown = 0;\n    let totalDrawdown = 0;\n    let drawdownCount = 0;\n\n    for (const snapshot of snapshots) {\n      if (snapshot.equity > peak) {\n        // New peak - close any open drawdown period\n        if (drawdownStart && snapshot.drawdownPercent > 0) {\n          const prevSnapshot = snapshots[snapshots.indexOf(snapshot) - 1];\n          if (prevSnapshot) {\n            periods.push({\n              start: drawdownStart.timestamp,\n              end: prevSnapshot.timestamp,\n              depth: prevSnapshot.drawdownPercent,\n              duration:\n                (prevSnapshot.timestamp.getTime() - drawdownStart.timestamp.getTime()) /\n                (24 * 60 * 60 * 1000),\n              recovery:\n                (snapshot.timestamp.getTime() - prevSnapshot.timestamp.getTime()) /\n                (24 * 60 * 60 * 1000),\n            });\n          }\n        }\n        peak = snapshot.equity;\n        drawdownStart = null;\n      } else if (snapshot.drawdownPercent > 0 && !drawdownStart) {\n        // Start of new drawdown\n        drawdownStart = snapshot;\n      }\n\n      if (snapshot.drawdownPercent > maxDrawdown) {\n        maxDrawdown = snapshot.drawdownPercent;\n      }\n\n      if (snapshot.drawdownPercent > 0) {\n        totalDrawdown += snapshot.drawdownPercent;\n        drawdownCount++;\n      }\n    }\n\n    const currentDrawdown = snapshots[snapshots.length - 1]?.drawdownPercent ?? 0;\n    const avgDrawdown = drawdownCount > 0 ? totalDrawdown / drawdownCount : 0;\n\n    return {\n      currentDrawdown,\n      maxDrawdown,\n      avgDrawdown,\n      drawdownPeriods: periods,\n    };\n  }\n\n  // Calculate position concentration risk\n  calculateConcentrationRisk(snapshots: PortfolioSnapshot[]): {\n    avgConcentration: number;\n    maxConcentration: number;\n    herfindahlIndex: number;\n  } {\n    if (snapshots.length === 0) {\n      return { avgConcentration: 0, maxConcentration: 0, herfindahlIndex: 0 };\n    }\n\n    const concentrations: number[] = [];\n    const herfindahlIndices: number[] = [];\n\n    for (const snapshot of snapshots) {\n      if (snapshot.positions.length === 0) {\n        concentrations.push(0);\n        herfindahlIndices.push(0);\n        continue;\n      }\n\n      const totalValue = snapshot.positions.reduce(\n        (sum, p) => sum + p.quantity * p.currentPrice,\n        0\n      );\n\n      if (totalValue === 0) {\n        concentrations.push(0);\n        herfindahlIndices.push(0);\n        continue;\n      }\n\n      const weights = snapshot.positions.map(\n        (p) => (p.quantity * p.currentPrice) / totalValue\n      );\n\n      concentrations.push(Math.max(...weights));\n      herfindahlIndices.push(weights.reduce((sum, w) => sum + w * w, 0));\n    }\n\n    return {\n      avgConcentration:\n        concentrations.reduce((a, b) => a + b, 0) / concentrations.length,\n      maxConcentration: Math.max(...concentrations),\n      herfindahlIndex:\n        herfindahlIndices.reduce((a, b) => a + b, 0) / herfindahlIndices.length,\n    };\n  }\n\n  // Calculate tail risk metrics\n  calculateTailRisk(returns: number[]): {\n    skewness: number;\n    kurtosis: number;\n    tailRatio: number;\n  } {\n    if (returns.length < 4) {\n      return { skewness: 0, kurtosis: 0, tailRatio: 1 };\n    }\n\n    const n = returns.length;\n    const mean = returns.reduce((a, b) => a + b, 0) / n;\n\n    // Standard deviation\n    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n\n    if (stdDev === 0) {\n      return { skewness: 0, kurtosis: 0, tailRatio: 1 };\n    }\n\n    // Skewness\n    const skewness =\n      returns.reduce((sum, r) => sum + Math.pow((r - mean) / stdDev, 3), 0) / n;\n\n    // Kurtosis (excess)\n    const kurtosis =\n      returns.reduce((sum, r) => sum + Math.pow((r - mean) / stdDev, 4), 0) / n - 3;\n\n    // Tail ratio (5th percentile / 95th percentile absolute values)\n    const sorted = [...returns].sort((a, b) => a - b);\n    const p5 = Math.abs(sorted[Math.floor(n * 0.05)]!);\n    const p95 = Math.abs(sorted[Math.floor(n * 0.95)]!);\n    const tailRatio = p95 > 0 ? p5 / p95 : 1;\n\n    return { skewness, kurtosis, tailRatio };\n  }\n\n  // Calculate trade risk metrics\n  calculateTradeRisk(trades: Trade[]): {\n    avgRiskRewardRatio: number;\n    largestWin: number;\n    largestLoss: number;\n    avgWinLossRatio: number;\n  } {\n    const closedTrades = trades.filter((t) => t.status === \"closed\" && t.pnl !== undefined);\n\n    if (closedTrades.length === 0) {\n      return {\n        avgRiskRewardRatio: 0,\n        largestWin: 0,\n        largestLoss: 0,\n        avgWinLossRatio: 0,\n      };\n    }\n\n    const pnls = closedTrades.map((t) => t.pnl!);\n    const wins = pnls.filter((p) => p > 0);\n    const losses = pnls.filter((p) => p < 0);\n\n    const largestWin = wins.length > 0 ? Math.max(...wins) : 0;\n    const largestLoss = losses.length > 0 ? Math.min(...losses) : 0;\n\n    const avgWin = wins.length > 0 ? wins.reduce((a, b) => a + b, 0) / wins.length : 0;\n    const avgLoss =\n      losses.length > 0\n        ? Math.abs(losses.reduce((a, b) => a + b, 0)) / losses.length\n        : 0;\n\n    const avgWinLossRatio = avgLoss > 0 ? avgWin / avgLoss : Infinity;\n\n    // Average risk/reward ratio based on actual trades\n    const avgRiskRewardRatio = avgWinLossRatio;\n\n    return {\n      avgRiskRewardRatio,\n      largestWin,\n      largestLoss,\n      avgWinLossRatio,\n    };\n  }\n}\n","import type { Trade, PerformanceMetrics } from \"../core/types.js\";\n\nexport interface MonteCarloResult {\n  simulations: number;\n  percentiles: {\n    p5: SimulationOutcome;\n    p25: SimulationOutcome;\n    p50: SimulationOutcome;\n    p75: SimulationOutcome;\n    p95: SimulationOutcome;\n  };\n  probability: {\n    profit: number;\n    loss: number;\n    doubling: number;\n    ruin: number;\n  };\n  distribution: SimulationOutcome[];\n}\n\nexport interface SimulationOutcome {\n  finalEquity: number;\n  totalReturn: number;\n  maxDrawdown: number;\n  sharpeRatio: number;\n}\n\nexport class MonteCarloSimulator {\n  private initialCapital: number;\n  private riskFreeRate: number;\n\n  constructor(config: { initialCapital: number; riskFreeRate?: number }) {\n    this.initialCapital = config.initialCapital;\n    this.riskFreeRate = config.riskFreeRate ?? 0.05;\n  }\n\n  // Run Monte Carlo simulation using trade resampling\n  runTradeResampling(\n    trades: Trade[],\n    simulations: number,\n    tradesPerSimulation: number\n  ): MonteCarloResult {\n    const closedTrades = trades.filter((t) => t.status === \"closed\" && t.pnl !== undefined);\n\n    if (closedTrades.length === 0) {\n      return this.emptyResult();\n    }\n\n    const outcomes: SimulationOutcome[] = [];\n\n    for (let i = 0; i < simulations; i++) {\n      const outcome = this.runSingleSimulation(closedTrades, tradesPerSimulation);\n      outcomes.push(outcome);\n    }\n\n    // Sort by final equity\n    outcomes.sort((a, b) => a.finalEquity - b.finalEquity);\n\n    return {\n      simulations,\n      percentiles: {\n        p5: outcomes[Math.floor(simulations * 0.05)]!,\n        p25: outcomes[Math.floor(simulations * 0.25)]!,\n        p50: outcomes[Math.floor(simulations * 0.5)]!,\n        p75: outcomes[Math.floor(simulations * 0.75)]!,\n        p95: outcomes[Math.floor(simulations * 0.95)]!,\n      },\n      probability: this.calculateProbabilities(outcomes),\n      distribution: outcomes,\n    };\n  }\n\n  private runSingleSimulation(\n    trades: Trade[],\n    numTrades: number\n  ): SimulationOutcome {\n    let equity = this.initialCapital;\n    let peak = equity;\n    let maxDrawdown = 0;\n    const equityCurve: number[] = [equity];\n\n    // Randomly sample trades with replacement\n    for (let i = 0; i < numTrades; i++) {\n      const randomIndex = Math.floor(Math.random() * trades.length);\n      const trade = trades[randomIndex]!;\n\n      // Scale PnL relative to initial position\n      const pnlPercent = trade.pnlPercent ?? 0;\n      const pnl = equity * (pnlPercent / 100);\n\n      equity += pnl;\n      equityCurve.push(equity);\n\n      if (equity > peak) {\n        peak = equity;\n      }\n\n      const drawdown = (peak - equity) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n\n      // Stop if ruined\n      if (equity <= 0) {\n        equity = 0;\n        break;\n      }\n    }\n\n    const returns = this.calculateReturns(equityCurve);\n    const sharpeRatio = this.calculateSharpe(returns);\n\n    return {\n      finalEquity: equity,\n      totalReturn: (equity - this.initialCapital) / this.initialCapital,\n      maxDrawdown,\n      sharpeRatio,\n    };\n  }\n\n  private calculateReturns(equityCurve: number[]): number[] {\n    const returns: number[] = [];\n    for (let i = 1; i < equityCurve.length; i++) {\n      const prev = equityCurve[i - 1]!;\n      if (prev > 0) {\n        returns.push((equityCurve[i]! - prev) / prev);\n      }\n    }\n    return returns;\n  }\n\n  private calculateSharpe(returns: number[]): number {\n    if (returns.length < 2) return 0;\n\n    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance =\n      returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;\n    const stdDev = Math.sqrt(variance);\n\n    if (stdDev === 0) return 0;\n\n    // Annualize assuming daily returns\n    const annualizedReturn = mean * 252;\n    const annualizedStdDev = stdDev * Math.sqrt(252);\n\n    return (annualizedReturn - this.riskFreeRate) / annualizedStdDev;\n  }\n\n  private calculateProbabilities(outcomes: SimulationOutcome[]): {\n    profit: number;\n    loss: number;\n    doubling: number;\n    ruin: number;\n  } {\n    const n = outcomes.length;\n    const profitCount = outcomes.filter((o) => o.totalReturn > 0).length;\n    const doublingCount = outcomes.filter((o) => o.finalEquity >= this.initialCapital * 2).length;\n    const ruinCount = outcomes.filter((o) => o.finalEquity <= this.initialCapital * 0.1).length;\n\n    return {\n      profit: profitCount / n,\n      loss: (n - profitCount) / n,\n      doubling: doublingCount / n,\n      ruin: ruinCount / n,\n    };\n  }\n\n  // Run Monte Carlo using return distribution\n  runReturnSimulation(\n    returns: number[],\n    simulations: number,\n    periodsPerSimulation: number\n  ): MonteCarloResult {\n    if (returns.length === 0) {\n      return this.emptyResult();\n    }\n\n    const outcomes: SimulationOutcome[] = [];\n\n    for (let i = 0; i < simulations; i++) {\n      let equity = this.initialCapital;\n      let peak = equity;\n      let maxDrawdown = 0;\n      const equityCurve: number[] = [equity];\n\n      for (let j = 0; j < periodsPerSimulation; j++) {\n        const randomReturn = returns[Math.floor(Math.random() * returns.length)]!;\n        equity *= 1 + randomReturn;\n        equityCurve.push(equity);\n\n        if (equity > peak) {\n          peak = equity;\n        }\n\n        const drawdown = (peak - equity) / peak;\n        if (drawdown > maxDrawdown) {\n          maxDrawdown = drawdown;\n        }\n      }\n\n      const simReturns = this.calculateReturns(equityCurve);\n      const sharpeRatio = this.calculateSharpe(simReturns);\n\n      outcomes.push({\n        finalEquity: equity,\n        totalReturn: (equity - this.initialCapital) / this.initialCapital,\n        maxDrawdown,\n        sharpeRatio,\n      });\n    }\n\n    outcomes.sort((a, b) => a.finalEquity - b.finalEquity);\n\n    return {\n      simulations,\n      percentiles: {\n        p5: outcomes[Math.floor(simulations * 0.05)]!,\n        p25: outcomes[Math.floor(simulations * 0.25)]!,\n        p50: outcomes[Math.floor(simulations * 0.5)]!,\n        p75: outcomes[Math.floor(simulations * 0.75)]!,\n        p95: outcomes[Math.floor(simulations * 0.95)]!,\n      },\n      probability: this.calculateProbabilities(outcomes),\n      distribution: outcomes,\n    };\n  }\n\n  private emptyResult(): MonteCarloResult {\n    const emptyOutcome: SimulationOutcome = {\n      finalEquity: this.initialCapital,\n      totalReturn: 0,\n      maxDrawdown: 0,\n      sharpeRatio: 0,\n    };\n\n    return {\n      simulations: 0,\n      percentiles: {\n        p5: emptyOutcome,\n        p25: emptyOutcome,\n        p50: emptyOutcome,\n        p75: emptyOutcome,\n        p95: emptyOutcome,\n      },\n      probability: {\n        profit: 0,\n        loss: 0,\n        doubling: 0,\n        ruin: 0,\n      },\n      distribution: [],\n    };\n  }\n}\n"],"mappings":"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","names":[]}