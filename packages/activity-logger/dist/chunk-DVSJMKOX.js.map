{"version":3,"sources":["../src/solana/memo-logger.ts"],"sourcesContent":["import {\n  Connection,\n  Keypair,\n  Transaction,\n  sendAndConfirmTransaction,\n  PublicKey,\n  type Commitment,\n  type Finality,\n} from \"@solana/web3.js\";\nimport { createHash } from \"crypto\";\nimport type { Activity, ActivityType, SolanaMemo } from \"../types.js\";\n\n// SPL Memo Program ID\nconst MEMO_PROGRAM_ID = new PublicKey(\n  \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\"\n);\n\nexport interface SolanaLoggerConfig {\n  rpcUrl: string;\n  privateKey: string;\n  commitment?: Commitment;\n}\n\nexport interface SolanaLogResult {\n  signature: string;\n  slot: number;\n  fee: number;\n  memo: SolanaMemo;\n}\n\nexport class SolanaMemoLogger {\n  private connection: Connection;\n  private payer: Keypair;\n  private commitment: Commitment;\n\n  constructor(config: SolanaLoggerConfig) {\n    this.connection = new Connection(config.rpcUrl, config.commitment ?? \"confirmed\");\n    this.payer = this.parsePrivateKey(config.privateKey);\n    this.commitment = config.commitment ?? \"confirmed\";\n  }\n\n  private parsePrivateKey(privateKey: string): Keypair {\n    // Handle both base58 and JSON array formats\n    try {\n      // Try JSON array format first\n      const parsed = JSON.parse(privateKey);\n      if (Array.isArray(parsed)) {\n        return Keypair.fromSecretKey(Uint8Array.from(parsed));\n      }\n    } catch {\n      // Not JSON, try base58\n    }\n\n    // Try base58 format\n    const bs58 = this.base58Decode(privateKey);\n    return Keypair.fromSecretKey(bs58);\n  }\n\n  private base58Decode(str: string): Uint8Array {\n    const ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    const bytes: number[] = [];\n    for (const char of str) {\n      let carry = ALPHABET.indexOf(char);\n      if (carry === -1) throw new Error(\"Invalid base58 character\");\n      for (let j = 0; j < bytes.length; j++) {\n        carry += bytes[j] * 58;\n        bytes[j] = carry & 0xff;\n        carry >>= 8;\n      }\n      while (carry > 0) {\n        bytes.push(carry & 0xff);\n        carry >>= 8;\n      }\n    }\n    // Add leading zeros\n    for (const char of str) {\n      if (char !== \"1\") break;\n      bytes.push(0);\n    }\n    return Uint8Array.from(bytes.reverse());\n  }\n\n  async logActivity(\n    activity: Activity,\n    arweaveTxId?: string\n  ): Promise<SolanaLogResult> {\n    const contentHash = this.computeHash(activity);\n\n    const memo: SolanaMemo = {\n      v: 1,\n      t: \"gicm:activity\",\n      id: activity.id,\n      type: activity.type,\n      ts: Math.floor(Date.now() / 1000),\n      h: contentHash.slice(0, 16), // Truncate for space\n      ...(arweaveTxId && { ar: arweaveTxId }),\n    };\n\n    const memoString = JSON.stringify(memo);\n\n    // Create memo instruction manually (simpler than importing spl-memo)\n    const instruction = {\n      keys: [{ pubkey: this.payer.publicKey, isSigner: true, isWritable: false }],\n      programId: MEMO_PROGRAM_ID,\n      data: Buffer.from(memoString, \"utf-8\"),\n    };\n\n    const transaction = new Transaction().add(instruction);\n\n    const signature = await sendAndConfirmTransaction(\n      this.connection,\n      transaction,\n      [this.payer],\n      { commitment: this.commitment }\n    );\n\n    // getTransaction only accepts Finality (\"confirmed\" | \"finalized\"), not full Commitment\n    const finality: Finality = this.commitment === \"processed\" ? \"confirmed\" : this.commitment as Finality;\n    const txInfo = await this.connection.getTransaction(signature, {\n      commitment: finality,\n    });\n\n    return {\n      signature,\n      slot: txInfo?.slot ?? 0,\n      fee: txInfo?.meta?.fee ?? 5000,\n      memo,\n    };\n  }\n\n  async logActivityBatch(\n    activities: Activity[]\n  ): Promise<{ signature: string; slot: number; merkleRoot: string }> {\n    const hashes = activities.map((a) => this.computeHash(a));\n    const merkleRoot = this.computeMerkleRoot(hashes);\n\n    const batchMemo = {\n      v: 1,\n      t: \"gicm:batch\",\n      ts: Math.floor(Date.now() / 1000),\n      count: activities.length,\n      root: merkleRoot.slice(0, 32),\n      ids: activities.map((a) => a.id.slice(0, 8)),\n    };\n\n    const memoString = JSON.stringify(batchMemo);\n\n    const instruction = {\n      keys: [{ pubkey: this.payer.publicKey, isSigner: true, isWritable: false }],\n      programId: MEMO_PROGRAM_ID,\n      data: Buffer.from(memoString, \"utf-8\"),\n    };\n\n    const transaction = new Transaction().add(instruction);\n\n    const signature = await sendAndConfirmTransaction(\n      this.connection,\n      transaction,\n      [this.payer],\n      { commitment: this.commitment }\n    );\n\n    // getTransaction only accepts Finality (\"confirmed\" | \"finalized\"), not full Commitment\n    const finality: Finality = this.commitment === \"processed\" ? \"confirmed\" : this.commitment as Finality;\n    const txInfo = await this.connection.getTransaction(signature, {\n      commitment: finality,\n    });\n\n    return {\n      signature,\n      slot: txInfo?.slot ?? 0,\n      merkleRoot,\n    };\n  }\n\n  async verifyActivity(\n    signature: string,\n    expectedHash: string\n  ): Promise<{ verified: boolean; memo?: SolanaMemo }> {\n    try {\n      const tx = await this.connection.getTransaction(signature, {\n        commitment: \"finalized\",\n      });\n\n      if (!tx) {\n        return { verified: false };\n      }\n\n      // Parse memo from transaction logs\n      const memoLog = tx.meta?.logMessages?.find((log) =>\n        log.includes(\"gicm:activity\")\n      );\n\n      if (!memoLog) {\n        return { verified: false };\n      }\n\n      // Extract JSON from log\n      const jsonMatch = memoLog.match(/\\{.*\\}/);\n      if (!jsonMatch) {\n        return { verified: false };\n      }\n\n      const memo = JSON.parse(jsonMatch[0]) as SolanaMemo;\n      const verified = memo.h === expectedHash.slice(0, 16);\n\n      return { verified, memo };\n    } catch {\n      return { verified: false };\n    }\n  }\n\n  async getBalance(): Promise<number> {\n    return this.connection.getBalance(this.payer.publicKey);\n  }\n\n  getPublicKey(): string {\n    return this.payer.publicKey.toBase58();\n  }\n\n  private computeHash(data: unknown): string {\n    return createHash(\"sha256\").update(JSON.stringify(data)).digest(\"hex\");\n  }\n\n  private computeMerkleRoot(hashes: string[]): string {\n    if (hashes.length === 0) return \"\";\n    if (hashes.length === 1) return hashes[0];\n\n    const pairs: string[] = [];\n    for (let i = 0; i < hashes.length; i += 2) {\n      const left = hashes[i];\n      const right = hashes[i + 1] || left;\n      pairs.push(\n        createHash(\"sha256\")\n          .update(left + right)\n          .digest(\"hex\")\n      );\n    }\n\n    return this.computeMerkleRoot(pairs);\n  }\n}\n\n// Utility function to create a memo for signing externally\nexport function createMemoPayload(\n  activityId: string,\n  activityType: ActivityType,\n  contentHash: string,\n  arweaveTxId?: string\n): string {\n  const memo: SolanaMemo = {\n    v: 1,\n    t: \"gicm:activity\",\n    id: activityId,\n    type: activityType,\n    ts: Math.floor(Date.now() / 1000),\n    h: contentHash.slice(0, 16),\n    ...(arweaveTxId && { ar: arweaveTxId }),\n  };\n\n  return JSON.stringify(memo);\n}\n"],"mappings":"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","names":[]}