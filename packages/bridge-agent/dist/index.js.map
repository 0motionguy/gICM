{"version":3,"sources":["../src/bridge-agent.ts","../src/types.ts","../src/bridges/wormhole.ts","../src/bridges/layerzero.ts","../src/bridges/debridge.ts","../src/router/pathfinder.ts","../src/router/estimator.ts"],"sourcesContent":["import { z } from \"zod\";\nimport {\n  BaseAgent,\n  type AgentConfig,\n  type AgentContext,\n  type AgentResult,\n  type LLMClient,\n  createLLMClient,\n} from \"@gicm/agent-core\";\nimport type {\n  BridgeAgentConfig,\n  BridgeQuote,\n  BridgeRoute,\n  BridgeTransaction,\n  Chain,\n  QuoteParams,\n} from \"./types.js\";\nimport { BridgeAgentConfigSchema } from \"./types.js\";\nimport { WormholeProvider } from \"./bridges/wormhole.js\";\nimport { LayerZeroProvider } from \"./bridges/layerzero.js\";\nimport { DeBridgeProvider } from \"./bridges/debridge.js\";\nimport { Pathfinder } from \"./router/pathfinder.js\";\nimport { Estimator, type FeeEstimate, type TimeEstimate } from \"./router/estimator.js\";\n\nexport interface BridgeAgentAnalysis {\n  route?: BridgeRoute;\n  transaction?: BridgeTransaction;\n  fees?: FeeEstimate;\n  timeEstimate?: TimeEstimate;\n  aiSummary?: string;\n}\n\nexport class BridgeAgent extends BaseAgent {\n  private pathfinder: Pathfinder;\n  private estimator: Estimator;\n  private bridgeConfig: BridgeAgentConfig;\n  private llmClient?: LLMClient;\n\n  constructor(config: BridgeAgentConfig & AgentConfig) {\n    const validatedConfig = BridgeAgentConfigSchema.parse(config);\n    super(\"bridge-agent\", config);\n\n    this.bridgeConfig = validatedConfig;\n    this.estimator = new Estimator();\n\n    // Initialize LLM client if API key provided\n    if (config.apiKey) {\n      this.llmClient = createLLMClient({\n        provider: config.llmProvider ?? \"openai\",\n        model: config.llmModel,\n        apiKey: config.apiKey,\n        temperature: config.temperature ?? 0.7,\n        maxTokens: config.maxTokens ?? 4096,\n      });\n    }\n\n    // Initialize providers\n    const providers = [\n      new WormholeProvider(validatedConfig.wormholeRpc),\n      new LayerZeroProvider(validatedConfig.layerZeroEndpoint),\n      new DeBridgeProvider({ apiKey: validatedConfig.debridgeApiKey }),\n    ];\n\n    this.pathfinder = new Pathfinder(providers);\n    this.initializeTools();\n  }\n\n  private initializeTools(): void {\n    this.registerTool({\n      name: \"get_bridge_quote\",\n      description: \"Get quote for bridging tokens between chains\",\n      parameters: z.object({\n        sourceChain: z.string().describe(\"Source chain (ethereum, arbitrum, etc)\"),\n        destChain: z.string().describe(\"Destination chain\"),\n        sourceToken: z.string().describe(\"Source token address\"),\n        destToken: z.string().describe(\"Destination token address\"),\n        amount: z.string().describe(\"Amount to bridge\"),\n        slippage: z.number().default(0.5).describe(\"Max slippage percentage\"),\n      }),\n      execute: async (params) => {\n        const { sourceChain, destChain, sourceToken, destToken, amount, slippage } = params as {\n          sourceChain: string;\n          destChain: string;\n          sourceToken: string;\n          destToken: string;\n          amount: string;\n          slippage: number;\n        };\n        return this.getQuote({\n          sourceChain: sourceChain as Chain,\n          destChain: destChain as Chain,\n          sourceToken,\n          destToken,\n          amount,\n          slippage,\n        });\n      },\n    });\n\n    this.registerTool({\n      name: \"find_best_route\",\n      description: \"Find best bridge route comparing all providers\",\n      parameters: z.object({\n        sourceChain: z.string().describe(\"Source chain\"),\n        destChain: z.string().describe(\"Destination chain\"),\n        sourceToken: z.string().describe(\"Source token address\"),\n        destToken: z.string().describe(\"Destination token address\"),\n        amount: z.string().describe(\"Amount to bridge\"),\n      }),\n      execute: async (params) => {\n        const { sourceChain, destChain, sourceToken, destToken, amount } = params as {\n          sourceChain: string;\n          destChain: string;\n          sourceToken: string;\n          destToken: string;\n          amount: string;\n        };\n        return this.findBestRoute({\n          sourceChain: sourceChain as Chain,\n          destChain: destChain as Chain,\n          sourceToken,\n          destToken,\n          amount,\n        });\n      },\n    });\n\n    this.registerTool({\n      name: \"estimate_fees\",\n      description: \"Estimate total fees for a bridge quote\",\n      parameters: z.object({\n        bridgeId: z.string().describe(\"Bridge ID from quote\"),\n        sourceChain: z.string().describe(\"Source chain\"),\n        destChain: z.string().describe(\"Destination chain\"),\n        amount: z.string().describe(\"Amount\"),\n      }),\n      execute: async (params) => {\n        const { bridgeId, sourceChain, destChain, amount } = params as {\n          bridgeId: string;\n          sourceChain: string;\n          destChain: string;\n          amount: string;\n        };\n        const quote: BridgeQuote = {\n          bridgeId,\n          bridgeName: bridgeId,\n          sourceChain: sourceChain as Chain,\n          destChain: destChain as Chain,\n          sourceToken: \"\",\n          destToken: \"\",\n          inputAmount: amount,\n          outputAmount: amount,\n          fee: \"0\",\n          feeUsd: 0,\n          estimatedTime: 0,\n          priceImpact: 0,\n          slippage: 0.5,\n        };\n        return this.estimator.estimateFees(quote);\n      },\n    });\n\n    this.registerTool({\n      name: \"track_transaction\",\n      description: \"Track bridge transaction status\",\n      parameters: z.object({\n        bridgeId: z.string().describe(\"Bridge provider ID\"),\n        txId: z.string().describe(\"Transaction or order ID\"),\n      }),\n      execute: async (params) => {\n        const { bridgeId, txId } = params as { bridgeId: string; txId: string };\n        return this.trackTransaction(bridgeId, txId);\n      },\n    });\n\n    this.registerTool({\n      name: \"compare_bridges\",\n      description: \"Compare all bridge options for a route\",\n      parameters: z.object({\n        sourceChain: z.string().describe(\"Source chain\"),\n        destChain: z.string().describe(\"Destination chain\"),\n        sourceToken: z.string().describe(\"Source token\"),\n        destToken: z.string().describe(\"Destination token\"),\n        amount: z.string().describe(\"Amount\"),\n      }),\n      execute: async (params) => {\n        const { sourceChain, destChain, sourceToken, destToken, amount } = params as {\n          sourceChain: string;\n          destChain: string;\n          sourceToken: string;\n          destToken: string;\n          amount: string;\n        };\n        return this.compareBridges({\n          sourceChain: sourceChain as Chain,\n          destChain: destChain as Chain,\n          sourceToken,\n          destToken,\n          amount,\n        });\n      },\n    });\n  }\n\n  getSystemPrompt(): string {\n    return `You are a cross-chain bridge expert. You can:\n- Find optimal bridge routes between chains\n- Compare fees and speeds across bridge providers\n- Track bridge transaction status\n- Estimate gas fees and total costs\n- Recommend the best bridge for specific needs\n\nSupported bridges: Wormhole, LayerZero, deBridge\nSupported chains: Ethereum, BSC, Polygon, Arbitrum, Optimism, Base, Avalanche, Solana\n\nWhen recommending bridges, consider:\n1. Total fees (bridge fee + gas on both chains)\n2. Transaction speed\n3. Security and reliability\n4. Token support\n5. Slippage and price impact`;\n  }\n\n  async analyze(context: AgentContext): Promise<AgentResult> {\n    const query = context.userQuery ?? \"\";\n\n    if (!this.llmClient) {\n      return this.createResult(\n        false,\n        null,\n        \"LLM client not configured. Provide apiKey in config.\",\n        0,\n        \"No LLM available for AI analysis\"\n      );\n    }\n\n    try {\n      const response = await this.llmClient.chat([\n        { role: \"system\", content: this.getSystemPrompt() },\n        { role: \"user\", content: query },\n      ]);\n\n      return this.createResult(\n        true,\n        { aiSummary: response.content },\n        undefined,\n        0.8,\n        \"AI analysis completed\"\n      );\n    } catch (error) {\n      return this.createResult(\n        false,\n        null,\n        error instanceof Error ? error.message : \"Unknown error\",\n        0,\n        \"Failed to complete AI analysis\"\n      );\n    }\n  }\n\n  async getQuote(params: QuoteParams): Promise<BridgeQuote[]> {\n    return this.pathfinder.getAllQuotes(params);\n  }\n\n  async findBestRoute(params: QuoteParams): Promise<BridgeRoute | null> {\n    return this.pathfinder.findBestRoute(params);\n  }\n\n  async compareBridges(params: QuoteParams): Promise<{\n    ranked: Array<{\n      quote: BridgeQuote;\n      score: number;\n      fees: FeeEstimate;\n      time: TimeEstimate;\n    }>;\n  }> {\n    const quotes = await this.pathfinder.getAllQuotes(params);\n    return this.estimator.compareQuotes(quotes);\n  }\n\n  async trackTransaction(\n    bridgeId: string,\n    txId: string\n  ): Promise<BridgeTransaction | null> {\n    // Route to appropriate provider\n    const providers: Record<string, () => Promise<BridgeTransaction | null>> = {\n      wormhole: () => new WormholeProvider().getTransaction(txId),\n      layerzero: () => Promise.resolve(null), // Would need LayerZero scan\n      debridge: () => new DeBridgeProvider().getTransaction(txId),\n    };\n\n    const getTransaction = providers[bridgeId];\n    if (!getTransaction) return null;\n\n    return getTransaction();\n  }\n\n  estimateFees(quote: BridgeQuote): FeeEstimate {\n    return this.estimator.estimateFees(quote);\n  }\n\n  estimateTime(bridgeId: string): TimeEstimate {\n    return this.estimator.estimateTime(bridgeId);\n  }\n\n  getSupportedChains(): Chain[] {\n    return [\n      \"ethereum\",\n      \"bsc\",\n      \"polygon\",\n      \"arbitrum\",\n      \"optimism\",\n      \"base\",\n      \"avalanche\",\n      \"solana\",\n    ];\n  }\n}\n","import { z } from \"zod\";\n\nexport const BridgeAgentConfigSchema = z.object({\n  wormholeRpc: z.string().default(\"https://wormhole-v2-mainnet-api.certus.one\"),\n  layerZeroEndpoint: z.string().optional(),\n  debridgeApiKey: z.string().optional(),\n});\n\nexport type BridgeAgentConfig = z.infer<typeof BridgeAgentConfigSchema>;\n\nexport type Chain =\n  | \"ethereum\"\n  | \"bsc\"\n  | \"polygon\"\n  | \"arbitrum\"\n  | \"optimism\"\n  | \"base\"\n  | \"avalanche\"\n  | \"solana\"\n  | \"sui\"\n  | \"aptos\";\n\nexport interface BridgeQuote {\n  bridgeId: string;\n  bridgeName: string;\n  sourceChain: Chain;\n  destChain: Chain;\n  sourceToken: string;\n  destToken: string;\n  inputAmount: string;\n  outputAmount: string;\n  fee: string;\n  feeUsd: number;\n  estimatedTime: number; // seconds\n  priceImpact: number;\n  slippage: number;\n}\n\nexport interface BridgeRoute {\n  quotes: BridgeQuote[];\n  bestQuote: BridgeQuote;\n  comparison: {\n    cheapest: BridgeQuote;\n    fastest: BridgeQuote;\n    bestValue: BridgeQuote;\n  };\n}\n\nexport interface BridgeTransaction {\n  id: string;\n  bridgeId: string;\n  bridgeName: string;\n  sourceChain: Chain;\n  destChain: Chain;\n  sourceToken: string;\n  destToken: string;\n  inputAmount: string;\n  outputAmount?: string;\n  status: \"pending\" | \"processing\" | \"completed\" | \"failed\";\n  sourceTxHash: string;\n  destTxHash?: string;\n  createdAt: Date;\n  completedAt?: Date;\n  error?: string;\n}\n\nexport interface SupportedToken {\n  symbol: string;\n  address: string;\n  chain: Chain;\n  decimals: number;\n  name: string;\n  logoUri?: string;\n}\n\nexport interface BridgeProvider {\n  name: string;\n  id: string;\n  supportedChains: Chain[];\n\n  getQuote(params: QuoteParams): Promise<BridgeQuote | null>;\n  getTransaction(txId: string): Promise<BridgeTransaction | null>;\n  getSupportedTokens(chain: Chain): Promise<SupportedToken[]>;\n}\n\nexport interface QuoteParams {\n  sourceChain: Chain;\n  destChain: Chain;\n  sourceToken: string;\n  destToken: string;\n  amount: string;\n  slippage?: number;\n}\n","import type {\n  BridgeProvider,\n  BridgeQuote,\n  BridgeTransaction,\n  SupportedToken,\n  Chain,\n  QuoteParams,\n} from \"../types.js\";\n\ninterface WormholeChainConfig {\n  chainId: number;\n  name: string;\n}\n\ninterface WormholeTokenResponse {\n  symbol: string;\n  address: string;\n  decimals: number;\n  name: string;\n  logoURI?: string;\n}\n\ninterface WormholeQuoteResponse {\n  srcChainId: number;\n  dstChainId: number;\n  srcToken: string;\n  dstToken: string;\n  srcAmount: string;\n  dstAmount: string;\n  fee: string;\n  feeUsd: number;\n  estimatedTime: number;\n}\n\ninterface WormholeTxResponse {\n  id: string;\n  status: string;\n  srcChainId: number;\n  dstChainId: number;\n  srcTx: string;\n  dstTx?: string;\n  timestamp: number;\n  completedAt?: number;\n}\n\n// Wormhole chain IDs\nconst WORMHOLE_CHAINS: Record<Chain, WormholeChainConfig> = {\n  ethereum: { chainId: 2, name: \"Ethereum\" },\n  bsc: { chainId: 4, name: \"BSC\" },\n  polygon: { chainId: 5, name: \"Polygon\" },\n  arbitrum: { chainId: 23, name: \"Arbitrum\" },\n  optimism: { chainId: 24, name: \"Optimism\" },\n  base: { chainId: 30, name: \"Base\" },\n  avalanche: { chainId: 6, name: \"Avalanche\" },\n  solana: { chainId: 1, name: \"Solana\" },\n  sui: { chainId: 21, name: \"Sui\" },\n  aptos: { chainId: 22, name: \"Aptos\" },\n};\n\nexport class WormholeProvider implements BridgeProvider {\n  name = \"Wormhole\";\n  id = \"wormhole\";\n  supportedChains: Chain[] = Object.keys(WORMHOLE_CHAINS) as Chain[];\n  private apiUrl: string;\n\n  constructor(apiUrl = \"https://wormhole-v2-mainnet-api.certus.one\") {\n    this.apiUrl = apiUrl;\n  }\n\n  private async fetch<T>(endpoint: string): Promise<T | null> {\n    try {\n      const response = await fetch(`${this.apiUrl}${endpoint}`);\n      if (!response.ok) return null;\n      return (await response.json()) as T;\n    } catch {\n      return null;\n    }\n  }\n\n  async getQuote(params: QuoteParams): Promise<BridgeQuote | null> {\n    const sourceChainId = WORMHOLE_CHAINS[params.sourceChain]?.chainId;\n    const destChainId = WORMHOLE_CHAINS[params.destChain]?.chainId;\n\n    if (!sourceChainId || !destChainId) {\n      console.error(\"Unsupported chain for Wormhole\");\n      return null;\n    }\n\n    // Wormhole Portal API for quotes\n    // In production, would use their SDK\n    try {\n      const quote = await this.fetch<WormholeQuoteResponse>(\n        `/v1/quote?srcChain=${sourceChainId}&dstChain=${destChainId}&srcToken=${params.sourceToken}&dstToken=${params.destToken}&amount=${params.amount}`\n      );\n\n      if (!quote) {\n        // Simulate quote for demo\n        return this.simulateQuote(params);\n      }\n\n      return {\n        bridgeId: \"wormhole\",\n        bridgeName: \"Wormhole\",\n        sourceChain: params.sourceChain,\n        destChain: params.destChain,\n        sourceToken: params.sourceToken,\n        destToken: params.destToken,\n        inputAmount: params.amount,\n        outputAmount: quote.dstAmount,\n        fee: quote.fee,\n        feeUsd: quote.feeUsd,\n        estimatedTime: quote.estimatedTime,\n        priceImpact: 0,\n        slippage: params.slippage ?? 0.5,\n      };\n    } catch {\n      return this.simulateQuote(params);\n    }\n  }\n\n  private simulateQuote(params: QuoteParams): BridgeQuote {\n    // Simulate a realistic quote for demo purposes\n    const fee = \"0.001\";\n    const feeUsd = 2.5;\n    const outputAmount = (\n      parseFloat(params.amount) * 0.997 // 0.3% fee simulation\n    ).toString();\n\n    return {\n      bridgeId: \"wormhole\",\n      bridgeName: \"Wormhole\",\n      sourceChain: params.sourceChain,\n      destChain: params.destChain,\n      sourceToken: params.sourceToken,\n      destToken: params.destToken,\n      inputAmount: params.amount,\n      outputAmount,\n      fee,\n      feeUsd,\n      estimatedTime: 900, // 15 minutes average\n      priceImpact: 0.1,\n      slippage: params.slippage ?? 0.5,\n    };\n  }\n\n  async getTransaction(txId: string): Promise<BridgeTransaction | null> {\n    try {\n      const tx = await this.fetch<WormholeTxResponse>(`/v1/transaction/${txId}`);\n\n      if (!tx) return null;\n\n      const sourceChain = Object.entries(WORMHOLE_CHAINS).find(\n        ([, config]) => config.chainId === tx.srcChainId\n      )?.[0] as Chain;\n      const destChain = Object.entries(WORMHOLE_CHAINS).find(\n        ([, config]) => config.chainId === tx.dstChainId\n      )?.[0] as Chain;\n\n      return {\n        id: tx.id,\n        bridgeId: \"wormhole\",\n        bridgeName: \"Wormhole\",\n        sourceChain,\n        destChain,\n        sourceToken: \"\",\n        destToken: \"\",\n        inputAmount: \"\",\n        status: this.mapStatus(tx.status),\n        sourceTxHash: tx.srcTx,\n        destTxHash: tx.dstTx,\n        createdAt: new Date(tx.timestamp * 1000),\n        completedAt: tx.completedAt ? new Date(tx.completedAt * 1000) : undefined,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  private mapStatus(status: string): BridgeTransaction[\"status\"] {\n    switch (status.toLowerCase()) {\n      case \"pending\":\n        return \"pending\";\n      case \"processing\":\n      case \"attested\":\n        return \"processing\";\n      case \"completed\":\n      case \"redeemed\":\n        return \"completed\";\n      case \"failed\":\n        return \"failed\";\n      default:\n        return \"pending\";\n    }\n  }\n\n  async getSupportedTokens(chain: Chain): Promise<SupportedToken[]> {\n    const chainConfig = WORMHOLE_CHAINS[chain];\n    if (!chainConfig) return [];\n\n    try {\n      const tokens = await this.fetch<WormholeTokenResponse[]>(\n        `/v1/tokens?chainId=${chainConfig.chainId}`\n      );\n\n      if (!tokens) return [];\n\n      return tokens.map((t) => ({\n        symbol: t.symbol,\n        address: t.address,\n        chain,\n        decimals: t.decimals,\n        name: t.name,\n        logoUri: t.logoURI,\n      }));\n    } catch {\n      return [];\n    }\n  }\n}\n","import type {\n  BridgeProvider,\n  BridgeQuote,\n  BridgeTransaction,\n  SupportedToken,\n  Chain,\n  QuoteParams,\n} from \"../types.js\";\n\ninterface LayerZeroChainConfig {\n  chainId: number;\n  endpointId: number;\n  name: string;\n}\n\n// LayerZero Endpoint IDs\nconst LAYERZERO_CHAINS: Record<Chain, LayerZeroChainConfig> = {\n  ethereum: { chainId: 1, endpointId: 101, name: \"Ethereum\" },\n  bsc: { chainId: 56, endpointId: 102, name: \"BSC\" },\n  polygon: { chainId: 137, endpointId: 109, name: \"Polygon\" },\n  arbitrum: { chainId: 42161, endpointId: 110, name: \"Arbitrum\" },\n  optimism: { chainId: 10, endpointId: 111, name: \"Optimism\" },\n  base: { chainId: 8453, endpointId: 184, name: \"Base\" },\n  avalanche: { chainId: 43114, endpointId: 106, name: \"Avalanche\" },\n  solana: { chainId: 0, endpointId: 168, name: \"Solana\" },\n  sui: { chainId: 0, endpointId: 0, name: \"Sui\" }, // Not supported\n  aptos: { chainId: 0, endpointId: 108, name: \"Aptos\" },\n};\n\nexport class LayerZeroProvider implements BridgeProvider {\n  name = \"LayerZero\";\n  id = \"layerzero\";\n  supportedChains: Chain[] = [\"ethereum\", \"bsc\", \"polygon\", \"arbitrum\", \"optimism\", \"base\", \"avalanche\", \"aptos\"];\n  private endpointUrl?: string;\n\n  constructor(endpointUrl?: string) {\n    this.endpointUrl = endpointUrl;\n  }\n\n  async getQuote(params: QuoteParams): Promise<BridgeQuote | null> {\n    const sourceConfig = LAYERZERO_CHAINS[params.sourceChain];\n    const destConfig = LAYERZERO_CHAINS[params.destChain];\n\n    if (!sourceConfig?.endpointId || !destConfig?.endpointId) {\n      return null;\n    }\n\n    // LayerZero uses OFT (Omnichain Fungible Token) standard\n    // Quote calculation would need contract interaction\n    // Simplified simulation for demo\n\n    const fee = this.estimateFee(params.sourceChain, params.destChain);\n    const outputAmount = (\n      parseFloat(params.amount) * (1 - fee.percentage / 100)\n    ).toString();\n\n    return {\n      bridgeId: \"layerzero\",\n      bridgeName: \"LayerZero\",\n      sourceChain: params.sourceChain,\n      destChain: params.destChain,\n      sourceToken: params.sourceToken,\n      destToken: params.destToken,\n      inputAmount: params.amount,\n      outputAmount,\n      fee: fee.native.toString(),\n      feeUsd: fee.usd,\n      estimatedTime: 120, // ~2 minutes (much faster than traditional bridges)\n      priceImpact: 0,\n      slippage: params.slippage ?? 0.5,\n    };\n  }\n\n  private estimateFee(\n    source: Chain,\n    dest: Chain\n  ): { native: number; usd: number; percentage: number } {\n    // Base fee varies by chain pair\n    const baseFees: Record<string, number> = {\n      \"ethereum-arbitrum\": 0.001,\n      \"ethereum-optimism\": 0.001,\n      \"ethereum-base\": 0.001,\n      \"ethereum-polygon\": 0.002,\n      \"ethereum-bsc\": 0.003,\n      \"arbitrum-optimism\": 0.0005,\n      default: 0.002,\n    };\n\n    const key = `${source}-${dest}`;\n    const reverseKey = `${dest}-${source}`;\n    const nativeFee = baseFees[key] ?? baseFees[reverseKey] ?? baseFees.default;\n\n    // Rough USD estimate\n    const ethPrice = 2500;\n    const usdFee = nativeFee * ethPrice;\n\n    return {\n      native: nativeFee,\n      usd: usdFee,\n      percentage: 0.1, // LayerZero has very low fees\n    };\n  }\n\n  async getTransaction(_txId: string): Promise<BridgeTransaction | null> {\n    // Would need to use LayerZero Scan API\n    // https://layerzeroscan.com/api\n    return null;\n  }\n\n  async getSupportedTokens(_chain: Chain): Promise<SupportedToken[]> {\n    // Would query OFT contracts on the chain\n    // Common OFT tokens: STG (Stargate), USDC, USDT\n    return [];\n  }\n\n  getEndpointId(chain: Chain): number | null {\n    return LAYERZERO_CHAINS[chain]?.endpointId ?? null;\n  }\n}\n","import type {\n  BridgeProvider,\n  BridgeQuote,\n  BridgeTransaction,\n  SupportedToken,\n  Chain,\n  QuoteParams,\n} from \"../types.js\";\n\ninterface DeBridgeChainConfig {\n  chainId: number;\n  name: string;\n}\n\ninterface DeBridgeQuoteResponse {\n  estimation: {\n    srcChainTokenIn: {\n      amount: string;\n      symbol: string;\n    };\n    dstChainTokenOut: {\n      amount: string;\n      symbol: string;\n    };\n    recommendedSlippage: number;\n  };\n  tx?: {\n    data: string;\n    to: string;\n    value: string;\n  };\n  priceImpact?: number;\n  executionFee?: {\n    amount: string;\n    symbol: string;\n  };\n  estimatedTime?: number;\n}\n\ninterface DeBridgeTxResponse {\n  orderId: string;\n  state: string;\n  srcChainId: number;\n  dstChainId: number;\n  giveAmount: string;\n  takeAmount: string;\n  createTxHash: string;\n  fulfillTxHash?: string;\n  createdAt: string;\n  fulfilledAt?: string;\n  errorMessage?: string;\n}\n\ninterface DeBridgeTokenResponse {\n  address: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n  logoURI?: string;\n}\n\nconst DEBRIDGE_CHAINS: Record<Chain, DeBridgeChainConfig> = {\n  ethereum: { chainId: 1, name: \"Ethereum\" },\n  bsc: { chainId: 56, name: \"BSC\" },\n  polygon: { chainId: 137, name: \"Polygon\" },\n  arbitrum: { chainId: 42161, name: \"Arbitrum\" },\n  optimism: { chainId: 10, name: \"Optimism\" },\n  base: { chainId: 8453, name: \"Base\" },\n  avalanche: { chainId: 43114, name: \"Avalanche\" },\n  solana: { chainId: 7565164, name: \"Solana\" },\n  sui: { chainId: 0, name: \"Sui\" }, // Not supported\n  aptos: { chainId: 0, name: \"Aptos\" }, // Not supported\n};\n\nexport class DeBridgeProvider implements BridgeProvider {\n  name = \"deBridge\";\n  id = \"debridge\";\n  supportedChains: Chain[] = [\"ethereum\", \"bsc\", \"polygon\", \"arbitrum\", \"optimism\", \"base\", \"avalanche\", \"solana\"];\n  private apiKey?: string;\n  private baseUrl = \"https://api.dln.trade/v1.0\";\n\n  constructor(config: { apiKey?: string } = {}) {\n    this.apiKey = config.apiKey;\n  }\n\n  private async fetch<T>(endpoint: string, params?: Record<string, string>): Promise<T | null> {\n    try {\n      const url = new URL(`${this.baseUrl}${endpoint}`);\n      if (params) {\n        Object.entries(params).forEach(([key, value]) => {\n          url.searchParams.append(key, value);\n        });\n      }\n\n      const headers: Record<string, string> = {\n        Accept: \"application/json\",\n      };\n      if (this.apiKey) {\n        headers[\"Authorization\"] = `Bearer ${this.apiKey}`;\n      }\n\n      const response = await fetch(url.toString(), { headers });\n      if (!response.ok) return null;\n      return (await response.json()) as T;\n    } catch {\n      return null;\n    }\n  }\n\n  async getQuote(params: QuoteParams): Promise<BridgeQuote | null> {\n    const sourceChainId = DEBRIDGE_CHAINS[params.sourceChain]?.chainId;\n    const destChainId = DEBRIDGE_CHAINS[params.destChain]?.chainId;\n\n    if (!sourceChainId || !destChainId) {\n      return null;\n    }\n\n    try {\n      const quote = await this.fetch<DeBridgeQuoteResponse>(\"/dln/order/quote\", {\n        srcChainId: sourceChainId.toString(),\n        srcChainTokenIn: params.sourceToken,\n        srcChainTokenInAmount: params.amount,\n        dstChainId: destChainId.toString(),\n        dstChainTokenOut: params.destToken,\n        prependOperatingExpenses: \"true\",\n      });\n\n      if (!quote?.estimation) {\n        return this.simulateQuote(params);\n      }\n\n      const feeAmount = quote.executionFee?.amount ?? \"0\";\n      const feeUsd = parseFloat(feeAmount) * 0.001; // Rough estimate\n\n      return {\n        bridgeId: \"debridge\",\n        bridgeName: \"deBridge\",\n        sourceChain: params.sourceChain,\n        destChain: params.destChain,\n        sourceToken: params.sourceToken,\n        destToken: params.destToken,\n        inputAmount: params.amount,\n        outputAmount: quote.estimation.dstChainTokenOut.amount,\n        fee: feeAmount,\n        feeUsd,\n        estimatedTime: quote.estimatedTime ?? 60, // ~1 minute\n        priceImpact: quote.priceImpact ?? 0,\n        slippage: quote.estimation.recommendedSlippage,\n      };\n    } catch {\n      return this.simulateQuote(params);\n    }\n  }\n\n  private simulateQuote(params: QuoteParams): BridgeQuote {\n    const outputAmount = (parseFloat(params.amount) * 0.998).toString();\n\n    return {\n      bridgeId: \"debridge\",\n      bridgeName: \"deBridge\",\n      sourceChain: params.sourceChain,\n      destChain: params.destChain,\n      sourceToken: params.sourceToken,\n      destToken: params.destToken,\n      inputAmount: params.amount,\n      outputAmount,\n      fee: \"0.0005\",\n      feeUsd: 1.25,\n      estimatedTime: 60,\n      priceImpact: 0.05,\n      slippage: params.slippage ?? 0.5,\n    };\n  }\n\n  async getTransaction(orderId: string): Promise<BridgeTransaction | null> {\n    try {\n      const tx = await this.fetch<DeBridgeTxResponse>(`/dln/order/${orderId}`);\n      if (!tx) return null;\n\n      const sourceChain = Object.entries(DEBRIDGE_CHAINS).find(\n        ([, config]) => config.chainId === tx.srcChainId\n      )?.[0] as Chain;\n      const destChain = Object.entries(DEBRIDGE_CHAINS).find(\n        ([, config]) => config.chainId === tx.dstChainId\n      )?.[0] as Chain;\n\n      return {\n        id: tx.orderId,\n        bridgeId: \"debridge\",\n        bridgeName: \"deBridge\",\n        sourceChain,\n        destChain,\n        sourceToken: \"\",\n        destToken: \"\",\n        inputAmount: tx.giveAmount,\n        outputAmount: tx.takeAmount,\n        status: this.mapStatus(tx.state),\n        sourceTxHash: tx.createTxHash,\n        destTxHash: tx.fulfillTxHash,\n        createdAt: new Date(tx.createdAt),\n        completedAt: tx.fulfilledAt ? new Date(tx.fulfilledAt) : undefined,\n        error: tx.errorMessage,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  private mapStatus(state: string): BridgeTransaction[\"status\"] {\n    switch (state.toLowerCase()) {\n      case \"created\":\n      case \"ordercreated\":\n        return \"pending\";\n      case \"claiminprogress\":\n      case \"fulfillsent\":\n        return \"processing\";\n      case \"fulfilled\":\n      case \"claimunlocked\":\n        return \"completed\";\n      case \"cancelled\":\n      case \"ordercancelled\":\n        return \"failed\";\n      default:\n        return \"pending\";\n    }\n  }\n\n  async getSupportedTokens(chain: Chain): Promise<SupportedToken[]> {\n    const chainConfig = DEBRIDGE_CHAINS[chain];\n    if (!chainConfig?.chainId) return [];\n\n    try {\n      const tokens = await this.fetch<DeBridgeTokenResponse[]>(\n        `/token-list?chainId=${chainConfig.chainId}`\n      );\n\n      if (!tokens) return [];\n\n      return tokens.map((t) => ({\n        symbol: t.symbol,\n        address: t.address,\n        chain,\n        decimals: t.decimals,\n        name: t.name,\n        logoUri: t.logoURI,\n      }));\n    } catch {\n      return [];\n    }\n  }\n}\n","import type { BridgeProvider, BridgeQuote, BridgeRoute, Chain, QuoteParams } from \"../types.js\";\n\nexport interface PathfinderConfig {\n  maxHops?: number;\n  preferredBridges?: string[];\n  excludeBridges?: string[];\n}\n\nexport class Pathfinder {\n  private providers: Map<string, BridgeProvider> = new Map();\n  private config: PathfinderConfig;\n\n  constructor(providers: BridgeProvider[], config: PathfinderConfig = {}) {\n    for (const provider of providers) {\n      this.providers.set(provider.id, provider);\n    }\n    this.config = {\n      maxHops: config.maxHops ?? 2,\n      preferredBridges: config.preferredBridges ?? [],\n      excludeBridges: config.excludeBridges ?? [],\n    };\n  }\n\n  async findBestRoute(params: QuoteParams): Promise<BridgeRoute | null> {\n    const quotes = await this.getAllQuotes(params);\n\n    if (quotes.length === 0) {\n      // Try multi-hop route\n      const multiHopQuotes = await this.findMultiHopRoutes(params);\n      if (multiHopQuotes.length === 0) return null;\n      return this.selectBestRoute(multiHopQuotes);\n    }\n\n    return this.selectBestRoute(quotes);\n  }\n\n  async getAllQuotes(params: QuoteParams): Promise<BridgeQuote[]> {\n    const quotes: BridgeQuote[] = [];\n    const providers = this.getActiveProviders();\n\n    const quotePromises = providers.map(async (provider) => {\n      // Check if bridge supports both chains\n      if (\n        !provider.supportedChains.includes(params.sourceChain) ||\n        !provider.supportedChains.includes(params.destChain)\n      ) {\n        return null;\n      }\n\n      try {\n        return await provider.getQuote(params);\n      } catch {\n        return null;\n      }\n    });\n\n    const results = await Promise.all(quotePromises);\n    for (const quote of results) {\n      if (quote) quotes.push(quote);\n    }\n\n    return quotes;\n  }\n\n  private getActiveProviders(): BridgeProvider[] {\n    const excluded = new Set(this.config.excludeBridges ?? []);\n    return Array.from(this.providers.values()).filter(\n      (p) => !excluded.has(p.id)\n    );\n  }\n\n  private async findMultiHopRoutes(params: QuoteParams): Promise<BridgeQuote[]> {\n    if ((this.config.maxHops ?? 2) < 2) return [];\n\n    // Common intermediate chains for multi-hop\n    const intermediateChains: Chain[] = [\"ethereum\", \"arbitrum\", \"polygon\"];\n    const multiHopQuotes: BridgeQuote[] = [];\n\n    for (const intermediate of intermediateChains) {\n      if (intermediate === params.sourceChain || intermediate === params.destChain) {\n        continue;\n      }\n\n      // Get quotes for first hop\n      const firstHopParams: QuoteParams = {\n        ...params,\n        destChain: intermediate,\n        destToken: params.sourceToken, // Assume same token for simplicity\n      };\n      const firstHopQuotes = await this.getAllQuotes(firstHopParams);\n\n      if (firstHopQuotes.length === 0) continue;\n\n      // Get quotes for second hop using best first hop output\n      const bestFirstHop = this.selectCheapest(firstHopQuotes);\n      if (!bestFirstHop) continue;\n\n      const secondHopParams: QuoteParams = {\n        sourceChain: intermediate,\n        destChain: params.destChain,\n        sourceToken: bestFirstHop.destToken,\n        destToken: params.destToken,\n        amount: bestFirstHop.outputAmount,\n        slippage: params.slippage,\n      };\n      const secondHopQuotes = await this.getAllQuotes(secondHopParams);\n\n      if (secondHopQuotes.length === 0) continue;\n\n      const bestSecondHop = this.selectCheapest(secondHopQuotes);\n      if (!bestSecondHop) continue;\n\n      // Create combined quote\n      const combinedQuote: BridgeQuote = {\n        bridgeId: `${bestFirstHop.bridgeId}+${bestSecondHop.bridgeId}`,\n        bridgeName: `${bestFirstHop.bridgeName} â†’ ${bestSecondHop.bridgeName}`,\n        sourceChain: params.sourceChain,\n        destChain: params.destChain,\n        sourceToken: params.sourceToken,\n        destToken: params.destToken,\n        inputAmount: params.amount,\n        outputAmount: bestSecondHop.outputAmount,\n        fee: (parseFloat(bestFirstHop.fee) + parseFloat(bestSecondHop.fee)).toString(),\n        feeUsd: bestFirstHop.feeUsd + bestSecondHop.feeUsd,\n        estimatedTime: bestFirstHop.estimatedTime + bestSecondHop.estimatedTime,\n        priceImpact: bestFirstHop.priceImpact + bestSecondHop.priceImpact,\n        slippage: Math.max(bestFirstHop.slippage, bestSecondHop.slippage),\n      };\n\n      multiHopQuotes.push(combinedQuote);\n    }\n\n    return multiHopQuotes;\n  }\n\n  private selectBestRoute(quotes: BridgeQuote[]): BridgeRoute {\n    const cheapest = this.selectCheapest(quotes)!;\n    const fastest = this.selectFastest(quotes)!;\n    const bestValue = this.selectBestValue(quotes)!;\n\n    // Default best is best value\n    const bestQuote = bestValue;\n\n    return {\n      quotes,\n      bestQuote,\n      comparison: {\n        cheapest,\n        fastest,\n        bestValue,\n      },\n    };\n  }\n\n  private selectCheapest(quotes: BridgeQuote[]): BridgeQuote | null {\n    if (quotes.length === 0) return null;\n    return quotes.reduce((best, quote) =>\n      quote.feeUsd < best.feeUsd ? quote : best\n    );\n  }\n\n  private selectFastest(quotes: BridgeQuote[]): BridgeQuote | null {\n    if (quotes.length === 0) return null;\n    return quotes.reduce((best, quote) =>\n      quote.estimatedTime < best.estimatedTime ? quote : best\n    );\n  }\n\n  private selectBestValue(quotes: BridgeQuote[]): BridgeQuote | null {\n    if (quotes.length === 0) return null;\n\n    // Score = output amount - weighted fees - time penalty\n    return quotes.reduce((best, quote) => {\n      const outputValue = parseFloat(quote.outputAmount);\n      const feePenalty = quote.feeUsd * 0.5;\n      const timePenalty = quote.estimatedTime / 3600; // Hours\n      const score = outputValue - feePenalty - timePenalty;\n\n      const bestOutput = parseFloat(best.outputAmount);\n      const bestFeePenalty = best.feeUsd * 0.5;\n      const bestTimePenalty = best.estimatedTime / 3600;\n      const bestScore = bestOutput - bestFeePenalty - bestTimePenalty;\n\n      return score > bestScore ? quote : best;\n    });\n  }\n\n  addProvider(provider: BridgeProvider): void {\n    this.providers.set(provider.id, provider);\n  }\n\n  removeProvider(providerId: string): void {\n    this.providers.delete(providerId);\n  }\n}\n","import type { BridgeQuote, Chain } from \"../types.js\";\n\nexport interface FeeEstimate {\n  bridgeFee: number;\n  bridgeFeeUsd: number;\n  gasFeeSource: number;\n  gasFeeSourceUsd: number;\n  gasFeeDest: number;\n  gasFeeDestUsd: number;\n  totalFee: number;\n  totalFeeUsd: number;\n}\n\nexport interface TimeEstimate {\n  minTime: number; // seconds\n  avgTime: number;\n  maxTime: number;\n  confidence: number; // 0-1\n}\n\n// Approximate gas prices by chain (in native token)\nconst GAS_PRICES: Record<Chain, { low: number; avg: number; high: number }> = {\n  ethereum: { low: 10, avg: 25, high: 50 }, // gwei\n  bsc: { low: 3, avg: 5, high: 10 },\n  polygon: { low: 30, avg: 50, high: 100 },\n  arbitrum: { low: 0.01, avg: 0.1, high: 0.5 },\n  optimism: { low: 0.001, avg: 0.01, high: 0.1 },\n  base: { low: 0.001, avg: 0.01, high: 0.05 },\n  avalanche: { low: 25, avg: 30, high: 50 },\n  solana: { low: 0.000005, avg: 0.00001, high: 0.0001 },\n  sui: { low: 0.001, avg: 0.005, high: 0.01 },\n  aptos: { low: 0.0001, avg: 0.001, high: 0.01 },\n};\n\n// Approximate native token prices (USD)\nconst NATIVE_PRICES: Record<Chain, number> = {\n  ethereum: 2500,\n  bsc: 300,\n  polygon: 0.8,\n  arbitrum: 2500, // ETH\n  optimism: 2500, // ETH\n  base: 2500, // ETH\n  avalanche: 35,\n  solana: 100,\n  sui: 1.5,\n  aptos: 10,\n};\n\n// Average bridge times by type\nconst BRIDGE_TIMES: Record<string, { min: number; avg: number; max: number }> = {\n  wormhole: { min: 600, avg: 900, max: 1800 }, // 10-30 min\n  layerzero: { min: 60, avg: 120, max: 300 }, // 1-5 min\n  debridge: { min: 30, avg: 60, max: 120 }, // 0.5-2 min\n  default: { min: 300, avg: 600, max: 1200 },\n};\n\nexport class Estimator {\n  estimateFees(\n    quote: BridgeQuote,\n    gasLevel: \"low\" | \"avg\" | \"high\" = \"avg\"\n  ): FeeEstimate {\n    const sourceGasPrice = GAS_PRICES[quote.sourceChain]?.[gasLevel] ?? 0;\n    const destGasPrice = GAS_PRICES[quote.destChain]?.[gasLevel] ?? 0;\n    const sourceNativePrice = NATIVE_PRICES[quote.sourceChain] ?? 0;\n    const destNativePrice = NATIVE_PRICES[quote.destChain] ?? 0;\n\n    // Estimate gas units (simplified)\n    const sourceGasUnits = this.estimateSourceGas(quote);\n    const destGasUnits = this.estimateDestGas(quote);\n\n    const gasFeeSource = (sourceGasPrice * sourceGasUnits) / 1e9; // Convert from gwei\n    const gasFeeSourceUsd = gasFeeSource * sourceNativePrice;\n\n    const gasFeeDest = (destGasPrice * destGasUnits) / 1e9;\n    const gasFeeDestUsd = gasFeeDest * destNativePrice;\n\n    const bridgeFee = parseFloat(quote.fee);\n    const bridgeFeeUsd = quote.feeUsd;\n\n    return {\n      bridgeFee,\n      bridgeFeeUsd,\n      gasFeeSource,\n      gasFeeSourceUsd,\n      gasFeeDest,\n      gasFeeDestUsd,\n      totalFee: bridgeFee + gasFeeSource + gasFeeDest,\n      totalFeeUsd: bridgeFeeUsd + gasFeeSourceUsd + gasFeeDestUsd,\n    };\n  }\n\n  private estimateSourceGas(quote: BridgeQuote): number {\n    // Gas units vary by chain and bridge\n    const baseGas: Record<string, number> = {\n      ethereum: 150000,\n      bsc: 100000,\n      polygon: 100000,\n      arbitrum: 500000, // Higher for L2\n      optimism: 500000,\n      base: 500000,\n      avalanche: 100000,\n      solana: 5000, // Compute units\n      sui: 1000,\n      aptos: 1000,\n    };\n\n    return baseGas[quote.sourceChain] ?? 150000;\n  }\n\n  private estimateDestGas(quote: BridgeQuote): number {\n    // Destination gas is usually for claiming/receiving\n    const baseGas: Record<string, number> = {\n      ethereum: 100000,\n      bsc: 80000,\n      polygon: 80000,\n      arbitrum: 300000,\n      optimism: 300000,\n      base: 300000,\n      avalanche: 80000,\n      solana: 5000,\n      sui: 1000,\n      aptos: 1000,\n    };\n\n    return baseGas[quote.destChain] ?? 100000;\n  }\n\n  estimateTime(bridgeId: string): TimeEstimate {\n    const baseBridge = bridgeId.split(\"+\")[0] ?? bridgeId;\n    const times = BRIDGE_TIMES[baseBridge] ?? BRIDGE_TIMES.default;\n\n    // Multi-hop routes take longer\n    const hopCount = bridgeId.split(\"+\").length;\n    const multiplier = hopCount;\n\n    return {\n      minTime: times.min * multiplier,\n      avgTime: times.avg * multiplier,\n      maxTime: times.max * multiplier,\n      confidence: hopCount === 1 ? 0.9 : 0.7,\n    };\n  }\n\n  calculateSlippageImpact(\n    inputAmount: string,\n    outputAmount: string,\n    priceImpact: number\n  ): {\n    effectiveRate: number;\n    slippageLoss: number;\n    slippageLossUsd: number;\n  } {\n    const input = parseFloat(inputAmount);\n    const output = parseFloat(outputAmount);\n\n    const effectiveRate = output / input;\n    const idealRate = 1; // Assuming 1:1 for same token bridges\n    const slippageLoss = (idealRate - effectiveRate) * input;\n    const slippageLossUsd = slippageLoss; // Would need price for accurate USD\n\n    return {\n      effectiveRate,\n      slippageLoss,\n      slippageLossUsd,\n    };\n  }\n\n  compareQuotes(quotes: BridgeQuote[]): {\n    ranked: Array<{\n      quote: BridgeQuote;\n      score: number;\n      fees: FeeEstimate;\n      time: TimeEstimate;\n    }>;\n  } {\n    const analyzed = quotes.map((quote) => {\n      const fees = this.estimateFees(quote);\n      const time = this.estimateTime(quote.bridgeId);\n\n      // Scoring: prioritize output amount, then fees, then speed\n      const outputScore = parseFloat(quote.outputAmount) * 100;\n      const feeScore = -fees.totalFeeUsd * 10;\n      const timeScore = -time.avgTime / 60; // Minutes penalty\n\n      return {\n        quote,\n        score: outputScore + feeScore + timeScore,\n        fees,\n        time,\n      };\n    });\n\n    analyzed.sort((a, b) => b.score - a.score);\n\n    return { ranked: analyzed };\n  }\n}\n"],"mappings":"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","names":["z","z"]}