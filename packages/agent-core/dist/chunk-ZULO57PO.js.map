{"version":3,"sources":["../src/observability/metrics-registry.ts"],"sourcesContent":["/**\n * Metrics Registry (Phase 14C)\n *\n * Centralized metrics collection with counters, gauges, histograms, and summaries.\n * Supports Prometheus, OpenTelemetry, and custom exporters.\n */\n\nimport { metrics, type Meter, type Counter, type Histogram, type ObservableGauge } from '@opentelemetry/api';\n\nexport interface MetricsConfig {\n  serviceName: string;\n  prefix?: string;\n  defaultLabels?: Record<string, string>;\n}\n\nexport type MetricType = 'counter' | 'gauge' | 'histogram' | 'summary';\n\nexport interface MetricMetadata {\n  name: string;\n  type: MetricType;\n  description: string;\n  unit?: string;\n  labels: string[];\n}\n\n/**\n * Metrics Registry\n */\nexport class MetricsRegistry {\n  private config: Required<MetricsConfig>;\n  private meter: Meter;\n  private counters = new Map<string, Counter>();\n  private histograms = new Map<string, Histogram>();\n  private gauges = new Map<string, { value: number; callback: (value: number) => void }>();\n  private metadata = new Map<string, MetricMetadata>();\n\n  constructor(config: MetricsConfig) {\n    this.config = {\n      prefix: 'gicm',\n      defaultLabels: {},\n      ...config,\n    };\n\n    this.meter = metrics.getMeter(this.config.serviceName);\n  }\n\n  /**\n   * Create or get a counter metric\n   */\n  counter(\n    name: string,\n    description: string,\n    unit?: string\n  ): Counter {\n    const fullName = this.getFullName(name);\n\n    if (!this.counters.has(fullName)) {\n      const counter = this.meter.createCounter(fullName, { description, unit });\n      this.counters.set(fullName, counter);\n\n      this.metadata.set(fullName, {\n        name: fullName,\n        type: 'counter',\n        description,\n        unit,\n        labels: [],\n      });\n    }\n\n    return this.counters.get(fullName)!;\n  }\n\n  /**\n   * Create or get a histogram metric\n   */\n  histogram(\n    name: string,\n    description: string,\n    unit?: string,\n    boundaries?: number[]\n  ): Histogram {\n    const fullName = this.getFullName(name);\n\n    if (!this.histograms.has(fullName)) {\n      const histogram = this.meter.createHistogram(fullName, { description, unit });\n      this.histograms.set(fullName, histogram);\n\n      this.metadata.set(fullName, {\n        name: fullName,\n        type: 'histogram',\n        description,\n        unit,\n        labels: [],\n      });\n    }\n\n    return this.histograms.get(fullName)!;\n  }\n\n  /**\n   * Create or get a gauge metric\n   */\n  gauge(\n    name: string,\n    description: string,\n    unit?: string\n  ): { set: (value: number) => void; get: () => number } {\n    const fullName = this.getFullName(name);\n\n    if (!this.gauges.has(fullName)) {\n      let currentValue = 0;\n\n      const observableGauge = this.meter.createObservableGauge(fullName, {\n        description,\n        unit,\n      });\n\n      observableGauge.addCallback((result) => {\n        result.observe(currentValue, this.config.defaultLabels);\n      });\n\n      this.gauges.set(fullName, {\n        value: currentValue,\n        callback: (value: number) => {\n          currentValue = value;\n        },\n      });\n\n      this.metadata.set(fullName, {\n        name: fullName,\n        type: 'gauge',\n        description,\n        unit,\n        labels: [],\n      });\n    }\n\n    const gauge = this.gauges.get(fullName)!;\n\n    return {\n      set: (value: number) => {\n        gauge.callback(value);\n        gauge.value = value;\n      },\n      get: () => gauge.value,\n    };\n  }\n\n  /**\n   * Increment a counter\n   */\n  inc(name: string, value = 1, labels?: Record<string, string>): void {\n    const counter = this.counter(name, `Counter: ${name}`);\n    counter.add(value, { ...this.config.defaultLabels, ...labels });\n  }\n\n  /**\n   * Decrement a counter (not standard but useful)\n   */\n  dec(name: string, value = 1, labels?: Record<string, string>): void {\n    const counter = this.counter(name, `Counter: ${name}`);\n    counter.add(-value, { ...this.config.defaultLabels, ...labels });\n  }\n\n  /**\n   * Set a gauge value\n   */\n  set(name: string, value: number, labels?: Record<string, string>): void {\n    const gauge = this.gauge(name, `Gauge: ${name}`);\n    gauge.set(value);\n  }\n\n  /**\n   * Record a histogram observation\n   */\n  observe(name: string, value: number, labels?: Record<string, string>): void {\n    const histogram = this.histogram(name, `Histogram: ${name}`);\n    histogram.record(value, { ...this.config.defaultLabels, ...labels });\n  }\n\n  /**\n   * Time a function execution and record duration\n   */\n  async time<T>(\n    name: string,\n    fn: () => Promise<T>,\n    labels?: Record<string, string>\n  ): Promise<T> {\n    const start = Date.now();\n    try {\n      return await fn();\n    } finally {\n      const duration = Date.now() - start;\n      this.observe(`${name}_duration_ms`, duration, labels);\n    }\n  }\n\n  /**\n   * Time a sync function execution and record duration\n   */\n  timeSync<T>(\n    name: string,\n    fn: () => T,\n    labels?: Record<string, string>\n  ): T {\n    const start = Date.now();\n    try {\n      return fn();\n    } finally {\n      const duration = Date.now() - start;\n      this.observe(`${name}_duration_ms`, duration, labels);\n    }\n  }\n\n  /**\n   * Get metric metadata\n   */\n  getMetadata(name: string): MetricMetadata | undefined {\n    const fullName = this.getFullName(name);\n    return this.metadata.get(fullName);\n  }\n\n  /**\n   * Get all registered metrics\n   */\n  getAllMetrics(): MetricMetadata[] {\n    return Array.from(this.metadata.values());\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clear(): void {\n    this.counters.clear();\n    this.histograms.clear();\n    this.gauges.clear();\n    this.metadata.clear();\n  }\n\n  /**\n   * Get full metric name with prefix\n   */\n  private getFullName(name: string): string {\n    return `${this.config.prefix}_${name}`;\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): Readonly<Required<MetricsConfig>> {\n    return Object.freeze({ ...this.config });\n  }\n}\n\n/**\n * Standard Metrics (pre-defined for common use cases)\n */\nexport class StandardMetrics {\n  private registry: MetricsRegistry;\n\n  // Counters\n  public requestsTotal: Counter;\n  public errorsTotal: Counter;\n  public retryTotal: Counter;\n\n  // Histograms\n  public requestDuration: Histogram;\n  public llmTokens: Histogram;\n  public llmCost: Histogram;\n\n  // Gauges\n  public activeRequests: ReturnType<MetricsRegistry['gauge']>;\n  public circuitBreakerState: ReturnType<MetricsRegistry['gauge']>;\n\n  constructor(registry: MetricsRegistry) {\n    this.registry = registry;\n\n    // Initialize counters\n    this.requestsTotal = registry.counter(\n      'requests_total',\n      'Total number of requests',\n      'requests'\n    );\n\n    this.errorsTotal = registry.counter(\n      'errors_total',\n      'Total number of errors',\n      'errors'\n    );\n\n    this.retryTotal = registry.counter(\n      'retry_total',\n      'Total number of retries',\n      'retries'\n    );\n\n    // Initialize histograms\n    this.requestDuration = registry.histogram(\n      'request_duration_ms',\n      'Request duration in milliseconds',\n      'ms'\n    );\n\n    this.llmTokens = registry.histogram(\n      'llm_tokens',\n      'LLM tokens used per request',\n      'tokens'\n    );\n\n    this.llmCost = registry.histogram(\n      'llm_cost_usd',\n      'LLM cost per request in USD',\n      'usd'\n    );\n\n    // Initialize gauges\n    this.activeRequests = registry.gauge(\n      'active_requests',\n      'Number of active requests',\n      'requests'\n    );\n\n    this.circuitBreakerState = registry.gauge(\n      'circuit_breaker_state',\n      'Circuit breaker state (0=closed, 1=open, 2=half-open)',\n      'state'\n    );\n  }\n\n  /**\n   * Record a successful request\n   */\n  recordRequest(durationMs: number, labels?: Record<string, string>): void {\n    this.requestsTotal.add(1, labels);\n    this.requestDuration.record(durationMs, labels);\n  }\n\n  /**\n   * Record an error\n   */\n  recordError(errorType: string, labels?: Record<string, string>): void {\n    this.errorsTotal.add(1, { ...labels, error_type: errorType });\n  }\n\n  /**\n   * Record a retry\n   */\n  recordRetry(reason: string, labels?: Record<string, string>): void {\n    this.retryTotal.add(1, { ...labels, reason });\n  }\n\n  /**\n   * Record LLM usage\n   */\n  recordLLMUsage(\n    tokens: number,\n    costUsd: number,\n    model: string,\n    labels?: Record<string, string>\n  ): void {\n    this.llmTokens.record(tokens, { ...labels, model });\n    this.llmCost.record(costUsd, { ...labels, model });\n  }\n\n  /**\n   * Increment active requests\n   */\n  incActiveRequests(): void {\n    const current = this.activeRequests.get();\n    this.activeRequests.set(current + 1);\n  }\n\n  /**\n   * Decrement active requests\n   */\n  decActiveRequests(): void {\n    const current = this.activeRequests.get();\n    this.activeRequests.set(Math.max(0, current - 1));\n  }\n\n  /**\n   * Set circuit breaker state\n   */\n  setCircuitBreakerState(state: 'closed' | 'open' | 'half-open'): void {\n    const stateValue = state === 'closed' ? 0 : state === 'open' ? 1 : 2;\n    this.circuitBreakerState.set(stateValue);\n  }\n}\n\n/**\n * Global metrics registry (singleton pattern)\n */\nlet globalRegistry: MetricsRegistry | null = null;\nlet globalStandardMetrics: StandardMetrics | null = null;\n\nexport function initializeMetrics(config: MetricsConfig): {\n  registry: MetricsRegistry;\n  standard: StandardMetrics;\n} {\n  if (globalRegistry) {\n    console.warn('[MetricsRegistry] Global registry already exists');\n    return {\n      registry: globalRegistry,\n      standard: globalStandardMetrics!,\n    };\n  }\n\n  globalRegistry = new MetricsRegistry(config);\n  globalStandardMetrics = new StandardMetrics(globalRegistry);\n\n  return {\n    registry: globalRegistry,\n    standard: globalStandardMetrics,\n  };\n}\n\nexport function getMetricsRegistry(): MetricsRegistry {\n  if (!globalRegistry) {\n    throw new Error('[MetricsRegistry] Global registry not initialized. Call initializeMetrics() first.');\n  }\n  return globalRegistry;\n}\n\nexport function getStandardMetrics(): StandardMetrics {\n  if (!globalStandardMetrics) {\n    throw new Error('[MetricsRegistry] Global standard metrics not initialized. Call initializeMetrics() first.');\n  }\n  return globalStandardMetrics;\n}\n"],"mappings":"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","names":[]}