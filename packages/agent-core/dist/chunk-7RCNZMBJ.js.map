{"version":3,"sources":["../src/observability/telemetry.ts"],"sourcesContent":["/**\n * OpenTelemetry Integration (Phase 14A)\n *\n * Provides distributed tracing, metrics, and context propagation for gICM agents.\n * Supports OTLP exporters for Grafana, Jaeger, Zipkin, etc.\n */\n\nimport { NodeSDK } from '@opentelemetry/sdk-node';\nimport { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';\nimport { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';\nimport { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';\nimport { resourceFromAttributes, defaultResource } from '@opentelemetry/resources';\nimport {\n  SEMRESATTRS_SERVICE_NAME,\n  SEMRESATTRS_SERVICE_VERSION,\n  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT\n} from '@opentelemetry/semantic-conventions';\nimport {\n  trace,\n  context,\n  SpanStatusCode,\n  Span,\n  Tracer,\n  type Attributes\n} from '@opentelemetry/api';\n\nexport interface TelemetryConfig {\n  serviceName: string;\n  serviceVersion?: string;\n  environment?: 'development' | 'staging' | 'production';\n\n  // OTLP endpoints\n  traceEndpoint?: string;\n  metricsEndpoint?: string;\n\n  // Feature flags\n  enableTracing?: boolean;\n  enableMetrics?: boolean;\n  enableAutoInstrumentation?: boolean;\n\n  // Sampling\n  traceSampleRate?: number; // 0-1\n\n  // Custom attributes\n  attributes?: Record<string, string | number | boolean>;\n}\n\nconst DEFAULT_CONFIG: Partial<TelemetryConfig> = {\n  serviceVersion: '1.0.0',\n  environment: 'development',\n  traceEndpoint: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces',\n  metricsEndpoint: process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT || 'http://localhost:4318/v1/metrics',\n  enableTracing: true,\n  enableMetrics: true,\n  enableAutoInstrumentation: true,\n  traceSampleRate: 1.0,\n};\n\nexport class TelemetryManager {\n  private sdk: NodeSDK | null = null;\n  private tracer: Tracer | null = null;\n  private config: Required<TelemetryConfig>;\n  private initialized = false;\n\n  constructor(config: TelemetryConfig) {\n    this.config = { ...DEFAULT_CONFIG, ...config } as Required<TelemetryConfig>;\n  }\n\n  /**\n   * Initialize OpenTelemetry SDK\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      console.warn('[Telemetry] Already initialized');\n      return;\n    }\n\n    const resource = defaultResource().merge(\n      resourceFromAttributes({\n        [SEMRESATTRS_SERVICE_NAME]: this.config.serviceName,\n        [SEMRESATTRS_SERVICE_VERSION]: this.config.serviceVersion,\n        [SEMRESATTRS_DEPLOYMENT_ENVIRONMENT]: this.config.environment,\n        ...this.config.attributes,\n      })\n    );\n\n    const traceExporter = new OTLPTraceExporter({\n      url: this.config.traceEndpoint,\n    });\n\n    const metricExporter = new OTLPMetricExporter({\n      url: this.config.metricsEndpoint,\n    });\n\n    this.sdk = new NodeSDK({\n      resource,\n      traceExporter: this.config.enableTracing ? traceExporter : undefined,\n      metricReader: this.config.enableMetrics ?\n        new PeriodicExportingMetricReader({\n          exporter: metricExporter,\n          exportIntervalMillis: 60000, // 1 minute\n        }) : undefined,\n      instrumentations: this.config.enableAutoInstrumentation\n        ? [getNodeAutoInstrumentations()]\n        : [],\n    });\n\n    await this.sdk.start();\n    this.tracer = trace.getTracer(this.config.serviceName, this.config.serviceVersion);\n    this.initialized = true;\n\n    console.log(`[Telemetry] Initialized for ${this.config.serviceName} v${this.config.serviceVersion}`);\n  }\n\n  /**\n   * Shutdown telemetry gracefully\n   */\n  async shutdown(): Promise<void> {\n    if (!this.initialized || !this.sdk) {\n      return;\n    }\n\n    await this.sdk.shutdown();\n    this.initialized = false;\n    console.log('[Telemetry] Shutdown complete');\n  }\n\n  /**\n   * Get the tracer instance\n   */\n  getTracer(): Tracer {\n    if (!this.tracer) {\n      throw new Error('[Telemetry] Not initialized. Call initialize() first.');\n    }\n    return this.tracer;\n  }\n\n  /**\n   * Create a span and execute a function within its context\n   */\n  async traceAsync<T>(\n    name: string,\n    fn: (span: Span) => Promise<T>,\n    attributes?: Attributes\n  ): Promise<T> {\n    const tracer = this.getTracer();\n\n    return tracer.startActiveSpan(name, { attributes }, async (span) => {\n      try {\n        const result = await fn(span);\n        span.setStatus({ code: SpanStatusCode.OK });\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error instanceof Error ? error.message : String(error),\n        });\n        span.recordException(error as Error);\n        throw error;\n      } finally {\n        span.end();\n      }\n    });\n  }\n\n  /**\n   * Create a span and execute a synchronous function within its context\n   */\n  traceSync<T>(\n    name: string,\n    fn: (span: Span) => T,\n    attributes?: Attributes\n  ): T {\n    const tracer = this.getTracer();\n\n    return tracer.startActiveSpan(name, { attributes }, (span) => {\n      try {\n        const result = fn(span);\n        span.setStatus({ code: SpanStatusCode.OK });\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error instanceof Error ? error.message : String(error),\n        });\n        span.recordException(error as Error);\n        throw error;\n      } finally {\n        span.end();\n      }\n    });\n  }\n\n  /**\n   * Wrap an async function with automatic tracing\n   */\n  wrapAsync<TArgs extends any[], TReturn>(\n    name: string,\n    fn: (...args: TArgs) => Promise<TReturn>,\n    attributesExtractor?: (...args: TArgs) => Attributes\n  ): (...args: TArgs) => Promise<TReturn> {\n    return async (...args: TArgs) => {\n      const attributes = attributesExtractor?.(...args);\n      return this.traceAsync(name, async (span) => {\n        if (attributes) {\n          span.setAttributes(attributes);\n        }\n        return fn(...args);\n      });\n    };\n  }\n\n  /**\n   * Wrap a sync function with automatic tracing\n   */\n  wrapSync<TArgs extends any[], TReturn>(\n    name: string,\n    fn: (...args: TArgs) => TReturn,\n    attributesExtractor?: (...args: TArgs) => Attributes\n  ): (...args: TArgs) => TReturn {\n    return (...args: TArgs) => {\n      const attributes = attributesExtractor?.(...args);\n      return this.traceSync(name, (span) => {\n        if (attributes) {\n          span.setAttributes(attributes);\n        }\n        return fn(...args);\n      });\n    };\n  }\n\n  /**\n   * Get the current active span\n   */\n  getCurrentSpan(): Span | undefined {\n    return trace.getActiveSpan();\n  }\n\n  /**\n   * Add attributes to the current active span\n   */\n  addAttributes(attributes: Attributes): void {\n    const span = this.getCurrentSpan();\n    if (span) {\n      span.setAttributes(attributes);\n    }\n  }\n\n  /**\n   * Add an event to the current active span\n   */\n  addEvent(name: string, attributes?: Attributes): void {\n    const span = this.getCurrentSpan();\n    if (span) {\n      span.addEvent(name, attributes);\n    }\n  }\n\n  /**\n   * Record an exception in the current active span\n   */\n  recordException(error: Error): void {\n    const span = this.getCurrentSpan();\n    if (span) {\n      span.recordException(error);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: error.message,\n      });\n    }\n  }\n\n  /**\n   * Check if telemetry is initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<Required<TelemetryConfig>> {\n    return Object.freeze({ ...this.config });\n  }\n}\n\n/**\n * Global telemetry instance (singleton pattern)\n */\nlet globalTelemetry: TelemetryManager | null = null;\n\nexport function initializeTelemetry(config: TelemetryConfig): TelemetryManager {\n  if (globalTelemetry) {\n    console.warn('[Telemetry] Global instance already exists');\n    return globalTelemetry;\n  }\n\n  globalTelemetry = new TelemetryManager(config);\n  return globalTelemetry;\n}\n\nexport function getTelemetry(): TelemetryManager {\n  if (!globalTelemetry) {\n    throw new Error('[Telemetry] Global instance not initialized. Call initializeTelemetry() first.');\n  }\n  return globalTelemetry;\n}\n\nexport function shutdownTelemetry(): Promise<void> {\n  if (!globalTelemetry) {\n    return Promise.resolve();\n  }\n  return globalTelemetry.shutdown();\n}\n\n/**\n * Decorator for automatic method tracing\n */\nexport function Trace(name?: string, attributesExtractor?: (...args: any[]) => Attributes) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n    const traceName = name || `${target.constructor.name}.${propertyKey}`;\n\n    descriptor.value = async function (...args: any[]) {\n      const telemetry = getTelemetry();\n      const attributes = attributesExtractor?.(...args);\n\n      return telemetry.traceAsync(traceName, async (span) => {\n        if (attributes) {\n          span.setAttributes(attributes);\n        }\n        return originalMethod.apply(this, args);\n      });\n    };\n\n    return descriptor;\n  };\n}\n"],"mappings":"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","names":[]}