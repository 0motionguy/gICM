import {
  ArxivHunter,
  BinanceHunter,
  DEFAULT_SCHEDULES,
  DeFiLlamaHunter,
  DevToHunter,
  FREDHunter,
  FearGreedHunter,
  FinnhubHunter,
  GeckoTerminalHunter,
  GitHubHunter,
  GitHubRepoSchema,
  HNItemSchema,
  HackerNewsHunter,
  HuntDiscoverySchema,
  HuntSourceSchema,
  LobstersHunter,
  NPMHunter,
  NitterHunter,
  ProductHuntHunter,
  RELEVANCE_KEYWORDS,
  RawDiscoverySchema,
  RedditHunter,
  SECHunter,
  TikTokHunter,
  TwitterHunter,
  TwitterTweetSchema
} from "./chunk-WZQCI5EU.js";

// src/hunter-agent.ts
import { BaseAgent } from "@gicm/agent-core";
import { CronJob } from "cron";
var HunterAgent = class extends BaseAgent {
  hunters = /* @__PURE__ */ new Map();
  jobs = /* @__PURE__ */ new Map();
  seen = /* @__PURE__ */ new Map();
  // fingerprint -> timestamp
  deduplicationTTL;
  onDiscovery;
  isRunning = false;
  constructor(config) {
    super("hunter", config);
    this.deduplicationTTL = config.deduplicationTTL ?? 7 * 24 * 60 * 60 * 1e3;
    this.onDiscovery = config.onDiscovery;
    for (const sourceConfig of config.sources) {
      if (!sourceConfig.enabled) continue;
      const hunter = this.createHunter(sourceConfig);
      if (hunter) {
        this.hunters.set(sourceConfig.source, hunter);
      }
    }
  }
  getSystemPrompt() {
    return `You are a tech discovery and alpha-hunting agent for gICM.
Your role is to find valuable opportunities from multiple sources
that are relevant to Web3, AI, trading, and developer tooling.

You hunt from:
SOCIAL/TECH:
- GitHub: Trending repos in crypto/AI
- HackerNews: Tech posts and Show HN launches
- Twitter: Crypto/AI discussions
- Reddit: r/programming, r/MachineLearning, r/cryptocurrency, r/solana
- ProductHunt: New product launches
- ArXiv: AI/ML research papers
- Lobste.rs: High-signal tech discussions
- Dev.to: Developer tutorials and tools
- TikTok: Viral crypto/tech content

DEFI/CRYPTO:
- DeFiLlama: TVL changes, yield opportunities, protocol metrics
- GeckoTerminal: New pool launches, trending pairs across chains
- Fear & Greed Index: Market sentiment for contrarian signals
- Binance: Price moves, volume anomalies on major pairs

ECONOMIC/FINANCIAL:
- FRED: Federal Reserve data (rates, inflation, employment)
- SEC EDGAR: Insider trades, 13-F institutional holdings
- Finnhub: Congressional trades, earnings surprises

ALTERNATIVE:
- npm: Package download trends for tech adoption signals

SIX THINKING HATS ANALYSIS:
When evaluating discoveries, analyze from 6 perspectives:
\u{1F3A9} WHITE (Facts): What are the objective metrics and data points?
\u{1F3A9} RED (Emotions): What's the gut feeling? Is there hype or fear?
\u{1F3A9} BLACK (Risks): What could go wrong? Rug risk? Technical issues?
\u{1F3A9} YELLOW (Benefits): What's the upside potential? Alpha opportunity?
\u{1F3A9} GREEN (Creativity): What novel approaches or use cases exist?
\u{1F3A9} BLUE (Process): What's the action plan? Entry/exit strategy?

You evaluate discoveries based on:
- Relevance to gICM (Web3/AI/trading focus)
- Quality signals (stars, engagement, volume, TVL)
- Recency and momentum
- Alpha potential (congressional trades, insider buys, new pools)
- Six Hats multi-perspective analysis`;
  }
  async analyze(context) {
    const action = context.action ?? "hunt";
    switch (action) {
      case "hunt":
        return this.performHunt(context.params?.sources);
      case "status":
        return this.getStatus();
      default:
        return this.createResult(false, null, `Unknown action: ${action}`);
    }
  }
  async start() {
    if (this.isRunning) {
      this.log("Hunter agent already running");
      return;
    }
    this.isRunning = true;
    this.log("Starting hunter agent");
    for (const [source, hunter] of this.hunters) {
      const schedule = this.getSchedule(source);
      const job = new CronJob(schedule, async () => {
        this.log(`Running scheduled hunt for ${source}`);
        await this.huntSource(source, hunter);
      });
      job.start();
      this.jobs.set(source, job);
      this.log(`Scheduled ${source} hunter with cron: ${schedule}`);
    }
  }
  async stop() {
    this.log("Stopping hunter agent");
    this.isRunning = false;
    for (const [source, job] of this.jobs) {
      job.stop();
      this.log(`Stopped ${source} hunter`);
    }
    this.jobs.clear();
  }
  async huntNow(sources) {
    const targetSources = sources ?? Array.from(this.hunters.keys());
    const allDiscoveries = [];
    for (const source of targetSources) {
      const hunter = this.hunters.get(source);
      if (!hunter) continue;
      const discoveries = await this.huntSource(source, hunter);
      allDiscoveries.push(...discoveries);
    }
    return allDiscoveries;
  }
  async performHunt(sources) {
    try {
      const discoveries = await this.huntNow(sources);
      return this.createResult(
        true,
        {
          count: discoveries.length,
          discoveries,
          sources: sources ?? Array.from(this.hunters.keys())
        },
        void 0,
        0.9,
        `Found ${discoveries.length} new discoveries`
      );
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return this.createResult(false, null, message);
    }
  }
  async huntSource(source, hunter) {
    try {
      this.log(`Hunting ${source}...`);
      const rawDiscoveries = await hunter.hunt();
      this.log(`${source}: Found ${rawDiscoveries.length} raw discoveries`);
      const discoveries = [];
      for (const raw of rawDiscoveries) {
        const discovery = hunter.transform(raw);
        if (this.hasSeen(discovery.fingerprint)) {
          continue;
        }
        this.markSeen(discovery.fingerprint);
        discoveries.push(discovery);
      }
      this.log(`${source}: ${discoveries.length} new unique discoveries`);
      if (this.onDiscovery && discoveries.length > 0) {
        await this.onDiscovery(discoveries);
      }
      return discoveries;
    } catch (error) {
      this.log(`${source} hunt failed: ${error}`);
      return [];
    }
  }
  getStatus() {
    const status = {
      isRunning: this.isRunning,
      hunters: Array.from(this.hunters.keys()),
      jobs: Array.from(this.jobs.entries()).map(([source, job]) => ({
        source,
        running: job.running,
        nextRun: job.nextDate()?.toISO()
      })),
      seenCount: this.seen.size
    };
    return this.createResult(true, status, void 0, 1, "Status retrieved");
  }
  createHunter(config) {
    switch (config.source) {
      // Social/Tech Sources
      case "github":
        return new GitHubHunter(config);
      case "hackernews":
        return new HackerNewsHunter(config);
      case "twitter":
        return new TwitterHunter(config);
      case "reddit":
        return new RedditHunter(config);
      case "producthunt":
        return new ProductHuntHunter(config);
      case "arxiv":
        return new ArxivHunter(config);
      case "lobsters":
        return new LobstersHunter(config);
      case "devto":
        return new DevToHunter(config);
      case "tiktok":
        return new TikTokHunter(config);
      // DeFi/Crypto Sources
      case "defillama":
        return new DeFiLlamaHunter(config);
      case "geckoterminal":
        return new GeckoTerminalHunter(config);
      case "feargreed":
        return new FearGreedHunter(config);
      case "binance":
        return new BinanceHunter(config);
      // Economic/Financial Sources
      case "fred":
        return new FREDHunter(config);
      case "sec":
        return new SECHunter(config);
      case "finnhub":
        return new FinnhubHunter(config);
      // Alternative Sources
      case "npm":
        return new NPMHunter(config);
      default:
        this.log(`Unknown source: ${config.source}`);
        return null;
    }
  }
  getSchedule(source) {
    const config = this.findSourceConfig(source);
    return config?.schedule ?? DEFAULT_SCHEDULES[source];
  }
  findSourceConfig(source) {
    const agentConfig = this.config;
    return agentConfig.sources.find((s) => s.source === source);
  }
  hasSeen(fingerprint) {
    const timestamp = this.seen.get(fingerprint);
    if (!timestamp) return false;
    if (Date.now() - timestamp > this.deduplicationTTL) {
      this.seen.delete(fingerprint);
      return false;
    }
    return true;
  }
  markSeen(fingerprint) {
    this.seen.set(fingerprint, Date.now());
    if (this.seen.size > 1e4) {
      this.cleanupSeen();
    }
  }
  cleanupSeen() {
    const now = Date.now();
    for (const [fingerprint, timestamp] of this.seen) {
      if (now - timestamp > this.deduplicationTTL) {
        this.seen.delete(fingerprint);
      }
    }
  }
};
export {
  ArxivHunter,
  DEFAULT_SCHEDULES,
  DevToHunter,
  GitHubHunter,
  GitHubRepoSchema,
  HNItemSchema,
  HackerNewsHunter,
  HuntDiscoverySchema,
  HuntSourceSchema,
  HunterAgent,
  LobstersHunter,
  NitterHunter,
  ProductHuntHunter,
  RELEVANCE_KEYWORDS,
  RawDiscoverySchema,
  RedditHunter,
  TikTokHunter,
  TwitterHunter,
  TwitterTweetSchema
};
//# sourceMappingURL=index.js.map