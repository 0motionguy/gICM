/**
 * Retry with exponential backoff
 */
interface RetryConfig {
    maxAttempts: number;
    initialDelay: number;
    maxDelay: number;
    backoffFactor: number;
    jitter: boolean;
    shouldRetry?: (error: Error, attempt: number) => boolean;
    onRetry?: (error: Error, attempt: number, delay: number) => void;
}
declare function calculateDelay(attempt: number, config: RetryConfig): number;
declare function withRetry<T>(fn: () => Promise<T>, config?: Partial<RetryConfig>): Promise<T>;
/**
 * Retry decorator for class methods
 */
declare function Retry(config?: Partial<RetryConfig>): (_target: unknown, _propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;

/**
 * Circuit Breaker pattern to prevent cascade failures
 */
declare enum CircuitState {
    CLOSED = "CLOSED",
    OPEN = "OPEN",
    HALF_OPEN = "HALF_OPEN"
}
interface CircuitBreakerConfig {
    name: string;
    failureThreshold: number;
    successThreshold: number;
    timeout: number;
    onStateChange?: (from: CircuitState, to: CircuitState) => void;
    onFailure?: (error: Error) => void;
}
declare class CircuitBreakerOpenError extends Error {
    constructor(name: string);
}
declare class CircuitBreaker {
    private state;
    private failureCount;
    private successCount;
    private nextAttemptTime;
    private config;
    constructor(config: Partial<CircuitBreakerConfig> & {
        name: string;
    });
    execute<T>(fn: () => Promise<T>): Promise<T>;
    private canExecute;
    private onSuccess;
    private onFailure;
    private transition;
    getState(): CircuitState;
    getStats(): {
        state: CircuitState;
        failures: number;
        successes: number;
        nextAttemptTime: number | null;
    };
    reset(): void;
    forceOpen(): void;
}

/**
 * Health monitoring for services
 */
interface HealthCheck {
    name: string;
    check: () => Promise<boolean>;
    critical?: boolean;
    timeout?: number;
}
type HealthStatus = "healthy" | "degraded" | "unhealthy";
interface CheckResult {
    status: "pass" | "fail";
    responseTime: number;
    error?: string;
    critical: boolean;
}
interface HealthResult {
    status: HealthStatus;
    checks: Record<string, CheckResult>;
    timestamp: string;
    uptime: number;
}
declare class HealthMonitor {
    private checks;
    private startTime;
    register(check: HealthCheck): void;
    unregister(name: string): void;
    runCheck(check: HealthCheck): Promise<CheckResult>;
    getStatus(): Promise<HealthResult>;
    isHealthy(): boolean;
    getUptime(): number;
    listChecks(): string[];
}
/**
 * Create a simple health check function
 */
declare function createHealthCheck(name: string, check: () => Promise<boolean>, options?: {
    critical?: boolean;
    timeout?: number;
}): HealthCheck;

/**
 * LIVE mode trading guards to prevent excessive losses
 */
interface LiveModeConfig {
    maxPositionUsd: number;
    maxDailyLossUsd: number;
    maxDrawdownPercent: number;
    requireApproval: boolean;
    coolDownAfterLossMs: number;
    allowedTokens?: string[];
    blockedTokens: string[];
}
interface TradeRequest {
    token: string;
    side: "buy" | "sell";
    amountUsd: number;
    source: string;
}
interface GuardResult {
    allowed: boolean;
    reason?: string;
    requiresApproval?: boolean;
    approvalId?: string;
    warnings: string[];
}
interface PendingApproval {
    id: string;
    request: TradeRequest;
    createdAt: number;
}
declare class LiveModeGuard {
    private config;
    private dailyPnL;
    private lastLossTime;
    private pendingApprovals;
    private dailyPnLResetTime;
    constructor(config?: Partial<LiveModeConfig>);
    checkTrade(request: TradeRequest): GuardResult;
    approveTradeById(approvalId: string): TradeRequest | null;
    rejectTradeById(approvalId: string): void;
    recordTradeResult(pnl: number): void;
    getStatus(): {
        dailyPnL: number;
        inCoolDown: boolean;
        coolDownRemainingMs: number;
        pendingApprovals: number;
        config: LiveModeConfig;
    };
    getPendingApprovals(): PendingApproval[];
    resetDailyPnL(): void;
    clearCoolDown(): void;
    private getNextMidnightUTC;
}

/**
 * Resilience utilities for gICM platform
 *
 * Provides:
 * - Retry with exponential backoff
 * - Circuit breaker pattern
 * - Health monitoring
 * - LIVE mode trading guards
 */

declare function withResilience<T>(fn: () => Promise<T>, options?: {
    retry?: Partial<RetryConfig>;
    circuitBreaker?: CircuitBreaker;
}): Promise<T>;

export { type CheckResult, CircuitBreaker, type CircuitBreakerConfig, CircuitBreakerOpenError, CircuitState, type GuardResult, type HealthCheck, HealthMonitor, type HealthResult, type HealthStatus, type LiveModeConfig, LiveModeGuard, type PendingApproval, Retry, type RetryConfig, type TradeRequest, calculateDelay, createHealthCheck, withResilience, withRetry };
