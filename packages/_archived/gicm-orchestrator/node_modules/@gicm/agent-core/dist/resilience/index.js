// src/resilience/retry.ts
var DEFAULT_CONFIG = {
  maxAttempts: 3,
  initialDelay: 1e3,
  maxDelay: 3e4,
  backoffFactor: 2,
  jitter: true
};
function calculateDelay(attempt, config) {
  let delay = config.initialDelay * Math.pow(config.backoffFactor, attempt);
  delay = Math.min(delay, config.maxDelay);
  if (config.jitter) {
    const jitterRange = delay * 0.25;
    delay = delay - jitterRange + Math.random() * jitterRange * 2;
  }
  return Math.floor(delay);
}
async function withRetry(fn, config) {
  const cfg = { ...DEFAULT_CONFIG, ...config };
  let lastError = new Error("No attempts made");
  for (let attempt = 0; attempt < cfg.maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (cfg.shouldRetry && !cfg.shouldRetry(lastError, attempt)) {
        throw lastError;
      }
      if (attempt >= cfg.maxAttempts - 1) {
        throw lastError;
      }
      const delay = calculateDelay(attempt, cfg);
      if (cfg.onRetry) {
        cfg.onRetry(lastError, attempt + 1, delay);
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  throw lastError;
}
function Retry(config) {
  return function(_target, _propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = async function(...args) {
      return withRetry(() => originalMethod.apply(this, args), config);
    };
    return descriptor;
  };
}

// src/resilience/circuit-breaker.ts
var CircuitState = /* @__PURE__ */ ((CircuitState2) => {
  CircuitState2["CLOSED"] = "CLOSED";
  CircuitState2["OPEN"] = "OPEN";
  CircuitState2["HALF_OPEN"] = "HALF_OPEN";
  return CircuitState2;
})(CircuitState || {});
var DEFAULT_CONFIG2 = {
  failureThreshold: 5,
  successThreshold: 2,
  timeout: 6e4
};
var CircuitBreakerOpenError = class extends Error {
  constructor(name) {
    super(`Circuit breaker "${name}" is OPEN`);
    this.name = "CircuitBreakerOpenError";
  }
};
var CircuitBreaker = class {
  state = "CLOSED" /* CLOSED */;
  failureCount = 0;
  successCount = 0;
  nextAttemptTime = 0;
  config;
  constructor(config) {
    this.config = { ...DEFAULT_CONFIG2, ...config };
  }
  async execute(fn) {
    if (!this.canExecute()) {
      throw new CircuitBreakerOpenError(this.config.name);
    }
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure(error instanceof Error ? error : new Error(String(error)));
      throw error;
    }
  }
  canExecute() {
    switch (this.state) {
      case "CLOSED" /* CLOSED */:
        return true;
      case "OPEN" /* OPEN */:
        if (Date.now() >= this.nextAttemptTime) {
          this.transition("HALF_OPEN" /* HALF_OPEN */);
          return true;
        }
        return false;
      case "HALF_OPEN" /* HALF_OPEN */:
        return true;
      default:
        return false;
    }
  }
  onSuccess() {
    switch (this.state) {
      case "HALF_OPEN" /* HALF_OPEN */:
        this.successCount++;
        if (this.successCount >= this.config.successThreshold) {
          this.transition("CLOSED" /* CLOSED */);
        }
        break;
      case "CLOSED" /* CLOSED */:
        this.failureCount = 0;
        break;
    }
  }
  onFailure(error) {
    if (this.config.onFailure) {
      this.config.onFailure(error);
    }
    switch (this.state) {
      case "CLOSED" /* CLOSED */:
        this.failureCount++;
        if (this.failureCount >= this.config.failureThreshold) {
          this.transition("OPEN" /* OPEN */);
        }
        break;
      case "HALF_OPEN" /* HALF_OPEN */:
        this.transition("OPEN" /* OPEN */);
        break;
    }
  }
  transition(newState) {
    const oldState = this.state;
    this.state = newState;
    this.failureCount = 0;
    this.successCount = 0;
    if (newState === "OPEN" /* OPEN */) {
      this.nextAttemptTime = Date.now() + this.config.timeout;
    }
    if (this.config.onStateChange) {
      this.config.onStateChange(oldState, newState);
    }
  }
  getState() {
    return this.state;
  }
  getStats() {
    return {
      state: this.state,
      failures: this.failureCount,
      successes: this.successCount,
      nextAttemptTime: this.state === "OPEN" /* OPEN */ ? this.nextAttemptTime : null
    };
  }
  reset() {
    this.transition("CLOSED" /* CLOSED */);
  }
  forceOpen() {
    this.transition("OPEN" /* OPEN */);
  }
};

// src/resilience/health-check.ts
var DEFAULT_TIMEOUT = 5e3;
var HealthMonitor = class {
  checks = /* @__PURE__ */ new Map();
  startTime = Date.now();
  register(check) {
    this.checks.set(check.name, {
      ...check,
      timeout: check.timeout ?? DEFAULT_TIMEOUT,
      critical: check.critical ?? false
    });
  }
  unregister(name) {
    this.checks.delete(name);
  }
  async runCheck(check) {
    const startTime = Date.now();
    try {
      const result = await Promise.race([
        check.check(),
        new Promise(
          (_, reject) => setTimeout(
            () => reject(new Error("Health check timeout")),
            check.timeout ?? DEFAULT_TIMEOUT
          )
        )
      ]);
      return {
        status: result ? "pass" : "fail",
        responseTime: Date.now() - startTime,
        critical: check.critical ?? false
      };
    } catch (error) {
      return {
        status: "fail",
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error),
        critical: check.critical ?? false
      };
    }
  }
  async getStatus() {
    const results = {};
    let hasCriticalFailure = false;
    let hasNonCriticalFailure = false;
    const checkPromises = Array.from(this.checks.entries()).map(
      async ([name, check]) => {
        const result = await this.runCheck(check);
        results[name] = result;
        if (result.status === "fail") {
          if (result.critical) {
            hasCriticalFailure = true;
          } else {
            hasNonCriticalFailure = true;
          }
        }
      }
    );
    await Promise.all(checkPromises);
    let status;
    if (hasCriticalFailure) {
      status = "unhealthy";
    } else if (hasNonCriticalFailure) {
      status = "degraded";
    } else {
      status = "healthy";
    }
    return {
      status,
      checks: results,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: Date.now() - this.startTime
    };
  }
  isHealthy() {
    return true;
  }
  getUptime() {
    return Date.now() - this.startTime;
  }
  listChecks() {
    return Array.from(this.checks.keys());
  }
};
function createHealthCheck(name, check, options) {
  return {
    name,
    check,
    critical: options?.critical ?? false,
    timeout: options?.timeout ?? DEFAULT_TIMEOUT
  };
}

// src/resilience/live-guards.ts
var DEFAULT_CONFIG3 = {
  maxPositionUsd: 1e3,
  maxDailyLossUsd: 100,
  maxDrawdownPercent: 10,
  requireApproval: true,
  coolDownAfterLossMs: 36e5,
  // 1 hour
  blockedTokens: []
};
var LiveModeGuard = class {
  config;
  dailyPnL = 0;
  lastLossTime = 0;
  pendingApprovals = /* @__PURE__ */ new Map();
  dailyPnLResetTime;
  constructor(config) {
    this.config = { ...DEFAULT_CONFIG3, ...config };
    this.dailyPnLResetTime = this.getNextMidnightUTC();
  }
  checkTrade(request) {
    const warnings = [];
    if (Date.now() > this.dailyPnLResetTime) {
      this.dailyPnL = 0;
      this.dailyPnLResetTime = this.getNextMidnightUTC();
    }
    if (this.lastLossTime > 0) {
      const coolDownRemaining = this.lastLossTime + this.config.coolDownAfterLossMs - Date.now();
      if (coolDownRemaining > 0) {
        return {
          allowed: false,
          reason: `In cool-down period after loss. ${Math.ceil(coolDownRemaining / 6e4)} minutes remaining.`,
          warnings
        };
      }
    }
    if (this.config.blockedTokens.includes(request.token)) {
      return {
        allowed: false,
        reason: `Token ${request.token} is blocked`,
        warnings
      };
    }
    if (this.config.allowedTokens && !this.config.allowedTokens.includes(request.token)) {
      return {
        allowed: false,
        reason: `Token ${request.token} not in allowed list`,
        warnings
      };
    }
    if (request.amountUsd > this.config.maxPositionUsd) {
      return {
        allowed: false,
        reason: `Position $${request.amountUsd} exceeds max $${this.config.maxPositionUsd}`,
        warnings
      };
    }
    if (this.dailyPnL < -this.config.maxDailyLossUsd) {
      return {
        allowed: false,
        reason: `Daily loss limit reached: $${Math.abs(this.dailyPnL).toFixed(2)}`,
        warnings
      };
    }
    if (request.amountUsd > this.config.maxPositionUsd * 0.5) {
      warnings.push(
        `Large position: ${(request.amountUsd / this.config.maxPositionUsd * 100).toFixed(0)}% of max`
      );
    }
    if (this.dailyPnL < -this.config.maxDailyLossUsd * 0.5) {
      warnings.push(
        `Approaching daily loss limit: $${Math.abs(this.dailyPnL).toFixed(2)} of $${this.config.maxDailyLossUsd}`
      );
    }
    if (this.config.requireApproval) {
      const approvalId = `${request.token}-${request.side}-${Date.now()}`;
      this.pendingApprovals.set(approvalId, {
        id: approvalId,
        request,
        createdAt: Date.now()
      });
      return {
        allowed: false,
        requiresApproval: true,
        approvalId,
        reason: `Requires human approval (ID: ${approvalId})`,
        warnings
      };
    }
    return { allowed: true, warnings };
  }
  approveTradeById(approvalId) {
    const approval = this.pendingApprovals.get(approvalId);
    if (approval) {
      this.pendingApprovals.delete(approvalId);
      return approval.request;
    }
    return null;
  }
  rejectTradeById(approvalId) {
    this.pendingApprovals.delete(approvalId);
  }
  recordTradeResult(pnl) {
    this.dailyPnL += pnl;
    if (pnl < 0) {
      this.lastLossTime = Date.now();
    }
  }
  getStatus() {
    const inCoolDown = this.lastLossTime > 0 && Date.now() < this.lastLossTime + this.config.coolDownAfterLossMs;
    return {
      dailyPnL: this.dailyPnL,
      inCoolDown,
      coolDownRemainingMs: inCoolDown ? this.lastLossTime + this.config.coolDownAfterLossMs - Date.now() : 0,
      pendingApprovals: this.pendingApprovals.size,
      config: this.config
    };
  }
  getPendingApprovals() {
    return Array.from(this.pendingApprovals.values());
  }
  resetDailyPnL() {
    this.dailyPnL = 0;
    this.dailyPnLResetTime = this.getNextMidnightUTC();
  }
  clearCoolDown() {
    this.lastLossTime = 0;
  }
  getNextMidnightUTC() {
    const now = /* @__PURE__ */ new Date();
    const tomorrow = new Date(
      Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0,
        0,
        0,
        0
      )
    );
    return tomorrow.getTime();
  }
};

// src/resilience/index.ts
async function withResilience(fn, options) {
  const execute = async () => {
    if (options?.circuitBreaker) {
      return options.circuitBreaker.execute(fn);
    }
    return fn();
  };
  if (options?.retry) {
    return withRetry(execute, options.retry);
  }
  return execute();
}
export {
  CircuitBreaker,
  CircuitBreakerOpenError,
  CircuitState,
  HealthMonitor,
  LiveModeGuard,
  Retry,
  calculateDelay,
  createHealthCheck,
  withResilience,
  withRetry
};
//# sourceMappingURL=index.js.map