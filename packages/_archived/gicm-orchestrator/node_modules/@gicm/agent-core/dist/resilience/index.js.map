{"version":3,"sources":["../../src/resilience/retry.ts","../../src/resilience/circuit-breaker.ts","../../src/resilience/health-check.ts","../../src/resilience/live-guards.ts","../../src/resilience/index.ts"],"sourcesContent":["/**\n * Retry with exponential backoff\n */\n\nexport interface RetryConfig {\n  maxAttempts: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n  jitter: boolean;\n  shouldRetry?: (error: Error, attempt: number) => boolean;\n  onRetry?: (error: Error, attempt: number, delay: number) => void;\n}\n\nconst DEFAULT_CONFIG: RetryConfig = {\n  maxAttempts: 3,\n  initialDelay: 1000,\n  maxDelay: 30000,\n  backoffFactor: 2,\n  jitter: true,\n};\n\nexport function calculateDelay(attempt: number, config: RetryConfig): number {\n  let delay = config.initialDelay * Math.pow(config.backoffFactor, attempt);\n  delay = Math.min(delay, config.maxDelay);\n\n  if (config.jitter) {\n    // Add +/- 25% jitter\n    const jitterRange = delay * 0.25;\n    delay = delay - jitterRange + Math.random() * jitterRange * 2;\n  }\n\n  return Math.floor(delay);\n}\n\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  config?: Partial<RetryConfig>\n): Promise<T> {\n  const cfg: RetryConfig = { ...DEFAULT_CONFIG, ...config };\n  let lastError: Error = new Error(\"No attempts made\");\n\n  for (let attempt = 0; attempt < cfg.maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Check if we should retry\n      if (cfg.shouldRetry && !cfg.shouldRetry(lastError, attempt)) {\n        throw lastError;\n      }\n\n      // Last attempt - don't delay, just throw\n      if (attempt >= cfg.maxAttempts - 1) {\n        throw lastError;\n      }\n\n      // Calculate delay\n      const delay = calculateDelay(attempt, cfg);\n\n      // Notify\n      if (cfg.onRetry) {\n        cfg.onRetry(lastError, attempt + 1, delay);\n      }\n\n      // Wait before retry\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Retry decorator for class methods\n */\nexport function Retry(config?: Partial<RetryConfig>) {\n  return function (\n    _target: unknown,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: unknown[]) {\n      return withRetry(() => originalMethod.apply(this, args), config);\n    };\n\n    return descriptor;\n  };\n}\n","/**\n * Circuit Breaker pattern to prevent cascade failures\n */\n\nexport enum CircuitState {\n  CLOSED = \"CLOSED\",\n  OPEN = \"OPEN\",\n  HALF_OPEN = \"HALF_OPEN\",\n}\n\nexport interface CircuitBreakerConfig {\n  name: string;\n  failureThreshold: number;\n  successThreshold: number;\n  timeout: number;\n  onStateChange?: (from: CircuitState, to: CircuitState) => void;\n  onFailure?: (error: Error) => void;\n}\n\nconst DEFAULT_CONFIG: Omit<CircuitBreakerConfig, \"name\"> = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 60000,\n};\n\nexport class CircuitBreakerOpenError extends Error {\n  constructor(name: string) {\n    super(`Circuit breaker \"${name}\" is OPEN`);\n    this.name = \"CircuitBreakerOpenError\";\n  }\n}\n\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttemptTime = 0;\n  private config: CircuitBreakerConfig;\n\n  constructor(config: Partial<CircuitBreakerConfig> & { name: string }) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    // Check if we should allow the request\n    if (!this.canExecute()) {\n      throw new CircuitBreakerOpenError(this.config.name);\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure(error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n\n  private canExecute(): boolean {\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        return true;\n\n      case CircuitState.OPEN:\n        // Check if timeout has passed\n        if (Date.now() >= this.nextAttemptTime) {\n          this.transition(CircuitState.HALF_OPEN);\n          return true;\n        }\n        return false;\n\n      case CircuitState.HALF_OPEN:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  private onSuccess(): void {\n    switch (this.state) {\n      case CircuitState.HALF_OPEN:\n        this.successCount++;\n        if (this.successCount >= this.config.successThreshold) {\n          this.transition(CircuitState.CLOSED);\n        }\n        break;\n\n      case CircuitState.CLOSED:\n        // Reset failure count on success\n        this.failureCount = 0;\n        break;\n    }\n  }\n\n  private onFailure(error: Error): void {\n    if (this.config.onFailure) {\n      this.config.onFailure(error);\n    }\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        this.failureCount++;\n        if (this.failureCount >= this.config.failureThreshold) {\n          this.transition(CircuitState.OPEN);\n        }\n        break;\n\n      case CircuitState.HALF_OPEN:\n        // Single failure in half-open returns to open\n        this.transition(CircuitState.OPEN);\n        break;\n    }\n  }\n\n  private transition(newState: CircuitState): void {\n    const oldState = this.state;\n    this.state = newState;\n\n    // Reset counters\n    this.failureCount = 0;\n    this.successCount = 0;\n\n    // Set next attempt time for OPEN state\n    if (newState === CircuitState.OPEN) {\n      this.nextAttemptTime = Date.now() + this.config.timeout;\n    }\n\n    // Notify\n    if (this.config.onStateChange) {\n      this.config.onStateChange(oldState, newState);\n    }\n  }\n\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  getStats(): {\n    state: CircuitState;\n    failures: number;\n    successes: number;\n    nextAttemptTime: number | null;\n  } {\n    return {\n      state: this.state,\n      failures: this.failureCount,\n      successes: this.successCount,\n      nextAttemptTime:\n        this.state === CircuitState.OPEN ? this.nextAttemptTime : null,\n    };\n  }\n\n  reset(): void {\n    this.transition(CircuitState.CLOSED);\n  }\n\n  forceOpen(): void {\n    this.transition(CircuitState.OPEN);\n  }\n}\n","/**\n * Health monitoring for services\n */\n\nexport interface HealthCheck {\n  name: string;\n  check: () => Promise<boolean>;\n  critical?: boolean;\n  timeout?: number;\n}\n\nexport type HealthStatus = \"healthy\" | \"degraded\" | \"unhealthy\";\n\nexport interface CheckResult {\n  status: \"pass\" | \"fail\";\n  responseTime: number;\n  error?: string;\n  critical: boolean;\n}\n\nexport interface HealthResult {\n  status: HealthStatus;\n  checks: Record<string, CheckResult>;\n  timestamp: string;\n  uptime: number;\n}\n\nconst DEFAULT_TIMEOUT = 5000;\n\nexport class HealthMonitor {\n  private checks: Map<string, HealthCheck> = new Map();\n  private startTime = Date.now();\n\n  register(check: HealthCheck): void {\n    this.checks.set(check.name, {\n      ...check,\n      timeout: check.timeout ?? DEFAULT_TIMEOUT,\n      critical: check.critical ?? false,\n    });\n  }\n\n  unregister(name: string): void {\n    this.checks.delete(name);\n  }\n\n  async runCheck(check: HealthCheck): Promise<CheckResult> {\n    const startTime = Date.now();\n\n    try {\n      // Run check with timeout\n      const result = await Promise.race([\n        check.check(),\n        new Promise<boolean>((_, reject) =>\n          setTimeout(\n            () => reject(new Error(\"Health check timeout\")),\n            check.timeout ?? DEFAULT_TIMEOUT\n          )\n        ),\n      ]);\n\n      return {\n        status: result ? \"pass\" : \"fail\",\n        responseTime: Date.now() - startTime,\n        critical: check.critical ?? false,\n      };\n    } catch (error) {\n      return {\n        status: \"fail\",\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error),\n        critical: check.critical ?? false,\n      };\n    }\n  }\n\n  async getStatus(): Promise<HealthResult> {\n    const results: Record<string, CheckResult> = {};\n    let hasCriticalFailure = false;\n    let hasNonCriticalFailure = false;\n\n    // Run all checks in parallel\n    const checkPromises = Array.from(this.checks.entries()).map(\n      async ([name, check]) => {\n        const result = await this.runCheck(check);\n        results[name] = result;\n\n        if (result.status === \"fail\") {\n          if (result.critical) {\n            hasCriticalFailure = true;\n          } else {\n            hasNonCriticalFailure = true;\n          }\n        }\n      }\n    );\n\n    await Promise.all(checkPromises);\n\n    // Determine overall status\n    let status: HealthStatus;\n    if (hasCriticalFailure) {\n      status = \"unhealthy\";\n    } else if (hasNonCriticalFailure) {\n      status = \"degraded\";\n    } else {\n      status = \"healthy\";\n    }\n\n    return {\n      status,\n      checks: results,\n      timestamp: new Date().toISOString(),\n      uptime: Date.now() - this.startTime,\n    };\n  }\n\n  isHealthy(): boolean {\n    // Quick check - returns false if any critical check would fail\n    // Note: This is synchronous and uses cached state if available\n    return true; // Override with actual cached state in production\n  }\n\n  getUptime(): number {\n    return Date.now() - this.startTime;\n  }\n\n  listChecks(): string[] {\n    return Array.from(this.checks.keys());\n  }\n}\n\n/**\n * Create a simple health check function\n */\nexport function createHealthCheck(\n  name: string,\n  check: () => Promise<boolean>,\n  options?: { critical?: boolean; timeout?: number }\n): HealthCheck {\n  return {\n    name,\n    check,\n    critical: options?.critical ?? false,\n    timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n  };\n}\n","/**\n * LIVE mode trading guards to prevent excessive losses\n */\n\nexport interface LiveModeConfig {\n  maxPositionUsd: number;\n  maxDailyLossUsd: number;\n  maxDrawdownPercent: number;\n  requireApproval: boolean;\n  coolDownAfterLossMs: number;\n  allowedTokens?: string[];\n  blockedTokens: string[];\n}\n\nconst DEFAULT_CONFIG: LiveModeConfig = {\n  maxPositionUsd: 1000,\n  maxDailyLossUsd: 100,\n  maxDrawdownPercent: 10,\n  requireApproval: true,\n  coolDownAfterLossMs: 3600000, // 1 hour\n  blockedTokens: [],\n};\n\nexport interface TradeRequest {\n  token: string;\n  side: \"buy\" | \"sell\";\n  amountUsd: number;\n  source: string;\n}\n\nexport interface GuardResult {\n  allowed: boolean;\n  reason?: string;\n  requiresApproval?: boolean;\n  approvalId?: string;\n  warnings: string[];\n}\n\nexport interface PendingApproval {\n  id: string;\n  request: TradeRequest;\n  createdAt: number;\n}\n\nexport class LiveModeGuard {\n  private config: LiveModeConfig;\n  private dailyPnL = 0;\n  private lastLossTime = 0;\n  private pendingApprovals: Map<string, PendingApproval> = new Map();\n  private dailyPnLResetTime: number;\n\n  constructor(config?: Partial<LiveModeConfig>) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.dailyPnLResetTime = this.getNextMidnightUTC();\n  }\n\n  checkTrade(request: TradeRequest): GuardResult {\n    const warnings: string[] = [];\n\n    // Check daily reset\n    if (Date.now() > this.dailyPnLResetTime) {\n      this.dailyPnL = 0;\n      this.dailyPnLResetTime = this.getNextMidnightUTC();\n    }\n\n    // Check cool-down period\n    if (this.lastLossTime > 0) {\n      const coolDownRemaining =\n        this.lastLossTime + this.config.coolDownAfterLossMs - Date.now();\n      if (coolDownRemaining > 0) {\n        return {\n          allowed: false,\n          reason: `In cool-down period after loss. ${Math.ceil(coolDownRemaining / 60000)} minutes remaining.`,\n          warnings,\n        };\n      }\n    }\n\n    // Check blocked tokens\n    if (this.config.blockedTokens.includes(request.token)) {\n      return {\n        allowed: false,\n        reason: `Token ${request.token} is blocked`,\n        warnings,\n      };\n    }\n\n    // Check allowed tokens (if specified)\n    if (\n      this.config.allowedTokens &&\n      !this.config.allowedTokens.includes(request.token)\n    ) {\n      return {\n        allowed: false,\n        reason: `Token ${request.token} not in allowed list`,\n        warnings,\n      };\n    }\n\n    // Check position size\n    if (request.amountUsd > this.config.maxPositionUsd) {\n      return {\n        allowed: false,\n        reason: `Position $${request.amountUsd} exceeds max $${this.config.maxPositionUsd}`,\n        warnings,\n      };\n    }\n\n    // Check daily loss limit\n    if (this.dailyPnL < -this.config.maxDailyLossUsd) {\n      return {\n        allowed: false,\n        reason: `Daily loss limit reached: $${Math.abs(this.dailyPnL).toFixed(2)}`,\n        warnings,\n      };\n    }\n\n    // Add warnings for risky trades\n    if (request.amountUsd > this.config.maxPositionUsd * 0.5) {\n      warnings.push(\n        `Large position: ${((request.amountUsd / this.config.maxPositionUsd) * 100).toFixed(0)}% of max`\n      );\n    }\n\n    if (this.dailyPnL < -this.config.maxDailyLossUsd * 0.5) {\n      warnings.push(\n        `Approaching daily loss limit: $${Math.abs(this.dailyPnL).toFixed(2)} of $${this.config.maxDailyLossUsd}`\n      );\n    }\n\n    // Check if approval required\n    if (this.config.requireApproval) {\n      const approvalId = `${request.token}-${request.side}-${Date.now()}`;\n      this.pendingApprovals.set(approvalId, {\n        id: approvalId,\n        request,\n        createdAt: Date.now(),\n      });\n\n      return {\n        allowed: false,\n        requiresApproval: true,\n        approvalId,\n        reason: `Requires human approval (ID: ${approvalId})`,\n        warnings,\n      };\n    }\n\n    return { allowed: true, warnings };\n  }\n\n  approveTradeById(approvalId: string): TradeRequest | null {\n    const approval = this.pendingApprovals.get(approvalId);\n    if (approval) {\n      this.pendingApprovals.delete(approvalId);\n      return approval.request;\n    }\n    return null;\n  }\n\n  rejectTradeById(approvalId: string): void {\n    this.pendingApprovals.delete(approvalId);\n  }\n\n  recordTradeResult(pnl: number): void {\n    this.dailyPnL += pnl;\n    if (pnl < 0) {\n      this.lastLossTime = Date.now();\n    }\n  }\n\n  getStatus(): {\n    dailyPnL: number;\n    inCoolDown: boolean;\n    coolDownRemainingMs: number;\n    pendingApprovals: number;\n    config: LiveModeConfig;\n  } {\n    const inCoolDown =\n      this.lastLossTime > 0 &&\n      Date.now() < this.lastLossTime + this.config.coolDownAfterLossMs;\n\n    return {\n      dailyPnL: this.dailyPnL,\n      inCoolDown,\n      coolDownRemainingMs: inCoolDown\n        ? this.lastLossTime + this.config.coolDownAfterLossMs - Date.now()\n        : 0,\n      pendingApprovals: this.pendingApprovals.size,\n      config: this.config,\n    };\n  }\n\n  getPendingApprovals(): PendingApproval[] {\n    return Array.from(this.pendingApprovals.values());\n  }\n\n  resetDailyPnL(): void {\n    this.dailyPnL = 0;\n    this.dailyPnLResetTime = this.getNextMidnightUTC();\n  }\n\n  clearCoolDown(): void {\n    this.lastLossTime = 0;\n  }\n\n  private getNextMidnightUTC(): number {\n    const now = new Date();\n    const tomorrow = new Date(\n      Date.UTC(\n        now.getUTCFullYear(),\n        now.getUTCMonth(),\n        now.getUTCDate() + 1,\n        0,\n        0,\n        0,\n        0\n      )\n    );\n    return tomorrow.getTime();\n  }\n}\n","/**\n * Resilience utilities for gICM platform\n *\n * Provides:\n * - Retry with exponential backoff\n * - Circuit breaker pattern\n * - Health monitoring\n * - LIVE mode trading guards\n */\n\n// Retry\nexport { withRetry, calculateDelay, Retry } from \"./retry.js\";\nexport type { RetryConfig } from \"./retry.js\";\n\n// Circuit Breaker\nexport {\n  CircuitBreaker,\n  CircuitBreakerOpenError,\n  CircuitState,\n} from \"./circuit-breaker.js\";\nexport type { CircuitBreakerConfig } from \"./circuit-breaker.js\";\n\n// Health Check\nexport { HealthMonitor, createHealthCheck } from \"./health-check.js\";\nexport type {\n  HealthCheck,\n  HealthStatus,\n  HealthResult,\n  CheckResult,\n} from \"./health-check.js\";\n\n// LIVE Mode Guards\nexport { LiveModeGuard } from \"./live-guards.js\";\nexport type {\n  LiveModeConfig,\n  TradeRequest,\n  GuardResult,\n  PendingApproval,\n} from \"./live-guards.js\";\n\n/**\n * Convenience function to wrap with both retry and circuit breaker\n */\nimport { withRetry, type RetryConfig } from \"./retry.js\";\nimport { CircuitBreaker } from \"./circuit-breaker.js\";\n\nexport async function withResilience<T>(\n  fn: () => Promise<T>,\n  options?: {\n    retry?: Partial<RetryConfig>;\n    circuitBreaker?: CircuitBreaker;\n  }\n): Promise<T> {\n  const execute = async () => {\n    if (options?.circuitBreaker) {\n      return options.circuitBreaker.execute(fn);\n    }\n    return fn();\n  };\n\n  if (options?.retry) {\n    return withRetry(execute, options.retry);\n  }\n\n  return execute();\n}\n"],"mappings":"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","names":["CircuitState","DEFAULT_CONFIG","DEFAULT_CONFIG"]}